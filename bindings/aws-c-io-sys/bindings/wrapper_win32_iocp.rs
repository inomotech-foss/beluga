/* automatically generated by rust-bindgen 0.69.1 */

pub type aws_io_message_type = ::core::ffi::c_uint;
pub type aws_channel_on_message_write_completed_fn = ::core::option::Option<
    unsafe extern "C" fn(
        channel: *mut aws_channel,
        message: *mut aws_io_message,
        err_code: ::core::ffi::c_int,
        user_data: *mut ::core::ffi::c_void,
    ),
>;
pub type aws_io_clock_fn =
    ::core::option::Option<unsafe extern "C" fn(timestamp: *mut u64) -> ::core::ffi::c_int>;
pub type aws_io_errors = ::core::ffi::c_uint;
pub type aws_channel_direction = ::core::ffi::c_uint;
pub type aws_channel_on_setup_completed_fn = ::core::option::Option<
    unsafe extern "C" fn(
        channel: *mut aws_channel,
        error_code: ::core::ffi::c_int,
        user_data: *mut ::core::ffi::c_void,
    ),
>;
pub type aws_channel_on_shutdown_completed_fn = ::core::option::Option<
    unsafe extern "C" fn(
        channel: *mut aws_channel,
        error_code: ::core::ffi::c_int,
        user_data: *mut ::core::ffi::c_void,
    ),
>;
pub type aws_channel_task_fn = ::core::option::Option<
    unsafe extern "C" fn(
        channel_task: *mut aws_channel_task,
        arg: *mut ::core::ffi::c_void,
        status: aws_task_status,
    ),
>;
pub type aws_address_record_type = ::core::ffi::c_uint;
pub type aws_get_host_address_flags = ::core::ffi::c_uint;
#[doc = " Invoked once an address has been resolved for host. The type in host_addresses is struct aws_host_address (by-value).\n The caller does not own this memory and you must copy the host address before returning from this function if you\n plan to use it later. For convenience, we've provided the aws_host_address_copy() and aws_host_address_clean_up()\n functions."]
pub type aws_on_host_resolved_result_fn = ::core::option::Option<
    unsafe extern "C" fn(
        resolver: *mut aws_host_resolver,
        host_name: *const aws_string,
        err_code: ::core::ffi::c_int,
        host_addresses: *const aws_array_list,
        user_data: *mut ::core::ffi::c_void,
    ),
>;
#[doc = " Function signature for configuring your own resolver (the default just uses getaddrinfo()). The type in\n output_addresses is struct aws_host_address (by-value). We assume this function blocks, hence this absurdly\n complicated design."]
pub type aws_resolve_host_implementation_fn = ::core::option::Option<
    unsafe extern "C" fn(
        allocator: *mut aws_allocator,
        host_name: *const aws_string,
        output_addresses: *mut aws_array_list,
        user_data: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int,
>;
#[doc = " Generic event function for channel lifecycle events.\n\n Callbacks are provided for:\n   (1) Channel creation\n   (2) Channel setup - If TLS is being used, this function is called once the socket has connected, the channel has\n been initialized, and TLS has been successfully negotiated. A TLS handler has already been added to the channel. If\n TLS negotiation fails, this function will be called with the corresponding error code. If TLS is not being used, this\n function is called once the socket has connected and the channel has been initialized.\n   (3) Channel shutdown\n\n These callbacks are always invoked within the thread of the event-loop that the channel is assigned to.\n\n This function does NOT always imply \"success\" -- if error_code is AWS_OP_SUCCESS then everything was successful,\n otherwise an error condition occurred."]
pub type aws_client_bootstrap_on_channel_event_fn = ::core::option::Option<
    unsafe extern "C" fn(
        bootstrap: *mut aws_client_bootstrap,
        error_code: ::core::ffi::c_int,
        channel: *mut aws_channel,
        user_data: *mut ::core::ffi::c_void,
    ),
>;
#[doc = " If ALPN is being used this function will be invoked by the channel once an ALPN message is received. The returned\n channel_handler will be added to, and managed by, the channel."]
pub type aws_channel_on_protocol_negotiated_fn = ::core::option::Option<
    unsafe extern "C" fn(
        new_slot: *mut aws_channel_slot,
        protocol: *mut aws_byte_buf,
        user_data: *mut ::core::ffi::c_void,
    ) -> *mut aws_channel_handler,
>;
#[doc = " Called after client bootstrap has been completely cleaned up, after its last refcount is released."]
pub type aws_client_bootstrap_shutdown_complete_fn =
    ::core::option::Option<unsafe extern "C" fn(user_data: *mut ::core::ffi::c_void)>;
#[doc = " If TLS is being used, this function is called once the socket has received an incoming connection, the channel has\n been initialized, and TLS has been successfully negotiated. A TLS handler has already been added to the channel. If\n TLS negotiation fails, this function will be called with the corresponding error code.\n\n If TLS is not being used, this function is called once the socket has received an incoming connection and the channel\n has been initialized.\n\n This function is always called within the thread of the event-loop that the new channel is assigned to upon success.\n\n On failure, the channel might not be assigned to an event loop yet, and will thus be invoked on the listener's\n event-loop thread.\n\n This function does NOT mean \"success\", if error_code is AWS_OP_SUCCESS then everything was successful, otherwise an\n error condition occurred.\n\n If an error occurred, you do not need to shutdown the channel. The `aws_channel_client_shutdown_callback` will be\n invoked once the channel has finished shutting down."]
pub type aws_server_bootstrap_on_accept_channel_setup_fn = ::core::option::Option<
    unsafe extern "C" fn(
        bootstrap: *mut aws_server_bootstrap,
        error_code: ::core::ffi::c_int,
        channel: *mut aws_channel,
        user_data: *mut ::core::ffi::c_void,
    ),
>;
#[doc = " Once the channel shuts down, this function will be invoked within the thread of\n the event-loop that the channel is assigned to.\n\n Note: this function is only invoked if the channel was successfully setup,\n e.g. aws_server_bootstrap_on_accept_channel_setup_fn() was invoked without an error code."]
pub type aws_server_bootstrap_on_accept_channel_shutdown_fn = ::core::option::Option<
    unsafe extern "C" fn(
        bootstrap: *mut aws_server_bootstrap,
        error_code: ::core::ffi::c_int,
        channel: *mut aws_channel,
        user_data: *mut ::core::ffi::c_void,
    ),
>;
#[doc = " Once the server listener socket is finished destroying, and all the existing connections are closed, this fuction\n will be invoked."]
pub type aws_server_bootstrap_on_server_listener_destroy_fn = ::core::option::Option<
    unsafe extern "C" fn(bootstrap: *mut aws_server_bootstrap, user_data: *mut ::core::ffi::c_void),
>;
pub type aws_io_event_type = ::core::ffi::c_uint;
pub type aws_event_loop_on_event_fn = ::core::option::Option<
    unsafe extern "C" fn(
        event_loop: *mut aws_event_loop,
        handle: *mut aws_io_handle,
        events: ::core::ffi::c_int,
        user_data: *mut ::core::ffi::c_void,
    ),
>;
pub type aws_event_loop_on_local_object_removed_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut aws_event_loop_local_object)>;
pub type aws_new_event_loop_fn = ::core::option::Option<
    unsafe extern "C" fn(
        alloc: *mut aws_allocator,
        options: *const aws_event_loop_options,
        new_loop_user_data: *mut ::core::ffi::c_void,
    ) -> *mut aws_event_loop,
>;
#[doc = " Completion callback for aws_future<T>"]
pub type aws_future_callback_fn =
    ::core::option::Option<unsafe extern "C" fn(user_data: *mut ::core::ffi::c_void)>;
pub type aws_future_impl_result_clean_up_fn =
    ::core::option::Option<unsafe extern "C" fn(result_addr: *mut ::core::ffi::c_void)>;
pub type aws_future_impl_result_destroy_fn =
    ::core::option::Option<unsafe extern "C" fn(result: *mut ::core::ffi::c_void)>;
pub type aws_future_impl_result_release_fn = ::core::option::Option<
    unsafe extern "C" fn(result: *mut ::core::ffi::c_void) -> *mut ::core::ffi::c_void,
>;
pub type aws_io_log_subject = ::core::ffi::c_uint;
pub type aws_pem_object_type = ::core::ffi::c_uint;
#[doc = " Callback for when the pipe is readable (edge-triggered), or an error has occurred.\n Afer subscribing, the callback is invoked when the pipe has data to read, or the pipe has an error.\n The readable callback is invoked again any time the user reads all data, and then more data arrives.\n Note that it will not be invoked again if the pipe still has unread data when more data arrives.\n `error_code` of AWS_ERROR_SUCCESS indicates a readable event, and otherwise contains the value of the error.\n `user_data` corresponds to the `user_data` passed into aws_pipe_subscribe_to_read_events().\n This callback is always invoked on the read-end's event-loop thread."]
pub type aws_pipe_on_readable_fn = ::core::option::Option<
    unsafe extern "C" fn(
        read_end: *mut aws_pipe_read_end,
        error_code: ::core::ffi::c_int,
        user_data: *mut ::core::ffi::c_void,
    ),
>;
#[doc = " Callback for when the asynchronous aws_pipe_write() operation has either completed or failed.\n `write_end` will be NULL if this callback is invoked after the the write-end has been cleaned up,\n this does not necessarily mean that the write operation failed.\n `error_code` will be AWS_ERROR_SUCCESS if all data was written, or a code corresponding to the error.\n `src_buffer` corresponds to the buffer passed into aws_pipe_write()\n `user_data` corresponds to the `user_data` passed into aws_pipe_write().\n This callback is always invoked on the write-end's event-loop thread."]
pub type aws_pipe_on_write_completed_fn = ::core::option::Option<
    unsafe extern "C" fn(
        write_end: *mut aws_pipe_write_end,
        error_code: ::core::ffi::c_int,
        src_buffer: aws_byte_cursor,
        user_data: *mut ::core::ffi::c_void,
    ),
>;
#[doc = " Controls how aws_pkcs11_lib calls C_Initialize() and C_Finalize() on the PKCS#11 library."]
pub type aws_pkcs11_lib_behavior = ::core::ffi::c_uint;
#[doc = " Invoked upon the acquisition, or failure to acquire a retry token. This function will always be invoked if and only\n if aws_retry_strategy_acquire_retry_token() returns AWS_OP_SUCCESS. It will never be invoked synchronously from\n aws_retry_strategy_acquire_retry_token(). Token will always be NULL if error_code is non-zero, and vice-versa. If\n token is non-null, it will have a reference count of 1, and you must call aws_retry_token_release() on it later. See\n the comments for aws_retry_strategy_on_retry_ready_fn for more info."]
pub type aws_retry_strategy_on_retry_token_acquired_fn = ::core::option::Option<
    unsafe extern "C" fn(
        retry_strategy: *mut aws_retry_strategy,
        error_code: ::core::ffi::c_int,
        token: *mut aws_retry_token,
        user_data: *mut ::core::ffi::c_void,
    ),
>;
#[doc = " Invoked after a successful call to aws_retry_strategy_schedule_retry(). This function will always be invoked if and\n only if aws_retry_strategy_schedule_retry() returns AWS_OP_SUCCESS. It will never be invoked synchronously from\n aws_retry_strategy_schedule_retry(). After attempting the operation, either call aws_retry_strategy_schedule_retry()\n with an aws_retry_error_type or call aws_retry_token_record_success() and then release the token via.\n aws_retry_token_release()."]
pub type aws_retry_strategy_on_retry_ready_fn = ::core::option::Option<
    unsafe extern "C" fn(
        token: *mut aws_retry_token,
        error_code: ::core::ffi::c_int,
        user_data: *mut ::core::ffi::c_void,
    ),
>;
#[doc = " Optional function to supply your own generate random implementation"]
pub type aws_generate_random_fn =
    ::core::option::Option<unsafe extern "C" fn(user_data: *mut ::core::ffi::c_void) -> u64>;
pub type aws_retry_error_type = ::core::ffi::c_uint;
#[doc = " Jitter mode for exponential backoff.\n\n For a great writeup on these options see:\n https://aws.amazon.com/blogs/architecture/exponential-backoff-and-jitter/"]
pub type aws_exponential_backoff_jitter_mode = ::core::ffi::c_uint;
pub type aws_generic_function = ::core::option::Option<unsafe extern "C" fn()>;
pub type aws_socket_domain = ::core::ffi::c_uint;
pub type aws_socket_type = ::core::ffi::c_uint;
#[doc = " Called in client mode when an outgoing connection has succeeded or an error has occurred.\n If the connection was successful error_code will be AWS_ERROR_SUCCESS and the socket has already been assigned\n to the event loop specified in aws_socket_connect().\n\n If an error occurred error_code will be non-zero."]
pub type aws_socket_on_connection_result_fn = ::core::option::Option<
    unsafe extern "C" fn(
        socket: *mut aws_socket,
        error_code: ::core::ffi::c_int,
        user_data: *mut ::core::ffi::c_void,
    ),
>;
#[doc = " Called by a listening socket when either an incoming connection has been received or an error occurred.\n\n In the normal use-case, this function will be called multiple times over the lifetime of a single listening socket.\n new_socket is already connected and initialized, and is using the same options and allocator as the listening socket.\n A user may want to call aws_socket_set_options() on the new socket if different options are desired.\n\n new_socket is not yet assigned to an event-loop. The user should call aws_socket_assign_to_event_loop() before\n performing IO operations.\n\n When error_code is AWS_ERROR_SUCCESS, new_socket is the recently accepted connection.\n If error_code is non-zero, an error occurred and you should aws_socket_close() the socket.\n\n Do not call aws_socket_clean_up() from this callback."]
pub type aws_socket_on_accept_result_fn = ::core::option::Option<
    unsafe extern "C" fn(
        socket: *mut aws_socket,
        error_code: ::core::ffi::c_int,
        new_socket: *mut aws_socket,
        user_data: *mut ::core::ffi::c_void,
    ),
>;
#[doc = " Callback for when the data passed to a call to aws_socket_write() has either completed or failed.\n On success, error_code will be AWS_ERROR_SUCCESS."]
pub type aws_socket_on_write_completed_fn = ::core::option::Option<
    unsafe extern "C" fn(
        socket: *mut aws_socket,
        error_code: ::core::ffi::c_int,
        bytes_written: usize,
        user_data: *mut ::core::ffi::c_void,
    ),
>;
#[doc = " Callback for when socket is either readable (edge-triggered) or when an error has occurred. If the socket is\n readable, error_code will be AWS_ERROR_SUCCESS."]
pub type aws_socket_on_readable_fn = ::core::option::Option<
    unsafe extern "C" fn(
        socket: *mut aws_socket,
        error_code: ::core::ffi::c_int,
        user_data: *mut ::core::ffi::c_void,
    ),
>;
pub type aws_tls_versions = ::core::ffi::c_uint;
pub type aws_tls_cipher_pref = ::core::ffi::c_uint;
#[doc = " The hash algorithm of a TLS private key operation. Any custom private key operation handlers are expected to perform\n operations on the input TLS data using the correct hash algorithm or fail the operation."]
pub type aws_tls_hash_algorithm = ::core::ffi::c_uint;
#[doc = " The signature of a TLS private key operation. Any custom private key operation handlers are expected to perform\n operations on the input TLS data using the correct signature algorithm or fail the operation."]
pub type aws_tls_signature_algorithm = ::core::ffi::c_uint;
#[doc = " The TLS private key operation that needs to be performed by a custom private key operation handler when making\n a connection using mutual TLS."]
pub type aws_tls_key_operation_type = ::core::ffi::c_uint;
#[doc = " Invoked upon completion of the TLS handshake. If successful error_code will be AWS_OP_SUCCESS, otherwise\n the negotiation failed and immediately after this function is invoked, the channel will be shutting down."]
pub type aws_tls_on_negotiation_result_fn = ::core::option::Option<
    unsafe extern "C" fn(
        handler: *mut aws_channel_handler,
        slot: *mut aws_channel_slot,
        error_code: ::core::ffi::c_int,
        user_data: *mut ::core::ffi::c_void,
    ),
>;
#[doc = " Only used if the TLS handler is the last handler in the channel. This allows you to read any data that\n was read and decrypted by the handler. If you have application protocol channel handlers, this function\n is not necessary and certainly not recommended."]
pub type aws_tls_on_data_read_fn = ::core::option::Option<
    unsafe extern "C" fn(
        handler: *mut aws_channel_handler,
        slot: *mut aws_channel_slot,
        buffer: *mut aws_byte_buf,
        user_data: *mut ::core::ffi::c_void,
    ),
>;
#[doc = " Invoked when an error occurs in the TLS state machine AFTER the handshake has completed. This function should only\n be used in conjunction with the rules of aws_tls_on_data_read_fn."]
pub type aws_tls_on_error_fn = ::core::option::Option<
    unsafe extern "C" fn(
        handler: *mut aws_channel_handler,
        slot: *mut aws_channel_slot,
        err: ::core::ffi::c_int,
        message: *const ::core::ffi::c_char,
        user_data: *mut ::core::ffi::c_void,
    ),
>;
pub type aws_tls_on_protocol_negotiated = ::core::option::Option<
    unsafe extern "C" fn(
        new_slot: *mut aws_channel_slot,
        protocol: *mut aws_byte_buf,
        user_data: *mut ::core::ffi::c_void,
    ) -> *mut aws_channel_handler,
>;
#[doc = " An enum for the current state of tls negotiation within a tls channel handler"]
pub type aws_tls_negotiation_status = ::core::ffi::c_uint;
pub type aws_crt_io_statistics_category = ::core::ffi::c_uint;
pub type aws_stream_seek_basis = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aws_io_handle {
    pub data: aws_io_handle__bindgen_ty_1,
    pub additional_data: *mut ::core::ffi::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_channel {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct aws_io_message {
    #[doc = " Allocator used for the message and message data. If this is null, the message belongs to a pool or some other\n message manager."]
    pub allocator: *mut aws_allocator,
    #[doc = " Buffer containing the data for message"]
    pub message_data: aws_byte_buf,
    #[doc = " type of the message. This is used for framework control messages. Currently the only type is\n AWS_IO_MESSAGE_APPLICATION_DATA"]
    pub message_type: aws_io_message_type,
    #[doc = " Conveys information about the contents of message_data (e.g. cast the ptr to some type). If 0, it's just opaque\n data."]
    pub message_tag: ::core::ffi::c_int,
    #[doc = " In order to avoid excess allocations/copies, on a partial read or write, the copy mark is set to indicate how\n much of this message has already been processed or copied."]
    pub copy_mark: usize,
    #[doc = " The channel that the message is bound to."]
    pub owning_channel: *mut aws_channel,
    #[doc = " Invoked by the channel once the entire message has been written to the data sink."]
    pub on_completion: aws_channel_on_message_write_completed_fn,
    #[doc = " arbitrary user data for the on_completion callback"]
    pub user_data: *mut ::core::ffi::c_void,
    #[doc = " it's incredibly likely something is going to need to queue this,\n go ahead and make sure the list info is part of the original allocation."]
    pub queueing_handle: aws_linked_list_node,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_future_bool {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct aws_async_input_stream {
    pub vtable: *const aws_async_input_stream_vtable,
    pub alloc: *mut aws_allocator,
    pub ref_count: aws_ref_count,
    pub impl_: *mut ::core::ffi::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_async_input_stream_vtable {
    #[doc = " Destroy the stream, its refcount has reached 0."]
    pub destroy: ::core::option::Option<unsafe extern "C" fn(stream: *mut aws_async_input_stream)>,
    #[doc = " Read once into the buffer.\n Complete the read when at least 1 byte is read, the buffer is full, or EOF is reached.\n Do not resize the buffer (do not use \"aws_byte_buf_xyz_dynamic()\" functions)\n Do not assume that buffer len starts at 0.\n You may assume that read() won't be called again until the current one completes.\n You may assume that the buffer has some space available.\n Return a future, which will contain an error code if something went wrong,\n or a result bool indicating whether EOF has been reached."]
    pub read: ::core::option::Option<
        unsafe extern "C" fn(
            stream: *mut aws_async_input_stream,
            dest: *mut aws_byte_buf,
        ) -> *mut aws_future_bool,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_channel_slot {
    pub alloc: *mut aws_allocator,
    pub channel: *mut aws_channel,
    pub adj_left: *mut aws_channel_slot,
    pub adj_right: *mut aws_channel_slot,
    pub handler: *mut aws_channel_handler,
    pub window_size: usize,
    pub upstream_message_overhead: usize,
    pub current_window_update_batch_size: usize,
}
#[repr(C)]
pub struct aws_channel_task {
    pub wrapper_task: aws_task,
    pub task_fn: aws_channel_task_fn,
    pub arg: *mut ::core::ffi::c_void,
    pub type_tag: *const ::core::ffi::c_char,
    pub node: aws_linked_list_node,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_channel_handler_vtable {
    #[doc = " Called by the channel when a message is available for processing in the read direction. It is your\n responsibility to call aws_mem_release(message->allocator, message); on message when you are finished with it.\n\n Also keep in mind that your slot's internal window has been decremented. You'll want to call\n aws_channel_slot_increment_read_window() at some point in the future if you want to keep receiving data."]
    pub process_read_message: ::core::option::Option<
        unsafe extern "C" fn(
            handler: *mut aws_channel_handler,
            slot: *mut aws_channel_slot,
            message: *mut aws_io_message,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = " Called by the channel when a message is available for processing in the write direction. It is your\n responsibility to call aws_mem_release(message->allocator, message); on message when you are finished with it."]
    pub process_write_message: ::core::option::Option<
        unsafe extern "C" fn(
            handler: *mut aws_channel_handler,
            slot: *mut aws_channel_slot,
            message: *mut aws_io_message,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = " Called by the channel when a downstream handler has issued a window increment. You'll want to update your\n internal state and likely propagate a window increment message of your own by calling\n 'aws_channel_slot_increment_read_window()'"]
    pub increment_read_window: ::core::option::Option<
        unsafe extern "C" fn(
            handler: *mut aws_channel_handler,
            slot: *mut aws_channel_slot,
            size: usize,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = " The channel calls shutdown on all handlers twice, once to shut down reading, and once to shut down writing.\n Shutdown always begins with the left-most handler, and proceeds to the right with dir set to\n AWS_CHANNEL_DIR_READ. Then shutdown is called on handlers from right to left with dir set to\n AWS_CHANNEL_DIR_WRITE.\n\n The shutdown process does not need to complete immediately and may rely on scheduled tasks.\n The handler must call aws_channel_slot_on_handler_shutdown_complete() when it is finished,\n which propagates shutdown to the next handler.  If 'free_scarce_resources_immediately' is true,\n then resources vulnerable to denial-of-service attacks (such as sockets and file handles)\n must be closed immediately before the shutdown() call returns."]
    pub shutdown: ::core::option::Option<
        unsafe extern "C" fn(
            handler: *mut aws_channel_handler,
            slot: *mut aws_channel_slot,
            dir: aws_channel_direction,
            error_code: ::core::ffi::c_int,
            free_scarce_resources_immediately: bool,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = " Called by the channel when the handler is added to a slot, to get the initial window size."]
    pub initial_window_size:
        ::core::option::Option<unsafe extern "C" fn(handler: *mut aws_channel_handler) -> usize>,
    #[doc = " Called by the channel anytime a handler is added or removed, provides a hint for downstream\n handlers to avoid message fragmentation due to message overhead."]
    pub message_overhead:
        ::core::option::Option<unsafe extern "C" fn(handler: *mut aws_channel_handler) -> usize>,
    #[doc = " Clean up any resources and deallocate yourself. The shutdown process will already be completed before this\n function is called."]
    pub destroy: ::core::option::Option<unsafe extern "C" fn(handler: *mut aws_channel_handler)>,
    #[doc = " Directs the channel handler to reset all of the internal statistics it tracks about itself."]
    pub reset_statistics:
        ::core::option::Option<unsafe extern "C" fn(handler: *mut aws_channel_handler)>,
    #[doc = " Adds a pointer to the handler's internal statistics (if they exist) to a list of statistics structures\n associated with the channel's handler chain."]
    pub gather_statistics: ::core::option::Option<
        unsafe extern "C" fn(handler: *mut aws_channel_handler, stats_list: *mut aws_array_list),
    >,
    pub trigger_read:
        ::core::option::Option<unsafe extern "C" fn(handler: *mut aws_channel_handler)>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_channel_handler {
    pub vtable: *mut aws_channel_handler_vtable,
    pub alloc: *mut aws_allocator,
    pub slot: *mut aws_channel_slot,
    pub impl_: *mut ::core::ffi::c_void,
}
#[doc = " Args for creating a new channel.\n  event_loop to use for IO and tasks. on_setup_completed will be invoked when\n  the setup process is finished It will be executed in the event loop's thread.\n  on_shutdown_completed will be executed upon channel shutdown.\n\n  enable_read_back_pressure toggles whether or not back pressure will be applied in the channel.\n  Leave this option off unless you're using something like reactive-streams, since it is a slight throughput\n  penalty.\n\n  Unless otherwise\n  specified all functions for channels and channel slots must be executed within that channel's event-loop's thread."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_channel_options {
    pub event_loop: *mut aws_event_loop,
    pub on_setup_completed: aws_channel_on_setup_completed_fn,
    pub on_shutdown_completed: aws_channel_on_shutdown_completed_fn,
    pub setup_user_data: *mut ::core::ffi::c_void,
    pub shutdown_user_data: *mut ::core::ffi::c_void,
    pub enable_read_back_pressure: bool,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_host_address {
    pub allocator: *mut aws_allocator,
    pub host: *const aws_string,
    pub address: *const aws_string,
    pub record_type: aws_address_record_type,
    pub expiry: u64,
    pub use_count: usize,
    pub connection_failure_count: usize,
    pub weight: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_host_resolution_config {
    pub impl_: aws_resolve_host_implementation_fn,
    pub max_ttl: usize,
    pub impl_data: *mut ::core::ffi::c_void,
    pub resolve_frequency_ns: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_host_listener {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_host_listener_options {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_host_resolver_purge_host_options {
    pub host: *const aws_string,
    pub on_host_purge_complete_callback: aws_simple_completion_callback,
    pub user_data: *mut ::core::ffi::c_void,
}
#[doc = " should you absolutely disdain the default implementation, feel free to implement your own."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_host_resolver_vtable {
    #[doc = " clean up everything you allocated, but not resolver itself."]
    pub destroy: ::core::option::Option<unsafe extern "C" fn(resolver: *mut aws_host_resolver)>,
    #[doc = " resolve the host by host_name, the user owns host_name, so it needs to be copied if you persist it,\n invoke res with the result. This function should never block."]
    pub resolve_host: ::core::option::Option<
        unsafe extern "C" fn(
            resolver: *mut aws_host_resolver,
            host_name: *const aws_string,
            res: aws_on_host_resolved_result_fn,
            config: *const aws_host_resolution_config,
            user_data: *mut ::core::ffi::c_void,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = " gives your implementation a hint that an address has some failed connections occuring. Do whatever you want (or\n nothing) about it."]
    pub record_connection_failure: ::core::option::Option<
        unsafe extern "C" fn(
            resolver: *mut aws_host_resolver,
            address: *const aws_host_address,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = " @Deprecated Use purge_cache_with_callback instead\n wipe out anything you have cached."]
    pub purge_cache: ::core::option::Option<
        unsafe extern "C" fn(resolver: *mut aws_host_resolver) -> ::core::ffi::c_int,
    >,
    #[doc = " wipe out anything you have cached."]
    pub purge_cache_with_callback: ::core::option::Option<
        unsafe extern "C" fn(
            resolver: *mut aws_host_resolver,
            on_purge_cache_complete_callback: aws_simple_completion_callback,
            user_data: *mut ::core::ffi::c_void,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = " wipe out anything cached for a specific host"]
    pub purge_host_cache: ::core::option::Option<
        unsafe extern "C" fn(
            resolver: *mut aws_host_resolver,
            options: *const aws_host_resolver_purge_host_options,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = " get number of addresses for a given host."]
    pub get_host_address_count: ::core::option::Option<
        unsafe extern "C" fn(
            resolver: *mut aws_host_resolver,
            host_name: *const aws_string,
            flags: u32,
        ) -> usize,
    >,
}
#[repr(C)]
pub struct aws_host_resolver {
    pub allocator: *mut aws_allocator,
    pub impl_: *mut ::core::ffi::c_void,
    pub vtable: *mut aws_host_resolver_vtable,
    pub ref_count: aws_ref_count,
    pub shutdown_options: aws_shutdown_callback_options,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_host_resolver_default_options {
    pub max_entries: usize,
    pub el_group: *mut aws_event_loop_group,
    pub shutdown_options: *const aws_shutdown_callback_options,
    pub system_clock_override_fn: aws_io_clock_fn,
}
#[doc = " aws_client_bootstrap handles creation and setup of channels that communicate via socket with a specific endpoint."]
#[repr(C)]
pub struct aws_client_bootstrap {
    pub allocator: *mut aws_allocator,
    pub event_loop_group: *mut aws_event_loop_group,
    pub host_resolver: *mut aws_host_resolver,
    pub host_resolver_config: aws_host_resolution_config,
    pub on_protocol_negotiated: aws_channel_on_protocol_negotiated_fn,
    pub ref_count: aws_ref_count,
    pub on_shutdown_complete: aws_client_bootstrap_shutdown_complete_fn,
    pub user_data: *mut ::core::ffi::c_void,
}
#[doc = " aws_client_bootstrap creation options."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_client_bootstrap_options {
    pub event_loop_group: *mut aws_event_loop_group,
    pub host_resolver: *mut aws_host_resolver,
    pub host_resolution_config: *const aws_host_resolution_config,
    pub on_shutdown_complete: aws_client_bootstrap_shutdown_complete_fn,
    pub user_data: *mut ::core::ffi::c_void,
}
#[doc = " aws_server_bootstrap manages listening sockets, creating and setting up channels to handle each incoming connection."]
#[repr(C)]
pub struct aws_server_bootstrap {
    pub allocator: *mut aws_allocator,
    pub event_loop_group: *mut aws_event_loop_group,
    pub on_protocol_negotiated: aws_channel_on_protocol_negotiated_fn,
    pub ref_count: aws_ref_count,
}
#[doc = " Socket-based channel creation options.\n\n bootstrap - configs name resolution and which event loop group the connection will be seated into\n host_name - host to connect to; if a dns address, will be resolved prior to connecting\n port - port to connect to\n socket_options - socket properties, including type (tcp vs. udp vs. unix domain) and connect timeout.  TLS\n   connections are currently restricted to tcp (AWS_SOCKET_STREAM) only.\n tls_options - (optional) tls context to apply after connection establishment.  If NULL, the connection will\n   not be protected by TLS.\n creation_callback - (optional) callback invoked when the channel is first created.  This is always right after\n   the connection was successfully established.  *Does NOT* get called if the initial connect failed.\n setup_callback - callback invoked once the channel is ready for use and TLS has been negotiated or if an error\n   is encountered\n shutdown_callback - callback invoked once the channel has shutdown.\n enable_read_back_pressure - controls whether or not back pressure will be applied in the channel\n user_data - arbitrary data to pass back to the various callbacks\n requested_event_loop - if set, the connection will be placed on the requested event loop rather than one\n  chosen internally from the bootstrap's associated event loop group.  It is an error to pass in an event loop\n  that is not associated with the bootstrap's event loop group.\n\n Immediately after the `shutdown_callback` returns, the channel is cleaned up automatically. All callbacks are invoked\n in the thread of the event-loop that the new channel is assigned to.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_socket_channel_bootstrap_options {
    pub bootstrap: *mut aws_client_bootstrap,
    pub host_name: *const ::core::ffi::c_char,
    pub port: u32,
    pub socket_options: *const aws_socket_options,
    pub tls_options: *const aws_tls_connection_options,
    pub creation_callback: aws_client_bootstrap_on_channel_event_fn,
    pub setup_callback: aws_client_bootstrap_on_channel_event_fn,
    pub shutdown_callback: aws_client_bootstrap_on_channel_event_fn,
    pub enable_read_back_pressure: bool,
    pub user_data: *mut ::core::ffi::c_void,
    pub requested_event_loop: *mut aws_event_loop,
    pub host_resolution_override_config: *const aws_host_resolution_config,
}
#[doc = " Arguments to setup a server socket listener which will also negotiate and configure TLS.\n This creates a socket listener bound to `host` and 'port' using socket options `options`, and TLS options\n `tls_options`. `incoming_callback` will be invoked once an incoming channel is ready for use and TLS is\n finished negotiating, or if an error is encountered. `shutdown_callback` will be invoked once the channel has\n shutdown. `destroy_callback` will be invoked after the server socket listener is destroyed, and all associated\n connections and channels have finished shutting down. Immediately after the `shutdown_callback` returns, the channel\n is cleaned up automatically. All callbacks are invoked in the thread of the event-loop that listener is assigned to.\n\n Upon shutdown of your application, you'll want to call `aws_server_bootstrap_destroy_socket_listener` with the return\n value from this function.\n\n The socket type in `options` must be AWS_SOCKET_STREAM if tls_options is set.\n DTLS is not currently supported for tls."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_server_socket_channel_bootstrap_options {
    pub bootstrap: *mut aws_server_bootstrap,
    pub host_name: *const ::core::ffi::c_char,
    pub port: u32,
    pub socket_options: *const aws_socket_options,
    pub tls_options: *const aws_tls_connection_options,
    pub incoming_callback: aws_server_bootstrap_on_accept_channel_setup_fn,
    pub shutdown_callback: aws_server_bootstrap_on_accept_channel_shutdown_fn,
    pub destroy_callback: aws_server_bootstrap_on_server_listener_destroy_fn,
    pub enable_read_back_pressure: bool,
    pub user_data: *mut ::core::ffi::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_event_loop_vtable {
    pub destroy: ::core::option::Option<unsafe extern "C" fn(event_loop: *mut aws_event_loop)>,
    pub run: ::core::option::Option<
        unsafe extern "C" fn(event_loop: *mut aws_event_loop) -> ::core::ffi::c_int,
    >,
    pub stop: ::core::option::Option<
        unsafe extern "C" fn(event_loop: *mut aws_event_loop) -> ::core::ffi::c_int,
    >,
    pub wait_for_stop_completion: ::core::option::Option<
        unsafe extern "C" fn(event_loop: *mut aws_event_loop) -> ::core::ffi::c_int,
    >,
    pub schedule_task_now: ::core::option::Option<
        unsafe extern "C" fn(event_loop: *mut aws_event_loop, task: *mut aws_task),
    >,
    pub schedule_task_future: ::core::option::Option<
        unsafe extern "C" fn(
            event_loop: *mut aws_event_loop,
            task: *mut aws_task,
            run_at_nanos: u64,
        ),
    >,
    pub cancel_task: ::core::option::Option<
        unsafe extern "C" fn(event_loop: *mut aws_event_loop, task: *mut aws_task),
    >,
    pub subscribe_to_io_events: ::core::option::Option<
        unsafe extern "C" fn(
            event_loop: *mut aws_event_loop,
            handle: *mut aws_io_handle,
            events: ::core::ffi::c_int,
            on_event: aws_event_loop_on_event_fn,
            user_data: *mut ::core::ffi::c_void,
        ) -> ::core::ffi::c_int,
    >,
    pub unsubscribe_from_io_events: ::core::option::Option<
        unsafe extern "C" fn(
            event_loop: *mut aws_event_loop,
            handle: *mut aws_io_handle,
        ) -> ::core::ffi::c_int,
    >,
    pub free_io_event_resources:
        ::core::option::Option<unsafe extern "C" fn(user_data: *mut ::core::ffi::c_void)>,
    pub is_on_callers_thread:
        ::core::option::Option<unsafe extern "C" fn(event_loop: *mut aws_event_loop) -> bool>,
}
#[repr(C)]
pub struct aws_event_loop {
    pub vtable: *mut aws_event_loop_vtable,
    pub alloc: *mut aws_allocator,
    pub clock: aws_io_clock_fn,
    pub local_data: aws_hash_table,
    pub current_load_factor: aws_atomic_var,
    pub latest_tick_start: u64,
    pub current_tick_latency_sum: usize,
    pub next_flush_time: aws_atomic_var,
    pub impl_data: *mut ::core::ffi::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_event_loop_local_object {
    pub key: *const ::core::ffi::c_void,
    pub object: *mut ::core::ffi::c_void,
    pub on_object_removed: aws_event_loop_on_local_object_removed_fn,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_event_loop_options {
    pub clock: aws_io_clock_fn,
    pub thread_options: *mut aws_thread_options,
}
#[repr(C)]
pub struct aws_event_loop_group {
    pub allocator: *mut aws_allocator,
    pub event_loops: aws_array_list,
    pub ref_count: aws_ref_count,
    pub shutdown_options: aws_shutdown_callback_options,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_future_impl {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_future_size {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_future_void {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct aws_memory_pool {
    pub alloc: *mut aws_allocator,
    pub stack: aws_array_list,
    pub ideal_segment_count: u16,
    pub segment_size: usize,
    pub data_ptr: *mut ::core::ffi::c_void,
}
#[repr(C)]
pub struct aws_message_pool {
    pub alloc: *mut aws_allocator,
    pub application_data_pool: aws_memory_pool,
    pub small_block_pool: aws_memory_pool,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_message_pool_creation_args {
    pub application_data_msg_data_size: usize,
    pub application_data_msg_count: u8,
    pub small_block_msg_data_size: usize,
    pub small_block_msg_count: u8,
}
#[repr(C)]
pub struct aws_pem_object {
    pub type_: aws_pem_object_type,
    pub type_string: *mut aws_string,
    pub data: aws_byte_buf,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_pipe_read_end {
    pub impl_data: *mut ::core::ffi::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_pipe_write_end {
    pub impl_data: *mut ::core::ffi::c_void,
}
#[doc = " Handle to a loaded PKCS#11 library."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_pkcs11_lib {
    _unused: [u8; 0],
}
#[doc = " Options for aws_pkcs11_lib_new()"]
#[repr(C)]
pub struct aws_pkcs11_lib_options {
    #[doc = " Name of PKCS#11 library file to load (UTF-8).\n Zero out if your application is compiled with PKCS#11 symbols linked in."]
    pub filename: aws_byte_cursor,
    #[doc = " Behavior for calling C_Initialize() and C_Finalize() on the PKCS#11 library."]
    pub initialize_finalize_behavior: aws_pkcs11_lib_behavior,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_retry_strategy_vtable {
    pub destroy:
        ::core::option::Option<unsafe extern "C" fn(retry_strategy: *mut aws_retry_strategy)>,
    pub acquire_token: ::core::option::Option<
        unsafe extern "C" fn(
            retry_strategy: *mut aws_retry_strategy,
            partition_id: *const aws_byte_cursor,
            on_acquired: aws_retry_strategy_on_retry_token_acquired_fn,
            user_data: *mut ::core::ffi::c_void,
            timeout_ms: u64,
        ) -> ::core::ffi::c_int,
    >,
    pub schedule_retry: ::core::option::Option<
        unsafe extern "C" fn(
            token: *mut aws_retry_token,
            error_type: aws_retry_error_type,
            retry_ready: aws_retry_strategy_on_retry_ready_fn,
            user_data: *mut ::core::ffi::c_void,
        ) -> ::core::ffi::c_int,
    >,
    pub record_success: ::core::option::Option<
        unsafe extern "C" fn(token: *mut aws_retry_token) -> ::core::ffi::c_int,
    >,
    pub release_token: ::core::option::Option<unsafe extern "C" fn(token: *mut aws_retry_token)>,
}
#[repr(C)]
pub struct aws_retry_strategy {
    pub allocator: *mut aws_allocator,
    pub vtable: *mut aws_retry_strategy_vtable,
    pub ref_count: aws_atomic_var,
    pub impl_: *mut ::core::ffi::c_void,
}
#[repr(C)]
pub struct aws_retry_token {
    pub allocator: *mut aws_allocator,
    pub retry_strategy: *mut aws_retry_strategy,
    pub ref_count: aws_atomic_var,
    pub impl_: *mut ::core::ffi::c_void,
}
#[doc = " Options for exponential backoff retry strategy. el_group must be set, any other option, if set to 0 will signify\n \"use defaults\""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_exponential_backoff_retry_options {
    #[doc = " Event loop group to use for scheduling tasks."]
    pub el_group: *mut aws_event_loop_group,
    #[doc = " Max retries to allow. The default value is 10"]
    pub max_retries: usize,
    #[doc = " Scaling factor to add for the backoff. Default is 500ms"]
    pub backoff_scale_factor_ms: u32,
    #[doc = " Max retry backoff in seconds. Default is 20 seconds"]
    pub max_backoff_secs: u32,
    #[doc = " Jitter mode to use, see comments for aws_exponential_backoff_jitter_mode.\n Default is AWS_EXPONENTIAL_BACKOFF_JITTER_DEFAULT"]
    pub jitter_mode: aws_exponential_backoff_jitter_mode,
    #[doc = " Deprecated. Use generate_random_impl instead\n By default this will be set to use aws_device_random. If you want something else, set it here."]
    pub generate_random: ::core::option::Option<unsafe extern "C" fn() -> u64>,
    pub generate_random_impl: aws_generate_random_fn,
    #[doc = " Optional user data for the generate random generate_random_impl."]
    pub generate_random_user_data: *mut ::core::ffi::c_void,
    #[doc = " Optional shutdown callback that gets invoked, with appropriate user data,\n when the resources used by the retry_strategy are no longer in use."]
    pub shutdown_options: *const aws_shutdown_callback_options,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_standard_retry_options {
    pub backoff_retry_options: aws_exponential_backoff_retry_options,
    #[doc = " capacity for partitions. Defaults to 500"]
    pub initial_bucket_capacity: usize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_shared_library {
    pub library_handle: *mut ::core::ffi::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_socket_options {
    pub type_: aws_socket_type,
    pub domain: aws_socket_domain,
    pub connect_timeout_ms: u32,
    pub keep_alive_interval_sec: u16,
    pub keep_alive_timeout_sec: u16,
    pub keep_alive_max_failed_probes: u16,
    pub keepalive: bool,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_socket_endpoint {
    pub address: [::core::ffi::c_char; 256usize],
    pub port: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aws_socket {
    pub allocator: *mut aws_allocator,
    pub local_endpoint: aws_socket_endpoint,
    pub remote_endpoint: aws_socket_endpoint,
    pub options: aws_socket_options,
    pub io_handle: aws_io_handle,
    pub event_loop: *mut aws_event_loop,
    pub handler: *mut aws_channel_handler,
    pub state: ::core::ffi::c_int,
    pub readable_fn: aws_socket_on_readable_fn,
    pub readable_user_data: *mut ::core::ffi::c_void,
    pub connection_result_fn: aws_socket_on_connection_result_fn,
    pub accept_result_fn: aws_socket_on_accept_result_fn,
    pub connect_accept_user_data: *mut ::core::ffi::c_void,
    pub impl_: *mut ::core::ffi::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_pkcs11_session {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct aws_tls_ctx {
    pub alloc: *mut aws_allocator,
    pub impl_: *mut ::core::ffi::c_void,
    pub ref_count: aws_ref_count,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_tls_connection_options {
    #[doc = " semi-colon delimited list of protocols. Example:\n  h2;http/1.1"]
    pub alpn_list: *mut aws_string,
    #[doc = " Serves two purposes. If SNI is supported (hint... it is),\n this sets the SNI extension.\n\n For X.509 validation this also sets the name that will be used\n for verifying the subj alt name and common name of the peer's certificate."]
    pub server_name: *mut aws_string,
    pub on_negotiation_result: aws_tls_on_negotiation_result_fn,
    pub on_data_read: aws_tls_on_data_read_fn,
    pub on_error: aws_tls_on_error_fn,
    pub user_data: *mut ::core::ffi::c_void,
    pub ctx: *mut aws_tls_ctx,
    pub advertise_alpn_message: bool,
    pub timeout_ms: u32,
}
#[doc = " A struct containing all of the data needed for a private key operation when\n making a mutual TLS connection. This struct contains the data that needs\n to be operated on, like performing a sign operation or a decrypt operation."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_tls_key_operation {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct aws_tls_ctx_options {
    pub allocator: *mut aws_allocator,
    #[doc = "  minimum tls version to use. If you just want us to use the\n  system defaults, you can set: AWS_IO_TLS_VER_SYS_DEFAULTS. This\n  has the added benefit of automatically picking up new TLS versions\n  as your OS or distribution adds support."]
    pub minimum_tls_version: aws_tls_versions,
    #[doc = " The Cipher Preference List to use"]
    pub cipher_pref: aws_tls_cipher_pref,
    #[doc = " A PEM armored PKCS#7 collection of CAs you want to trust as a string.\n Only use this if it's a CA not currently installed on your system."]
    pub ca_file: aws_byte_buf,
    #[doc = " Only used on Unix systems using an openssl style trust API.\n this is typically something like /etc/pki/tls/certs/\""]
    pub ca_path: *mut aws_string,
    #[doc = " Sets ctx wide alpn string. This is most useful for servers.\n This is a semi-colon delimited list. example:\n h2;http/1.1"]
    pub alpn_list: *mut aws_string,
    #[doc = " A PEM armored PKCS#7 certificate as a string.\n It is supported on every operating system."]
    pub certificate: aws_byte_buf,
    #[doc = " The path to a system\n installed certficate/private key pair. Example:\n CurrentUser\\\\MY\\\\<thumprint>"]
    pub system_certificate_path: *const ::core::ffi::c_char,
    #[doc = " A PEM armored PKCS#7 private key as a string.\n\n On windows, this field should be NULL only if you are\n using a system installed certficate."]
    pub private_key: aws_byte_buf,
    #[doc = " max tls fragment size. Default is the value of g_aws_channel_max_fragment_size."]
    pub max_fragment_size: usize,
    #[doc = " default is true for clients and false for servers.\n You should not change this default for clients unless\n you're testing and don't want to fool around with CA trust stores.\n Before you release to production, you'll want to turn this back on\n and add your custom CA to the aws_tls_ctx_options.\n\n If you set this in server mode, it enforces client authentication."]
    pub verify_peer: bool,
    #[doc = " For use when adding BYO_CRYPTO implementations. You can set extra data in here for use with your TLS\n implementation."]
    pub ctx_options_extension: *mut ::core::ffi::c_void,
    #[doc = " Set if using custom private key operations.\n See aws_custom_key_op_handler for more details\n\n Note: Custom key operations (and PKCS#11 integration) hasn't been tested with TLS 1.3, so don't use\n cipher preferences that allow TLS 1.3. If this is set, we will always use non TLS 1.3 preferences."]
    pub custom_key_op_handler: *mut aws_custom_key_op_handler,
}
#[repr(C)]
pub struct aws_tls_negotiated_protocol_message {
    pub protocol: aws_byte_buf,
}
#[doc = " vtable for aws_custom_key_op_handler."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_custom_key_op_handler_vtable {
    #[doc = " Called when the a TLS handshake has an operation it needs the custom key operation handler to perform.\n NOTE: You must call aws_tls_key_operation_complete() or aws_tls_key_operation_complete_with_error()\n otherwise the TLS handshake will stall the TLS connection indefinitely and leak memory."]
    pub on_key_operation: ::core::option::Option<
        unsafe extern "C" fn(
            key_op_handler: *mut aws_custom_key_op_handler,
            operation: *mut aws_tls_key_operation,
        ),
    >,
}
#[doc = " The custom key operation that is used when performing a mutual TLS handshake. This can\n be extended to provide custom private key operations, like PKCS11 or similar."]
#[repr(C)]
pub struct aws_custom_key_op_handler {
    #[doc = " A void* intended to be populated with a reference to whatever class is extending this class. For example,\n if you have extended aws_custom_key_op_handler with a custom struct, you would put a pointer to this struct\n to *impl so you can retrieve it back in the vtable functions."]
    pub impl_: *mut ::core::ffi::c_void,
    #[doc = " A vtable containing all of the functions the aws_custom_key_op_handler implements. Is intended to be extended.\n NOTE: Use \"aws_custom_key_op_handler_<func>\" to access vtable functions."]
    pub vtable: *const aws_custom_key_op_handler_vtable,
    #[doc = " A reference count for handling memory usage.\n Use aws_custom_key_op_handler_acquire and aws_custom_key_op_handler_release to increase/decrease count."]
    pub ref_count: aws_ref_count,
}
#[doc = " This struct exists as a graceful way to pass many arguments when\n calling init-with-pkcs11 functions on aws_tls_ctx_options (this also makes\n it easy to introduce optional arguments in the future).\n Instances of this struct should only exist briefly on the stack.\n\n Instructions for binding this to high-level languages:\n - Python: The members of this struct should be the keyword args to the init-with-pkcs11 functions.\n - JavaScript: This should be an options map passed to init-with-pkcs11 functions.\n - Java: This should be an options class passed to init-with-pkcs11 functions.\n - C++: Same as Java\n\n Notes on integer types:\n PKCS#11 uses `unsigned long` for IDs, handles, etc but we expose them as `uint64_t` in public APIs.\n We do this because sizeof(long) is inconsistent across platform/arch/language\n (ex: always 64bit in Java, always 32bit in C on Windows, matches CPU in C on Linux and Apple).\n By using uint64_t in our public API, we can keep the careful bounds-checking all in one\n place, instead of expecting each high-level language binding to get it just right."]
#[repr(C)]
pub struct aws_tls_ctx_pkcs11_options {
    #[doc = " The PKCS#11 library to use.\n This field is required."]
    pub pkcs11_lib: *mut aws_pkcs11_lib,
    #[doc = " User PIN, for logging into the PKCS#11 token (UTF-8).\n Zero out to log into a token with a \"protected authentication path\"."]
    pub user_pin: aws_byte_cursor,
    #[doc = " ID of slot containing PKCS#11 token.\n If set to NULL, the token will be chosen based on other criteria\n (such as token label)."]
    pub slot_id: *const u64,
    #[doc = " Label of PKCS#11 token to use.\n If zeroed out, the token will be chosen based on other criteria\n (such as slot ID)."]
    pub token_label: aws_byte_cursor,
    #[doc = " Label of private key object on PKCS#11 token (UTF-8).\n If zeroed out, the private key will be chosen based on other criteria\n (such as being the only available private key on the token)."]
    pub private_key_object_label: aws_byte_cursor,
    #[doc = " Certificate's file path on disk (UTF-8).\n The certificate must be PEM formatted and UTF-8 encoded.\n Zero out if passing in certificate by some other means (such as file contents)."]
    pub cert_file_path: aws_byte_cursor,
    #[doc = " Certificate's file contents (UTF-8).\n The certificate must be PEM formatted and UTF-8 encoded.\n Zero out if passing in certificate by some other means (such as file path)."]
    pub cert_file_contents: aws_byte_cursor,
}
#[doc = " Socket channel handler statistics record"]
#[repr(C)]
pub struct aws_crt_statistics_socket {
    pub category: aws_crt_statistics_category_t,
    pub bytes_read: u64,
    pub bytes_written: u64,
}
#[doc = " Tls channel handler statistics record"]
#[repr(C)]
pub struct aws_crt_statistics_tls {
    pub category: aws_crt_statistics_category_t,
    pub handshake_start_ns: u64,
    pub handshake_end_ns: u64,
    pub handshake_status: aws_tls_negotiation_status,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_stream_status {
    pub is_end_of_stream: bool,
    pub is_valid: bool,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_input_stream_vtable {
    pub seek: ::core::option::Option<
        unsafe extern "C" fn(
            stream: *mut aws_input_stream,
            offset: i64,
            basis: aws_stream_seek_basis,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = " Stream as much data as will fit into the destination buffer and update its length.\n The destination buffer's capacity MUST NOT be changed.\n\n Return AWS_OP_SUCCESS if the read is successful.\n If AWS_OP_ERR is returned, the stream is assumed to be invalid and any data written to the buffer is ignored.\n\n If no more data is currently available, or the end of the stream has been reached, simply return AWS_OP_SUCCESS\n without touching the destination buffer."]
    pub read: ::core::option::Option<
        unsafe extern "C" fn(
            stream: *mut aws_input_stream,
            dest: *mut aws_byte_buf,
        ) -> ::core::ffi::c_int,
    >,
    pub get_status: ::core::option::Option<
        unsafe extern "C" fn(
            stream: *mut aws_input_stream,
            status: *mut aws_stream_status,
        ) -> ::core::ffi::c_int,
    >,
    pub get_length: ::core::option::Option<
        unsafe extern "C" fn(
            stream: *mut aws_input_stream,
            out_length: *mut i64,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = " Optional.\n If not set, the default aws_ref_count_acquire/release will be used.\n Set for high level language binding that has its own refcounting implementation and needs to be kept alive from\n C.\n If set, ref_count member will not be used."]
    pub acquire: ::core::option::Option<unsafe extern "C" fn(stream: *mut aws_input_stream)>,
    pub release: ::core::option::Option<unsafe extern "C" fn(stream: *mut aws_input_stream)>,
}
#[doc = " Base class for input streams.\n Note: when you implement one input stream, the ref_count needs to be initialized to clean up the resource when\n reaches to zero."]
#[repr(C)]
pub struct aws_input_stream {
    pub impl_: *mut ::core::ffi::c_void,
    pub vtable: *const aws_input_stream_vtable,
    pub ref_count: aws_ref_count,
}
pub const AWS_C_IO_PACKAGE_ID: u32 = 1;
pub const AWS_TLS_NEGOTIATED_PROTOCOL_MESSAGE: u32 = 1;
pub const AWS_IO_MESSAGE_APPLICATION_DATA: aws_io_message_type = 0;
pub const AWS_IO_CHANNEL_ERROR_ERROR_CANT_ACCEPT_INPUT: aws_io_errors = 1024;
pub const AWS_IO_CHANNEL_UNKNOWN_MESSAGE_TYPE: aws_io_errors = 1025;
pub const AWS_IO_CHANNEL_READ_WOULD_EXCEED_WINDOW: aws_io_errors = 1026;
pub const AWS_IO_EVENT_LOOP_ALREADY_ASSIGNED: aws_io_errors = 1027;
pub const AWS_IO_EVENT_LOOP_SHUTDOWN: aws_io_errors = 1028;
pub const AWS_IO_TLS_ERROR_NEGOTIATION_FAILURE: aws_io_errors = 1029;
pub const AWS_IO_TLS_ERROR_NOT_NEGOTIATED: aws_io_errors = 1030;
pub const AWS_IO_TLS_ERROR_WRITE_FAILURE: aws_io_errors = 1031;
pub const AWS_IO_TLS_ERROR_ALERT_RECEIVED: aws_io_errors = 1032;
pub const AWS_IO_TLS_CTX_ERROR: aws_io_errors = 1033;
pub const AWS_IO_TLS_VERSION_UNSUPPORTED: aws_io_errors = 1034;
pub const AWS_IO_TLS_CIPHER_PREF_UNSUPPORTED: aws_io_errors = 1035;
pub const AWS_IO_MISSING_ALPN_MESSAGE: aws_io_errors = 1036;
pub const AWS_IO_UNHANDLED_ALPN_PROTOCOL_MESSAGE: aws_io_errors = 1037;
pub const AWS_IO_FILE_VALIDATION_FAILURE: aws_io_errors = 1038;
pub const AWS_ERROR_IO_EVENT_LOOP_THREAD_ONLY: aws_io_errors = 1039;
pub const AWS_ERROR_IO_ALREADY_SUBSCRIBED: aws_io_errors = 1040;
pub const AWS_ERROR_IO_NOT_SUBSCRIBED: aws_io_errors = 1041;
pub const AWS_ERROR_IO_OPERATION_CANCELLED: aws_io_errors = 1042;
pub const AWS_IO_READ_WOULD_BLOCK: aws_io_errors = 1043;
pub const AWS_IO_BROKEN_PIPE: aws_io_errors = 1044;
pub const AWS_IO_SOCKET_UNSUPPORTED_ADDRESS_FAMILY: aws_io_errors = 1045;
pub const AWS_IO_SOCKET_INVALID_OPERATION_FOR_TYPE: aws_io_errors = 1046;
pub const AWS_IO_SOCKET_CONNECTION_REFUSED: aws_io_errors = 1047;
pub const AWS_IO_SOCKET_TIMEOUT: aws_io_errors = 1048;
pub const AWS_IO_SOCKET_NO_ROUTE_TO_HOST: aws_io_errors = 1049;
pub const AWS_IO_SOCKET_NETWORK_DOWN: aws_io_errors = 1050;
pub const AWS_IO_SOCKET_CLOSED: aws_io_errors = 1051;
pub const AWS_IO_SOCKET_NOT_CONNECTED: aws_io_errors = 1052;
pub const AWS_IO_SOCKET_INVALID_OPTIONS: aws_io_errors = 1053;
pub const AWS_IO_SOCKET_ADDRESS_IN_USE: aws_io_errors = 1054;
pub const AWS_IO_SOCKET_INVALID_ADDRESS: aws_io_errors = 1055;
pub const AWS_IO_SOCKET_ILLEGAL_OPERATION_FOR_STATE: aws_io_errors = 1056;
pub const AWS_IO_SOCKET_CONNECT_ABORTED: aws_io_errors = 1057;
pub const AWS_IO_DNS_QUERY_FAILED: aws_io_errors = 1058;
pub const AWS_IO_DNS_INVALID_NAME: aws_io_errors = 1059;
pub const AWS_IO_DNS_NO_ADDRESS_FOR_HOST: aws_io_errors = 1060;
pub const AWS_IO_DNS_HOST_REMOVED_FROM_CACHE: aws_io_errors = 1061;
pub const AWS_IO_STREAM_INVALID_SEEK_POSITION: aws_io_errors = 1062;
pub const AWS_IO_STREAM_READ_FAILED: aws_io_errors = 1063;
pub const DEPRECATED_AWS_IO_INVALID_FILE_HANDLE: aws_io_errors = 1064;
pub const AWS_IO_SHARED_LIBRARY_LOAD_FAILURE: aws_io_errors = 1065;
pub const AWS_IO_SHARED_LIBRARY_FIND_SYMBOL_FAILURE: aws_io_errors = 1066;
pub const AWS_IO_TLS_NEGOTIATION_TIMEOUT: aws_io_errors = 1067;
pub const AWS_IO_TLS_ALERT_NOT_GRACEFUL: aws_io_errors = 1068;
pub const AWS_IO_MAX_RETRIES_EXCEEDED: aws_io_errors = 1069;
pub const AWS_IO_RETRY_PERMISSION_DENIED: aws_io_errors = 1070;
pub const AWS_IO_TLS_DIGEST_ALGORITHM_UNSUPPORTED: aws_io_errors = 1071;
pub const AWS_IO_TLS_SIGNATURE_ALGORITHM_UNSUPPORTED: aws_io_errors = 1072;
pub const AWS_ERROR_PKCS11_VERSION_UNSUPPORTED: aws_io_errors = 1073;
pub const AWS_ERROR_PKCS11_TOKEN_NOT_FOUND: aws_io_errors = 1074;
pub const AWS_ERROR_PKCS11_KEY_NOT_FOUND: aws_io_errors = 1075;
pub const AWS_ERROR_PKCS11_KEY_TYPE_UNSUPPORTED: aws_io_errors = 1076;
pub const AWS_ERROR_PKCS11_UNKNOWN_CRYPTOKI_RETURN_VALUE: aws_io_errors = 1077;
pub const AWS_ERROR_PKCS11_CKR_CANCEL: aws_io_errors = 1078;
pub const AWS_ERROR_PKCS11_CKR_HOST_MEMORY: aws_io_errors = 1079;
pub const AWS_ERROR_PKCS11_CKR_SLOT_ID_INVALID: aws_io_errors = 1080;
pub const AWS_ERROR_PKCS11_CKR_GENERAL_ERROR: aws_io_errors = 1081;
pub const AWS_ERROR_PKCS11_CKR_FUNCTION_FAILED: aws_io_errors = 1082;
pub const AWS_ERROR_PKCS11_CKR_ARGUMENTS_BAD: aws_io_errors = 1083;
pub const AWS_ERROR_PKCS11_CKR_NO_EVENT: aws_io_errors = 1084;
pub const AWS_ERROR_PKCS11_CKR_NEED_TO_CREATE_THREADS: aws_io_errors = 1085;
pub const AWS_ERROR_PKCS11_CKR_CANT_LOCK: aws_io_errors = 1086;
pub const AWS_ERROR_PKCS11_CKR_ATTRIBUTE_READ_ONLY: aws_io_errors = 1087;
pub const AWS_ERROR_PKCS11_CKR_ATTRIBUTE_SENSITIVE: aws_io_errors = 1088;
pub const AWS_ERROR_PKCS11_CKR_ATTRIBUTE_TYPE_INVALID: aws_io_errors = 1089;
pub const AWS_ERROR_PKCS11_CKR_ATTRIBUTE_VALUE_INVALID: aws_io_errors = 1090;
pub const AWS_ERROR_PKCS11_CKR_ACTION_PROHIBITED: aws_io_errors = 1091;
pub const AWS_ERROR_PKCS11_CKR_DATA_INVALID: aws_io_errors = 1092;
pub const AWS_ERROR_PKCS11_CKR_DATA_LEN_RANGE: aws_io_errors = 1093;
pub const AWS_ERROR_PKCS11_CKR_DEVICE_ERROR: aws_io_errors = 1094;
pub const AWS_ERROR_PKCS11_CKR_DEVICE_MEMORY: aws_io_errors = 1095;
pub const AWS_ERROR_PKCS11_CKR_DEVICE_REMOVED: aws_io_errors = 1096;
pub const AWS_ERROR_PKCS11_CKR_ENCRYPTED_DATA_INVALID: aws_io_errors = 1097;
pub const AWS_ERROR_PKCS11_CKR_ENCRYPTED_DATA_LEN_RANGE: aws_io_errors = 1098;
pub const AWS_ERROR_PKCS11_CKR_FUNCTION_CANCELED: aws_io_errors = 1099;
pub const AWS_ERROR_PKCS11_CKR_FUNCTION_NOT_PARALLEL: aws_io_errors = 1100;
pub const AWS_ERROR_PKCS11_CKR_FUNCTION_NOT_SUPPORTED: aws_io_errors = 1101;
pub const AWS_ERROR_PKCS11_CKR_KEY_HANDLE_INVALID: aws_io_errors = 1102;
pub const AWS_ERROR_PKCS11_CKR_KEY_SIZE_RANGE: aws_io_errors = 1103;
pub const AWS_ERROR_PKCS11_CKR_KEY_TYPE_INCONSISTENT: aws_io_errors = 1104;
pub const AWS_ERROR_PKCS11_CKR_KEY_NOT_NEEDED: aws_io_errors = 1105;
pub const AWS_ERROR_PKCS11_CKR_KEY_CHANGED: aws_io_errors = 1106;
pub const AWS_ERROR_PKCS11_CKR_KEY_NEEDED: aws_io_errors = 1107;
pub const AWS_ERROR_PKCS11_CKR_KEY_INDIGESTIBLE: aws_io_errors = 1108;
pub const AWS_ERROR_PKCS11_CKR_KEY_FUNCTION_NOT_PERMITTED: aws_io_errors = 1109;
pub const AWS_ERROR_PKCS11_CKR_KEY_NOT_WRAPPABLE: aws_io_errors = 1110;
pub const AWS_ERROR_PKCS11_CKR_KEY_UNEXTRACTABLE: aws_io_errors = 1111;
pub const AWS_ERROR_PKCS11_CKR_MECHANISM_INVALID: aws_io_errors = 1112;
pub const AWS_ERROR_PKCS11_CKR_MECHANISM_PARAM_INVALID: aws_io_errors = 1113;
pub const AWS_ERROR_PKCS11_CKR_OBJECT_HANDLE_INVALID: aws_io_errors = 1114;
pub const AWS_ERROR_PKCS11_CKR_OPERATION_ACTIVE: aws_io_errors = 1115;
pub const AWS_ERROR_PKCS11_CKR_OPERATION_NOT_INITIALIZED: aws_io_errors = 1116;
pub const AWS_ERROR_PKCS11_CKR_PIN_INCORRECT: aws_io_errors = 1117;
pub const AWS_ERROR_PKCS11_CKR_PIN_INVALID: aws_io_errors = 1118;
pub const AWS_ERROR_PKCS11_CKR_PIN_LEN_RANGE: aws_io_errors = 1119;
pub const AWS_ERROR_PKCS11_CKR_PIN_EXPIRED: aws_io_errors = 1120;
pub const AWS_ERROR_PKCS11_CKR_PIN_LOCKED: aws_io_errors = 1121;
pub const AWS_ERROR_PKCS11_CKR_SESSION_CLOSED: aws_io_errors = 1122;
pub const AWS_ERROR_PKCS11_CKR_SESSION_COUNT: aws_io_errors = 1123;
pub const AWS_ERROR_PKCS11_CKR_SESSION_HANDLE_INVALID: aws_io_errors = 1124;
pub const AWS_ERROR_PKCS11_CKR_SESSION_PARALLEL_NOT_SUPPORTED: aws_io_errors = 1125;
pub const AWS_ERROR_PKCS11_CKR_SESSION_READ_ONLY: aws_io_errors = 1126;
pub const AWS_ERROR_PKCS11_CKR_SESSION_EXISTS: aws_io_errors = 1127;
pub const AWS_ERROR_PKCS11_CKR_SESSION_READ_ONLY_EXISTS: aws_io_errors = 1128;
pub const AWS_ERROR_PKCS11_CKR_SESSION_READ_WRITE_SO_EXISTS: aws_io_errors = 1129;
pub const AWS_ERROR_PKCS11_CKR_SIGNATURE_INVALID: aws_io_errors = 1130;
pub const AWS_ERROR_PKCS11_CKR_SIGNATURE_LEN_RANGE: aws_io_errors = 1131;
pub const AWS_ERROR_PKCS11_CKR_TEMPLATE_INCOMPLETE: aws_io_errors = 1132;
pub const AWS_ERROR_PKCS11_CKR_TEMPLATE_INCONSISTENT: aws_io_errors = 1133;
pub const AWS_ERROR_PKCS11_CKR_TOKEN_NOT_PRESENT: aws_io_errors = 1134;
pub const AWS_ERROR_PKCS11_CKR_TOKEN_NOT_RECOGNIZED: aws_io_errors = 1135;
pub const AWS_ERROR_PKCS11_CKR_TOKEN_WRITE_PROTECTED: aws_io_errors = 1136;
pub const AWS_ERROR_PKCS11_CKR_UNWRAPPING_KEY_HANDLE_INVALID: aws_io_errors = 1137;
pub const AWS_ERROR_PKCS11_CKR_UNWRAPPING_KEY_SIZE_RANGE: aws_io_errors = 1138;
pub const AWS_ERROR_PKCS11_CKR_UNWRAPPING_KEY_TYPE_INCONSISTENT: aws_io_errors = 1139;
pub const AWS_ERROR_PKCS11_CKR_USER_ALREADY_LOGGED_IN: aws_io_errors = 1140;
pub const AWS_ERROR_PKCS11_CKR_USER_NOT_LOGGED_IN: aws_io_errors = 1141;
pub const AWS_ERROR_PKCS11_CKR_USER_PIN_NOT_INITIALIZED: aws_io_errors = 1142;
pub const AWS_ERROR_PKCS11_CKR_USER_TYPE_INVALID: aws_io_errors = 1143;
pub const AWS_ERROR_PKCS11_CKR_USER_ANOTHER_ALREADY_LOGGED_IN: aws_io_errors = 1144;
pub const AWS_ERROR_PKCS11_CKR_USER_TOO_MANY_TYPES: aws_io_errors = 1145;
pub const AWS_ERROR_PKCS11_CKR_WRAPPED_KEY_INVALID: aws_io_errors = 1146;
pub const AWS_ERROR_PKCS11_CKR_WRAPPED_KEY_LEN_RANGE: aws_io_errors = 1147;
pub const AWS_ERROR_PKCS11_CKR_WRAPPING_KEY_HANDLE_INVALID: aws_io_errors = 1148;
pub const AWS_ERROR_PKCS11_CKR_WRAPPING_KEY_SIZE_RANGE: aws_io_errors = 1149;
pub const AWS_ERROR_PKCS11_CKR_WRAPPING_KEY_TYPE_INCONSISTENT: aws_io_errors = 1150;
pub const AWS_ERROR_PKCS11_CKR_RANDOM_SEED_NOT_SUPPORTED: aws_io_errors = 1151;
pub const AWS_ERROR_PKCS11_CKR_RANDOM_NO_RNG: aws_io_errors = 1152;
pub const AWS_ERROR_PKCS11_CKR_DOMAIN_PARAMS_INVALID: aws_io_errors = 1153;
pub const AWS_ERROR_PKCS11_CKR_CURVE_NOT_SUPPORTED: aws_io_errors = 1154;
pub const AWS_ERROR_PKCS11_CKR_BUFFER_TOO_SMALL: aws_io_errors = 1155;
pub const AWS_ERROR_PKCS11_CKR_SAVED_STATE_INVALID: aws_io_errors = 1156;
pub const AWS_ERROR_PKCS11_CKR_INFORMATION_SENSITIVE: aws_io_errors = 1157;
pub const AWS_ERROR_PKCS11_CKR_STATE_UNSAVEABLE: aws_io_errors = 1158;
pub const AWS_ERROR_PKCS11_CKR_CRYPTOKI_NOT_INITIALIZED: aws_io_errors = 1159;
pub const AWS_ERROR_PKCS11_CKR_CRYPTOKI_ALREADY_INITIALIZED: aws_io_errors = 1160;
pub const AWS_ERROR_PKCS11_CKR_MUTEX_BAD: aws_io_errors = 1161;
pub const AWS_ERROR_PKCS11_CKR_MUTEX_NOT_LOCKED: aws_io_errors = 1162;
pub const AWS_ERROR_PKCS11_CKR_NEW_PIN_MODE: aws_io_errors = 1163;
pub const AWS_ERROR_PKCS11_CKR_NEXT_OTP: aws_io_errors = 1164;
pub const AWS_ERROR_PKCS11_CKR_EXCEEDED_MAX_ITERATIONS: aws_io_errors = 1165;
pub const AWS_ERROR_PKCS11_CKR_FIPS_SELF_TEST_FAILED: aws_io_errors = 1166;
pub const AWS_ERROR_PKCS11_CKR_LIBRARY_LOAD_FAILED: aws_io_errors = 1167;
pub const AWS_ERROR_PKCS11_CKR_PIN_TOO_WEAK: aws_io_errors = 1168;
pub const AWS_ERROR_PKCS11_CKR_PUBLIC_KEY_INVALID: aws_io_errors = 1169;
pub const AWS_ERROR_PKCS11_CKR_FUNCTION_REJECTED: aws_io_errors = 1170;
pub const AWS_ERROR_IO_PINNED_EVENT_LOOP_MISMATCH: aws_io_errors = 1171;
pub const AWS_ERROR_PKCS11_ENCODING_ERROR: aws_io_errors = 1172;
pub const AWS_IO_TLS_ERROR_DEFAULT_TRUST_STORE_NOT_FOUND: aws_io_errors = 1173;
pub const AWS_IO_STREAM_SEEK_FAILED: aws_io_errors = 1174;
pub const AWS_IO_STREAM_GET_LENGTH_FAILED: aws_io_errors = 1175;
pub const AWS_IO_STREAM_SEEK_UNSUPPORTED: aws_io_errors = 1176;
pub const AWS_IO_STREAM_GET_LENGTH_UNSUPPORTED: aws_io_errors = 1177;
pub const AWS_IO_TLS_ERROR_READ_FAILURE: aws_io_errors = 1178;
pub const AWS_ERROR_PEM_MALFORMED: aws_io_errors = 1179;
pub const AWS_IO_ERROR_END_RANGE: aws_io_errors = 2047;
pub const AWS_IO_INVALID_FILE_HANDLE: aws_io_errors = 50;
pub const AWS_CHANNEL_DIR_READ: aws_channel_direction = 0;
pub const AWS_CHANNEL_DIR_WRITE: aws_channel_direction = 1;
pub const AWS_ADDRESS_RECORD_TYPE_A: aws_address_record_type = 0;
pub const AWS_ADDRESS_RECORD_TYPE_AAAA: aws_address_record_type = 1;
pub const AWS_GET_HOST_ADDRESS_COUNT_RECORD_TYPE_A: aws_get_host_address_flags = 1;
pub const AWS_GET_HOST_ADDRESS_COUNT_RECORD_TYPE_AAAA: aws_get_host_address_flags = 2;
pub const AWS_IO_EVENT_TYPE_READABLE: aws_io_event_type = 1;
pub const AWS_IO_EVENT_TYPE_WRITABLE: aws_io_event_type = 2;
pub const AWS_IO_EVENT_TYPE_REMOTE_HANG_UP: aws_io_event_type = 4;
pub const AWS_IO_EVENT_TYPE_CLOSED: aws_io_event_type = 8;
pub const AWS_IO_EVENT_TYPE_ERROR: aws_io_event_type = 16;
pub const AWS_LS_IO_GENERAL: aws_io_log_subject = 1024;
pub const AWS_LS_IO_EVENT_LOOP: aws_io_log_subject = 1025;
pub const AWS_LS_IO_SOCKET: aws_io_log_subject = 1026;
pub const AWS_LS_IO_SOCKET_HANDLER: aws_io_log_subject = 1027;
pub const AWS_LS_IO_TLS: aws_io_log_subject = 1028;
pub const AWS_LS_IO_ALPN: aws_io_log_subject = 1029;
pub const AWS_LS_IO_DNS: aws_io_log_subject = 1030;
pub const AWS_LS_IO_PKI: aws_io_log_subject = 1031;
pub const AWS_LS_IO_CHANNEL: aws_io_log_subject = 1032;
pub const AWS_LS_IO_CHANNEL_BOOTSTRAP: aws_io_log_subject = 1033;
pub const AWS_LS_IO_FILE_UTILS: aws_io_log_subject = 1034;
pub const AWS_LS_IO_SHARED_LIBRARY: aws_io_log_subject = 1035;
pub const AWS_LS_IO_EXPONENTIAL_BACKOFF_RETRY_STRATEGY: aws_io_log_subject = 1036;
pub const AWS_LS_IO_STANDARD_RETRY_STRATEGY: aws_io_log_subject = 1037;
pub const AWS_LS_IO_PKCS11: aws_io_log_subject = 1038;
pub const AWS_LS_IO_PEM: aws_io_log_subject = 1039;
pub const AWS_IO_LS_LAST: aws_io_log_subject = 2047;
pub const AWS_PEM_TYPE_UNKNOWN: aws_pem_object_type = 0;
pub const AWS_PEM_TYPE_X509_OLD: aws_pem_object_type = 1;
pub const AWS_PEM_TYPE_X509: aws_pem_object_type = 2;
pub const AWS_PEM_TYPE_X509_TRUSTED: aws_pem_object_type = 3;
pub const AWS_PEM_TYPE_X509_REQ_OLD: aws_pem_object_type = 4;
pub const AWS_PEM_TYPE_X509_REQ: aws_pem_object_type = 5;
pub const AWS_PEM_TYPE_X509_CRL: aws_pem_object_type = 6;
pub const AWS_PEM_TYPE_EVP_PKEY: aws_pem_object_type = 7;
pub const AWS_PEM_TYPE_PUBLIC_PKCS8: aws_pem_object_type = 8;
pub const AWS_PEM_TYPE_PRIVATE_RSA_PKCS1: aws_pem_object_type = 9;
pub const AWS_PEM_TYPE_PUBLIC_RSA_PKCS1: aws_pem_object_type = 10;
pub const AWS_PEM_TYPE_PRIVATE_DSA_PKCS1: aws_pem_object_type = 11;
pub const AWS_PEM_TYPE_PUBLIC_DSA_PKCS1: aws_pem_object_type = 12;
pub const AWS_PEM_TYPE_PKCS7: aws_pem_object_type = 13;
pub const AWS_PEM_TYPE_PKCS7_SIGNED_DATA: aws_pem_object_type = 14;
pub const AWS_PEM_TYPE_PRIVATE_PKCS8_ENCRYPTED: aws_pem_object_type = 15;
pub const AWS_PEM_TYPE_PRIVATE_PKCS8: aws_pem_object_type = 16;
pub const AWS_PEM_TYPE_DH_PARAMETERS: aws_pem_object_type = 17;
pub const AWS_PEM_TYPE_DH_PARAMETERS_X942: aws_pem_object_type = 18;
pub const AWS_PEM_TYPE_SSL_SESSION_PARAMETERS: aws_pem_object_type = 19;
pub const AWS_PEM_TYPE_DSA_PARAMETERS: aws_pem_object_type = 20;
pub const AWS_PEM_TYPE_ECDSA_PUBLIC: aws_pem_object_type = 21;
pub const AWS_PEM_TYPE_EC_PARAMETERS: aws_pem_object_type = 22;
pub const AWS_PEM_TYPE_EC_PRIVATE: aws_pem_object_type = 23;
pub const AWS_PEM_TYPE_PARAMETERS: aws_pem_object_type = 24;
pub const AWS_PEM_TYPE_CMS: aws_pem_object_type = 25;
pub const AWS_PEM_TYPE_SM2_PARAMETERS: aws_pem_object_type = 26;
#[doc = " Default behavior that accommodates most use cases.\n C_Initialize() is called on creation, and \"already-initialized\" errors are ignored.\n C_Finalize() is never called, just in case another part of your\n application is still using the PKCS#11 library."]
pub const AWS_PKCS11_LIB_DEFAULT_BEHAVIOR: aws_pkcs11_lib_behavior = 0;
#[doc = " Skip calling C_Initialize() and C_Finalize().\n Use this if your application has already initialized the PKCS#11 library,\n and you do not want C_Initialize() called again."]
pub const AWS_PKCS11_LIB_OMIT_INITIALIZE: aws_pkcs11_lib_behavior = 1;
#[doc = " C_Initialize() is called on creation and C_Finalize() is called on cleanup.\n If C_Initialize() reports that's it's already initialized, this is treated as an error.\n Use this if you need perfect cleanup (ex: running valgrind with --leak-check)."]
pub const AWS_PKCS11_LIB_STRICT_INITIALIZE_FINALIZE: aws_pkcs11_lib_behavior = 2;
#[doc = " This is a connection level error such as a socket timeout, socket connect error, tls negotiation timeout etc...\n Typically these should never be applied for non-idempotent request types since in this scenario, it's impossible\n to know whether the operation had a side effect on the server."]
pub const AWS_RETRY_ERROR_TYPE_TRANSIENT: aws_retry_error_type = 0;
#[doc = " This is an error where the server explicitly told the client to back off, such as a 429 or 503 Http error."]
pub const AWS_RETRY_ERROR_TYPE_THROTTLING: aws_retry_error_type = 1;
#[doc = " This is a server error that isn't explicitly throttling but is considered by the client\n to be something that should be retried."]
pub const AWS_RETRY_ERROR_TYPE_SERVER_ERROR: aws_retry_error_type = 2;
#[doc = " Doesn't count against any budgets. This could be something like a 401 challenge in Http."]
pub const AWS_RETRY_ERROR_TYPE_CLIENT_ERROR: aws_retry_error_type = 3;
pub const AWS_EXPONENTIAL_BACKOFF_JITTER_DEFAULT: aws_exponential_backoff_jitter_mode = 0;
pub const AWS_EXPONENTIAL_BACKOFF_JITTER_NONE: aws_exponential_backoff_jitter_mode = 1;
pub const AWS_EXPONENTIAL_BACKOFF_JITTER_FULL: aws_exponential_backoff_jitter_mode = 2;
pub const AWS_EXPONENTIAL_BACKOFF_JITTER_DECORRELATED: aws_exponential_backoff_jitter_mode = 3;
pub const AWS_SOCKET_IPV4: aws_socket_domain = 0;
pub const AWS_SOCKET_IPV6: aws_socket_domain = 1;
pub const AWS_SOCKET_LOCAL: aws_socket_domain = 2;
pub const AWS_SOCKET_VSOCK: aws_socket_domain = 3;
pub const AWS_SOCKET_STREAM: aws_socket_type = 0;
pub const AWS_SOCKET_DGRAM: aws_socket_type = 1;
pub const AWS_IO_SSLv3: aws_tls_versions = 0;
pub const AWS_IO_TLSv1: aws_tls_versions = 1;
pub const AWS_IO_TLSv1_1: aws_tls_versions = 2;
pub const AWS_IO_TLSv1_2: aws_tls_versions = 3;
pub const AWS_IO_TLSv1_3: aws_tls_versions = 4;
pub const AWS_IO_TLS_VER_SYS_DEFAULTS: aws_tls_versions = 128;
pub const AWS_IO_TLS_CIPHER_PREF_SYSTEM_DEFAULT: aws_tls_cipher_pref = 0;
pub const AWS_IO_TLS_CIPHER_PREF_KMS_PQ_TLSv1_0_2019_06: aws_tls_cipher_pref = 1;
pub const AWS_IO_TLS_CIPHER_PREF_KMS_PQ_SIKE_TLSv1_0_2019_11: aws_tls_cipher_pref = 2;
pub const AWS_IO_TLS_CIPHER_PREF_KMS_PQ_TLSv1_0_2020_02: aws_tls_cipher_pref = 3;
pub const AWS_IO_TLS_CIPHER_PREF_KMS_PQ_SIKE_TLSv1_0_2020_02: aws_tls_cipher_pref = 4;
pub const AWS_IO_TLS_CIPHER_PREF_KMS_PQ_TLSv1_0_2020_07: aws_tls_cipher_pref = 5;
pub const AWS_IO_TLS_CIPHER_PREF_PQ_TLSv1_0_2021_05: aws_tls_cipher_pref = 6;
pub const AWS_IO_TLS_CIPHER_PREF_END_RANGE: aws_tls_cipher_pref = 65535;
pub const AWS_TLS_HASH_UNKNOWN: aws_tls_hash_algorithm = 0;
pub const AWS_TLS_HASH_SHA1: aws_tls_hash_algorithm = 1;
pub const AWS_TLS_HASH_SHA224: aws_tls_hash_algorithm = 2;
pub const AWS_TLS_HASH_SHA256: aws_tls_hash_algorithm = 3;
pub const AWS_TLS_HASH_SHA384: aws_tls_hash_algorithm = 4;
pub const AWS_TLS_HASH_SHA512: aws_tls_hash_algorithm = 5;
pub const AWS_TLS_SIGNATURE_UNKNOWN: aws_tls_signature_algorithm = 0;
pub const AWS_TLS_SIGNATURE_RSA: aws_tls_signature_algorithm = 1;
pub const AWS_TLS_SIGNATURE_ECDSA: aws_tls_signature_algorithm = 2;
pub const AWS_TLS_KEY_OPERATION_UNKNOWN: aws_tls_key_operation_type = 0;
pub const AWS_TLS_KEY_OPERATION_SIGN: aws_tls_key_operation_type = 1;
pub const AWS_TLS_KEY_OPERATION_DECRYPT: aws_tls_key_operation_type = 2;
pub const AWS_TLS_NEGOTIATION_STATUS_NONE: aws_tls_negotiation_status = 0;
pub const AWS_TLS_NEGOTIATION_STATUS_ONGOING: aws_tls_negotiation_status = 1;
pub const AWS_TLS_NEGOTIATION_STATUS_SUCCESS: aws_tls_negotiation_status = 2;
pub const AWS_TLS_NEGOTIATION_STATUS_FAILURE: aws_tls_negotiation_status = 3;
pub const AWSCRT_STAT_CAT_SOCKET: aws_crt_io_statistics_category = 256;
pub const AWSCRT_STAT_CAT_TLS: aws_crt_io_statistics_category = 257;
pub const AWS_SSB_BEGIN: aws_stream_seek_basis = 0;
pub const AWS_SSB_END: aws_stream_seek_basis = 2;
#[repr(C)]
#[derive(Copy, Clone)]
pub union aws_io_handle__bindgen_ty_1 {
    pub fd: ::core::ffi::c_int,
    pub handle: *mut ::core::ffi::c_void,
}
extern "C" {
    #[doc = " Initializes internal datastructures used by aws-c-io.\n Must be called before using any functionality in aws-c-io."]
    pub fn aws_io_library_init(allocator: *mut aws_allocator);
    #[doc = " Shuts down the internal datastructures used by aws-c-io."]
    pub fn aws_io_library_clean_up();
    pub fn aws_io_fatal_assert_library_initialized();
    #[doc = " Initialize aws_async_input_stream \"base class\""]
    pub fn aws_async_input_stream_init_base(
        stream: *mut aws_async_input_stream,
        alloc: *mut aws_allocator,
        vtable: *const aws_async_input_stream_vtable,
        impl_: *mut ::core::ffi::c_void,
    );
    #[doc = " Increment reference count.\n You may pass in NULL (has no effect).\n Returns whatever pointer was passed in."]
    pub fn aws_async_input_stream_acquire(
        stream: *mut aws_async_input_stream,
    ) -> *mut aws_async_input_stream;
    #[doc = " Decrement reference count.\n You may pass in NULL (has no effect).\n Always returns NULL."]
    pub fn aws_async_input_stream_release(
        stream: *mut aws_async_input_stream,
    ) -> *mut aws_async_input_stream;
    #[doc = " Read once from the async stream into the buffer.\n The read completes when at least 1 byte is read, the buffer is full, or EOF is reached.\n Depending on implementation, the read could complete at any time.\n It may complete synchronously. It may complete on another thread.\n Returns a future, which will contain an error code if something went wrong,\n or a result bool indicating whether EOF has been reached.\n\n WARNING: The buffer must have space available.\n WARNING: Do not read again until the previous read is complete."]
    pub fn aws_async_input_stream_read(
        stream: *mut aws_async_input_stream,
        dest: *mut aws_byte_buf,
    ) -> *mut aws_future_bool;
    #[doc = " Read repeatedly from the async stream until the buffer is full, or EOF is reached.\n Depending on implementation, this could complete at any time.\n It may complete synchronously. It may complete on another thread.\n Returns a future, which will contain an error code if something went wrong,\n or a result bool indicating whether EOF has been reached.\n\n WARNING: The buffer must have space available.\n WARNING: Do not read again until the previous read is complete."]
    pub fn aws_async_input_stream_read_to_fill(
        stream: *mut aws_async_input_stream,
        dest: *mut aws_byte_buf,
    ) -> *mut aws_future_bool;
    pub static mut g_aws_channel_max_fragment_size: usize;
    #[doc = " Initializes channel_task for use."]
    pub fn aws_channel_task_init(
        channel_task: *mut aws_channel_task,
        task_fn: aws_channel_task_fn,
        arg: *mut ::core::ffi::c_void,
        type_tag: *const ::core::ffi::c_char,
    );
    #[doc = " Allocates new channel, Unless otherwise specified all functions for channels and channel slots must be executed\n within that channel's event-loop's thread. channel_options are copied."]
    pub fn aws_channel_new(
        allocator: *mut aws_allocator,
        creation_args: *const aws_channel_options,
    ) -> *mut aws_channel;
    #[doc = " Mark the channel, along with all slots and handlers, for destruction.\n Must be called after shutdown has completed.\n Can be called from any thread assuming 'aws_channel_shutdown()' has completed.\n Note that memory will not be freed until all users which acquired holds on the channel via\n aws_channel_acquire_hold(), release them via aws_channel_release_hold()."]
    pub fn aws_channel_destroy(channel: *mut aws_channel);
    #[doc = " Initiates shutdown of the channel. Shutdown will begin with the left-most slot. Each handler will invoke\n 'aws_channel_slot_on_handler_shutdown_complete' once they've finished their shutdown process for the read direction.\n Once the right-most slot has shutdown in the read direction, the process will start shutting down starting on the\n right-most slot. Once the left-most slot has shutdown in the write direction, 'callbacks->shutdown_completed' will be\n invoked in the event loop's thread.\n\n This function can be called from any thread."]
    pub fn aws_channel_shutdown(
        channel: *mut aws_channel,
        error_code: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    #[doc = " Prevent a channel's memory from being freed.\n Any number of users may acquire a hold to prevent a channel and its handlers from being unexpectedly freed.\n Any user which acquires a hold must release it via aws_channel_release_hold().\n Memory will be freed once all holds are released and aws_channel_destroy() has been called."]
    pub fn aws_channel_acquire_hold(channel: *mut aws_channel);
    #[doc = " Release a hold on the channel's memory, allowing it to be freed.\n This may be called before or after aws_channel_destroy()."]
    pub fn aws_channel_release_hold(channel: *mut aws_channel);
    #[doc = " Allocates and initializes a new slot for use with the channel. If this is the first slot in the channel, it will\n automatically be added to the channel as the first slot. For all subsequent calls on a given channel, the slot will\n need to be added to the channel via. the aws_channel_slot_insert_right(), aws_channel_slot_insert_end(), and\n aws_channel_slot_insert_left() APIs."]
    pub fn aws_channel_slot_new(channel: *mut aws_channel) -> *mut aws_channel_slot;
    #[doc = " Fetches the event loop the channel is a part of."]
    pub fn aws_channel_get_event_loop(channel: *mut aws_channel) -> *mut aws_event_loop;
    #[doc = " Fetches the current timestamp from the event-loop's clock, in nanoseconds."]
    pub fn aws_channel_current_clock_time(
        channel: *mut aws_channel,
        time_nanos: *mut u64,
    ) -> ::core::ffi::c_int;
    #[doc = " Retrieves an object by key from the event loop's local storage."]
    pub fn aws_channel_fetch_local_object(
        channel: *mut aws_channel,
        key: *const ::core::ffi::c_void,
        obj: *mut aws_event_loop_local_object,
    ) -> ::core::ffi::c_int;
    #[doc = " Stores an object by key in the event loop's local storage."]
    pub fn aws_channel_put_local_object(
        channel: *mut aws_channel,
        key: *const ::core::ffi::c_void,
        obj: *const aws_event_loop_local_object,
    ) -> ::core::ffi::c_int;
    #[doc = " Removes an object by key from the event loop's local storage."]
    pub fn aws_channel_remove_local_object(
        channel: *mut aws_channel,
        key: *const ::core::ffi::c_void,
        removed_obj: *mut aws_event_loop_local_object,
    ) -> ::core::ffi::c_int;
    #[doc = " Acquires a message from the event loop's message pool. size_hint is merely a hint, it may be smaller than you\n requested and you are responsible for checking the bounds of it. If the returned message is not large enough, you\n must send multiple messages."]
    pub fn aws_channel_acquire_message_from_pool(
        channel: *mut aws_channel,
        message_type: aws_io_message_type,
        size_hint: usize,
    ) -> *mut aws_io_message;
    #[doc = " Schedules a task to run on the event loop as soon as possible.\n This is the ideal way to move a task into the correct thread. It's also handy for context switches.\n This function is safe to call from any thread.\n\n If called from the channel's event loop, the task will get directly added to the run-now list.\n If called from outside the channel's event loop, the task will go into a cross-thread task queue.\n\n If tasks must be serialized relative to some source synchronization, you may not want to use this API\n because tasks submitted from the event loop thread can \"jump ahead\" of tasks submitted from external threads\n due to this optimization.  If this is a problem, you can either refactor your submission logic or use\n the aws_channel_schedule_task_now_serialized variant which does not perform this optimization.\n\n The task should not be cleaned up or modified until its function is executed."]
    pub fn aws_channel_schedule_task_now(channel: *mut aws_channel, task: *mut aws_channel_task);
    #[doc = " Schedules a task to run on the event loop as soon as possible.\n\n This variant always uses the cross thread queue rather than conditionally skipping it when already in\n the destination event loop.  While not \"optimal\", this allows us to serialize task execution no matter where\n the task was submitted from: if you are submitting tasks from a critical section, the serialized order that you\n submit is guaranteed to be the order that they execute on the event loop.\n\n The task should not be cleaned up or modified until its function is executed."]
    pub fn aws_channel_schedule_task_now_serialized(
        channel: *mut aws_channel,
        task: *mut aws_channel_task,
    );
    #[doc = " Schedules a task to run on the event loop at the specified time.\n This is the ideal way to move a task into the correct thread. It's also handy for context switches.\n Use aws_channel_current_clock_time() to get the current time in nanoseconds.\n This function is safe to call from any thread.\n\n The task should not be cleaned up or modified until its function is executed."]
    pub fn aws_channel_schedule_task_future(
        channel: *mut aws_channel,
        task: *mut aws_channel_task,
        run_at_nanos: u64,
    );
    #[doc = " Instrument a channel with a statistics handler.  While instrumented with a statistics handler, the channel\n will periodically report per-channel-handler-specific statistics about handler performance and state.\n\n Assigning a statistics handler to a channel is a transfer of ownership -- the channel will clean up\n the handler appropriately.  Statistics handlers may be changed dynamically (for example, the upgrade\n from a vanilla http channel to a websocket channel), but this function may only be called from the\n event loop thread that the channel is a part of.\n\n The first possible hook to set a statistics handler is the channel's creation callback."]
    pub fn aws_channel_set_statistics_handler(
        channel: *mut aws_channel,
        handler: *mut aws_crt_statistics_handler,
    ) -> ::core::ffi::c_int;
    #[doc = " Returns true if the caller is on the event loop's thread. If false, you likely need to use\n aws_channel_schedule_task(). This function is safe to call from any thread."]
    pub fn aws_channel_thread_is_callers_thread(channel: *mut aws_channel) -> bool;
    #[doc = " Sets the handler for a slot, the slot will also call get_current_window_size() and propagate a window update\n upstream."]
    pub fn aws_channel_slot_set_handler(
        slot: *mut aws_channel_slot,
        handler: *mut aws_channel_handler,
    ) -> ::core::ffi::c_int;
    #[doc = " Removes slot from the channel and deallocates the slot and its handler."]
    pub fn aws_channel_slot_remove(slot: *mut aws_channel_slot) -> ::core::ffi::c_int;
    #[doc = " Replaces remove with new_slot. Deallocates remove and its handler."]
    pub fn aws_channel_slot_replace(
        remove: *mut aws_channel_slot,
        new_slot: *mut aws_channel_slot,
    ) -> ::core::ffi::c_int;
    #[doc = " inserts 'to_add' to the position immediately to the right of slot. Note that the first call to\n aws_channel_slot_new() adds it to the channel implicitly."]
    pub fn aws_channel_slot_insert_right(
        slot: *mut aws_channel_slot,
        to_add: *mut aws_channel_slot,
    ) -> ::core::ffi::c_int;
    #[doc = " Inserts to 'to_add' the end of the channel. Note that the first call to\n aws_channel_slot_new() adds it to the channel implicitly."]
    pub fn aws_channel_slot_insert_end(
        channel: *mut aws_channel,
        to_add: *mut aws_channel_slot,
    ) -> ::core::ffi::c_int;
    #[doc = " inserts 'to_add' to the position immediately to the left of slot. Note that the first call to\n aws_channel_slot_new() adds it to the channel implicitly."]
    pub fn aws_channel_slot_insert_left(
        slot: *mut aws_channel_slot,
        to_add: *mut aws_channel_slot,
    ) -> ::core::ffi::c_int;
    #[doc = " Sends a message to the adjacent slot in the channel based on dir. Also does window size checking.\n\n NOTE: if this function returns an error code, it is the caller's responsibility to release message\n back to the pool. If this function returns AWS_OP_SUCCESS, the recipient of the message has taken\n ownership of the message. So, for example, don't release a message to the pool and then return an error.\n If you encounter an error condition in this case, shutdown the channel with the appropriate error code."]
    pub fn aws_channel_slot_send_message(
        slot: *mut aws_channel_slot,
        message: *mut aws_io_message,
        dir: aws_channel_direction,
    ) -> ::core::ffi::c_int;
    #[doc = " Convenience function that invokes aws_channel_acquire_message_from_pool(),\n asking for the largest reasonable DATA message that can be sent in the write direction,\n with upstream overhead accounted for."]
    pub fn aws_channel_slot_acquire_max_message_for_write(
        slot: *mut aws_channel_slot,
    ) -> *mut aws_io_message;
    #[doc = " Issues a window update notification upstream (to the left.)"]
    pub fn aws_channel_slot_increment_read_window(
        slot: *mut aws_channel_slot,
        window: usize,
    ) -> ::core::ffi::c_int;
    #[doc = " Called by handlers once they have finished their shutdown in the 'dir' direction. Propagates the shutdown process\n to the next handler in the channel."]
    pub fn aws_channel_slot_on_handler_shutdown_complete(
        slot: *mut aws_channel_slot,
        dir: aws_channel_direction,
        err_code: ::core::ffi::c_int,
        free_scarce_resources_immediately: bool,
    ) -> ::core::ffi::c_int;
    #[doc = " Initiates shutdown on slot. callbacks->on_shutdown_completed will be called\n once the shutdown process is completed."]
    pub fn aws_channel_slot_shutdown(
        slot: *mut aws_channel_slot,
        dir: aws_channel_direction,
        err_code: ::core::ffi::c_int,
        free_scarce_resources_immediately: bool,
    ) -> ::core::ffi::c_int;
    #[doc = " Fetches the downstream read window. This gives you the information necessary to honor the read window. If you call\n send_message() and it exceeds this window, the message will be rejected."]
    pub fn aws_channel_slot_downstream_read_window(slot: *mut aws_channel_slot) -> usize;
    #[doc = " Fetches the current overhead of upstream handlers. This provides a hint to avoid fragmentation if you care."]
    pub fn aws_channel_slot_upstream_message_overhead(slot: *mut aws_channel_slot) -> usize;
    #[doc = " Calls destroy on handler's vtable"]
    pub fn aws_channel_handler_destroy(handler: *mut aws_channel_handler);
    #[doc = " Calls process_read_message on handler's vtable"]
    pub fn aws_channel_handler_process_read_message(
        handler: *mut aws_channel_handler,
        slot: *mut aws_channel_slot,
        message: *mut aws_io_message,
    ) -> ::core::ffi::c_int;
    #[doc = " Calls process_write_message on handler's vtable."]
    pub fn aws_channel_handler_process_write_message(
        handler: *mut aws_channel_handler,
        slot: *mut aws_channel_slot,
        message: *mut aws_io_message,
    ) -> ::core::ffi::c_int;
    #[doc = " Calls on_window_update on handler's vtable."]
    pub fn aws_channel_handler_increment_read_window(
        handler: *mut aws_channel_handler,
        slot: *mut aws_channel_slot,
        size: usize,
    ) -> ::core::ffi::c_int;
    #[doc = " calls shutdown_direction on handler's vtable."]
    pub fn aws_channel_handler_shutdown(
        handler: *mut aws_channel_handler,
        slot: *mut aws_channel_slot,
        dir: aws_channel_direction,
        error_code: ::core::ffi::c_int,
        free_scarce_resources_immediately: bool,
    ) -> ::core::ffi::c_int;
    #[doc = " Calls initial_window_size on handler's vtable."]
    pub fn aws_channel_handler_initial_window_size(handler: *mut aws_channel_handler) -> usize;
    pub fn aws_channel_get_first_slot(channel: *mut aws_channel) -> *mut aws_channel_slot;
    #[doc = " A way for external processes to force a read by the data-source channel handler.  Necessary in certain cases, like\n when a server channel finishes setting up its initial handlers, a read may have already been triggered on the\n socket (the client's CLIENT_HELLO tls payload, for example) and absent further data/notifications, this data\n would never get processed."]
    pub fn aws_channel_trigger_read(channel: *mut aws_channel) -> ::core::ffi::c_int;
    #[doc = " Copies `from` to `to`."]
    pub fn aws_host_address_copy(
        from: *const aws_host_address,
        to: *mut aws_host_address,
    ) -> ::core::ffi::c_int;
    #[doc = " Moves `from` to `to`. After this call, from is no longer usable. Though, it could be resused for another\n move or copy operation."]
    pub fn aws_host_address_move(from: *mut aws_host_address, to: *mut aws_host_address);
    #[doc = " Cleans up the memory for `address`"]
    pub fn aws_host_address_clean_up(address: *mut aws_host_address);
    #[doc = " WARNING! do not call this function directly (getaddrinfo()): it blocks. Provide a pointer to this function for other\n resolution functions."]
    pub fn aws_default_dns_resolve(
        allocator: *mut aws_allocator,
        host_name: *const aws_string,
        output_addresses: *mut aws_array_list,
        user_data: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    #[doc = " Creates a host resolver with the default behavior. Here's the behavior:\n\n Since there's not a reliable way to do non-blocking DNS without a ton of risky work that would need years of testing\n on every Unix system in existence, we work around it by doing a threaded implementation.\n\n When you request an address, it checks the cache. If the entry isn't in the cache it creates a new one.\n Each entry has a potentially short lived back-ground thread based on ttl for the records. Once we've populated the\n cache and you keep the resolver active, the resolution callback will be invoked immediately. When it's idle, it will\n take a little while in the background thread to fetch more, evaluate TTLs etc... In that case your callback will be\n invoked from the background thread.\n\n --------------------------------------------------------------------------------------------------------------------\n\n A few things to note about TTLs and connection failures.\n\n We attempt to honor your max ttl but will not honor it if dns queries are failing or all of your connections are\n marked as failed. Once we are able to query dns again, we will re-evaluate the TTLs.\n\n Upon notification connection failures, we move them to a separate list. Eventually we retry them when it's likely\n that the endpoint is healthy again or we don't really have another choice, but we try to keep them out of your\n hot path.\n\n ---------------------------------------------------------------------------------------------------------------------\n\n Finally, this entire design attempts to prevent problems where developers have to choose between large TTLs and thus\n sticky hosts or short TTLs and good fleet utilization but now higher latencies. In this design, we resolve every\n second in the background (only while you're actually using the record), but we do not expire the earlier resolved\n addresses until max ttl has passed.\n\n This for example, should enable you to hit thousands of hosts in the Amazon S3 fleet instead of just one or two."]
    pub fn aws_host_resolver_new_default(
        allocator: *mut aws_allocator,
        options: *const aws_host_resolver_default_options,
    ) -> *mut aws_host_resolver;
    #[doc = " Increments the reference count on the host resolver, allowing the caller to take a reference to it.\n\n Returns the same host resolver passed in."]
    pub fn aws_host_resolver_acquire(resolver: *mut aws_host_resolver) -> *mut aws_host_resolver;
    #[doc = " Decrements a host resolver's ref count.  When the ref count drops to zero, the resolver will be destroyed."]
    pub fn aws_host_resolver_release(resolver: *mut aws_host_resolver);
    #[doc = " calls resolve_host on the vtable. config will be copied."]
    pub fn aws_host_resolver_resolve_host(
        resolver: *mut aws_host_resolver,
        host_name: *const aws_string,
        res: aws_on_host_resolved_result_fn,
        config: *const aws_host_resolution_config,
        user_data: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    #[doc = " calls record_connection_failure on the vtable."]
    pub fn aws_host_resolver_record_connection_failure(
        resolver: *mut aws_host_resolver,
        address: *const aws_host_address,
    ) -> ::core::ffi::c_int;
    #[doc = " @Deprecated Use purge_cache_with_callback instead\n calls purge_cache on the vtable."]
    pub fn aws_host_resolver_purge_cache(resolver: *mut aws_host_resolver) -> ::core::ffi::c_int;
    #[doc = " Calls aws_host_resolver_purge_cache_with_callback on the vtable which will wipe out everything host resolver has\n cached."]
    pub fn aws_host_resolver_purge_cache_with_callback(
        resolver: *mut aws_host_resolver,
        on_purge_cache_complete_callback: aws_simple_completion_callback,
        user_data: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    #[doc = " Removes the cache for a host asynchronously."]
    pub fn aws_host_resolver_purge_host_cache(
        resolver: *mut aws_host_resolver,
        options: *const aws_host_resolver_purge_host_options,
    ) -> ::core::ffi::c_int;
    #[doc = " get number of addresses for a given host."]
    pub fn aws_host_resolver_get_host_address_count(
        resolver: *mut aws_host_resolver,
        host_name: *const aws_string,
        flags: u32,
    ) -> usize;
    #[doc = " Returns the default host resolution config used internally if none specified.\n\n @return default host resolution config"]
    pub fn aws_host_resolver_init_default_resolution_config() -> aws_host_resolution_config;
    #[doc = " Create the client bootstrap."]
    pub fn aws_client_bootstrap_new(
        allocator: *mut aws_allocator,
        options: *const aws_client_bootstrap_options,
    ) -> *mut aws_client_bootstrap;
    #[doc = " Increments a client bootstrap's ref count, allowing the caller to take a reference to it.\n\n Returns the same client bootstrap passed in."]
    pub fn aws_client_bootstrap_acquire(
        bootstrap: *mut aws_client_bootstrap,
    ) -> *mut aws_client_bootstrap;
    #[doc = " Decrements a client bootstrap's ref count.  When the ref count drops to zero, the bootstrap will be destroyed."]
    pub fn aws_client_bootstrap_release(bootstrap: *mut aws_client_bootstrap);
    #[doc = " When using TLS, if ALPN is used, this callback will be invoked from the channel. The returned handler will be added\n to the channel."]
    pub fn aws_client_bootstrap_set_alpn_callback(
        bootstrap: *mut aws_client_bootstrap,
        on_protocol_negotiated: aws_channel_on_protocol_negotiated_fn,
    ) -> ::core::ffi::c_int;
    #[doc = " Sets up a client socket channel."]
    pub fn aws_client_bootstrap_new_socket_channel(
        options: *mut aws_socket_channel_bootstrap_options,
    ) -> ::core::ffi::c_int;
    #[doc = " Initializes the server bootstrap with `allocator` and `el_group`. This object manages listeners, server connections,\n and channels."]
    pub fn aws_server_bootstrap_new(
        allocator: *mut aws_allocator,
        el_group: *mut aws_event_loop_group,
    ) -> *mut aws_server_bootstrap;
    #[doc = " Increments a server bootstrap's ref count, allowing the caller to take a reference to it.\n\n Returns the same server bootstrap passed in."]
    pub fn aws_server_bootstrap_acquire(
        bootstrap: *mut aws_server_bootstrap,
    ) -> *mut aws_server_bootstrap;
    #[doc = " Decrements a server bootstrap's ref count.  When the ref count drops to zero, the bootstrap will be destroyed."]
    pub fn aws_server_bootstrap_release(bootstrap: *mut aws_server_bootstrap);
    #[doc = " When using TLS, if ALPN is used, this callback will be invoked from the channel. The returned handler will be added\n to the channel."]
    pub fn aws_server_bootstrap_set_alpn_callback(
        bootstrap: *mut aws_server_bootstrap,
        on_protocol_negotiated: aws_channel_on_protocol_negotiated_fn,
    ) -> ::core::ffi::c_int;
    #[doc = " Sets up a server socket listener. If you are planning on using TLS, use\n `aws_server_bootstrap_new_tls_socket_listener` instead. This creates a socket listener bound to `local_endpoint`\n using socket options `options`. `incoming_callback` will be invoked once an incoming channel is ready for use or if\n an error is encountered. `shutdown_callback` will be invoked once the channel has shutdown. `destroy_callback` will\n be invoked after the server socket listener is destroyed, and all associated connections and channels have finished\n shutting down. Immediately after the `shutdown_callback` returns, the channel is cleaned up automatically. All\n callbacks are invoked the thread of the event-loop that the listening socket is assigned to\n\n Upon shutdown of your application, you'll want to call `aws_server_bootstrap_destroy_socket_listener` with the return\n value from this function.\n\n bootstrap_options is copied."]
    pub fn aws_server_bootstrap_new_socket_listener(
        bootstrap_options: *const aws_server_socket_channel_bootstrap_options,
    ) -> *mut aws_socket;
    #[doc = " Shuts down 'listener' and cleans up any resources associated with it. Any incoming channels on `listener` will still\n be active. `destroy_callback` will be invoked after the server socket listener is destroyed, and all associated\n connections and channels have finished shutting down."]
    pub fn aws_server_bootstrap_destroy_socket_listener(
        bootstrap: *mut aws_server_bootstrap,
        listener: *mut aws_socket,
    );
    #[doc = " Creates an instance of the default event loop implementation for the current architecture and operating system."]
    pub fn aws_event_loop_new_default(
        alloc: *mut aws_allocator,
        clock: aws_io_clock_fn,
    ) -> *mut aws_event_loop;
    #[doc = " Creates an instance of the default event loop implementation for the current architecture and operating system using\n extendable options."]
    pub fn aws_event_loop_new_default_with_options(
        alloc: *mut aws_allocator,
        options: *const aws_event_loop_options,
    ) -> *mut aws_event_loop;
    #[doc = " Invokes the destroy() fn for the event loop implementation.\n If the event loop is still in a running state, this function will block waiting on the event loop to shutdown.\n If you do not want this function to block, call aws_event_loop_stop() manually first.\n If the event loop is shared by multiple threads then destroy must be called by exactly one thread. All other threads\n must ensure their API calls to the event loop happen-before the call to destroy."]
    pub fn aws_event_loop_destroy(event_loop: *mut aws_event_loop);
    #[doc = " Initializes common event-loop data structures.\n This is only called from the *new() function of event loop implementations."]
    pub fn aws_event_loop_init_base(
        event_loop: *mut aws_event_loop,
        alloc: *mut aws_allocator,
        clock: aws_io_clock_fn,
    ) -> ::core::ffi::c_int;
    #[doc = " Common cleanup code for all implementations.\n This is only called from the *destroy() function of event loop implementations."]
    pub fn aws_event_loop_clean_up_base(event_loop: *mut aws_event_loop);
    #[doc = " Fetches an object from the event-loop's data store. Key will be taken as the memory address of the memory pointed to\n by key. This function is not thread safe and should be called inside the event-loop's thread."]
    pub fn aws_event_loop_fetch_local_object(
        event_loop: *mut aws_event_loop,
        key: *mut ::core::ffi::c_void,
        obj: *mut aws_event_loop_local_object,
    ) -> ::core::ffi::c_int;
    #[doc = " Puts an item object the event-loop's data store. Key will be taken as the memory address of the memory pointed to by\n key. The lifetime of item must live until remove or a put item overrides it. This function is not thread safe and\n should be called inside the event-loop's thread."]
    pub fn aws_event_loop_put_local_object(
        event_loop: *mut aws_event_loop,
        obj: *mut aws_event_loop_local_object,
    ) -> ::core::ffi::c_int;
    #[doc = " Removes an object from the event-loop's data store. Key will be taken as the memory address of the memory pointed to\n by key. If removed_item is not null, the removed item will be moved to it if it exists. Otherwise, the default\n deallocation strategy will be used. This function is not thread safe and should be called inside the event-loop's\n thread."]
    pub fn aws_event_loop_remove_local_object(
        event_loop: *mut aws_event_loop,
        key: *mut ::core::ffi::c_void,
        removed_obj: *mut aws_event_loop_local_object,
    ) -> ::core::ffi::c_int;
    #[doc = " Triggers the running of the event loop. This function must not block. The event loop is not active until this\n function is invoked. This function can be called again on an event loop after calling aws_event_loop_stop() and\n aws_event_loop_wait_for_stop_completion()."]
    pub fn aws_event_loop_run(event_loop: *mut aws_event_loop) -> ::core::ffi::c_int;
    #[doc = " Triggers the event loop to stop, but does not wait for the loop to stop completely.\n This function may be called from outside or inside the event loop thread. It is safe to call multiple times.\n This function is called from destroy().\n\n If you do not call destroy(), an event loop can be run again by calling stop(), wait_for_stop_completion(), run()."]
    pub fn aws_event_loop_stop(event_loop: *mut aws_event_loop) -> ::core::ffi::c_int;
    #[doc = " For event-loop implementations to use for providing metrics info to the base event-loop. This enables the\n event-loop load balancer to take into account load when vending another event-loop to a caller.\n\n Call this function at the beginning of your event-loop tick: after wake-up, but before processing any IO or tasks."]
    pub fn aws_event_loop_register_tick_start(event_loop: *mut aws_event_loop);
    #[doc = " For event-loop implementations to use for providing metrics info to the base event-loop. This enables the\n event-loop load balancer to take into account load when vending another event-loop to a caller.\n\n Call this function at the end of your event-loop tick: after processing IO and tasks."]
    pub fn aws_event_loop_register_tick_end(event_loop: *mut aws_event_loop);
    #[doc = " Returns the current load factor (however that may be calculated). If the event-loop is not invoking\n aws_event_loop_register_tick_start() and aws_event_loop_register_tick_end(), this value will always be 0."]
    pub fn aws_event_loop_get_load_factor(event_loop: *mut aws_event_loop) -> usize;
    #[doc = " Blocks until the event loop stops completely.\n If you want to call aws_event_loop_run() again, you must call this after aws_event_loop_stop().\n It is not safe to call this function from inside the event loop thread."]
    pub fn aws_event_loop_wait_for_stop_completion(
        event_loop: *mut aws_event_loop,
    ) -> ::core::ffi::c_int;
    #[doc = " The event loop will schedule the task and run it on the event loop thread as soon as possible.\n Note that cancelled tasks may execute outside the event loop thread.\n This function may be called from outside or inside the event loop thread.\n\n The task should not be cleaned up or modified until its function is executed."]
    pub fn aws_event_loop_schedule_task_now(event_loop: *mut aws_event_loop, task: *mut aws_task);
    #[doc = " The event loop will schedule the task and run it at the specified time.\n Use aws_event_loop_current_clock_time() to query the current time in nanoseconds.\n Note that cancelled tasks may execute outside the event loop thread.\n This function may be called from outside or inside the event loop thread.\n\n The task should not be cleaned up or modified until its function is executed."]
    pub fn aws_event_loop_schedule_task_future(
        event_loop: *mut aws_event_loop,
        task: *mut aws_task,
        run_at_nanos: u64,
    );
    #[doc = " Cancels task.\n This function must be called from the event loop's thread, and is only guaranteed\n to work properly on tasks scheduled from within the event loop's thread.\n The task will be executed with the AWS_TASK_STATUS_CANCELED status inside this call."]
    pub fn aws_event_loop_cancel_task(event_loop: *mut aws_event_loop, task: *mut aws_task);
    #[doc = " Subscribes on_event to events on the event-loop for handle. events is a bitwise concatenation of the events that were\n received. The definition for these values can be found in aws_io_event_type. Currently, only\n AWS_IO_EVENT_TYPE_READABLE and AWS_IO_EVENT_TYPE_WRITABLE are honored. You always are registered for error conditions\n and closure. This function may be called from outside or inside the event loop thread. However, the unsubscribe\n function must be called inside the event-loop's thread."]
    pub fn aws_event_loop_subscribe_to_io_events(
        event_loop: *mut aws_event_loop,
        handle: *mut aws_io_handle,
        events: ::core::ffi::c_int,
        on_event: aws_event_loop_on_event_fn,
        user_data: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    #[doc = " Unsubscribes handle from event-loop notifications.\n This function is not thread safe and should be called inside the event-loop's thread.\n\n NOTE: if you are using io completion ports, this is a risky call. We use it in places, but only when we're certain\n there's no pending events. If you want to use it, it's your job to make sure you don't have pending events before\n calling it."]
    pub fn aws_event_loop_unsubscribe_from_io_events(
        event_loop: *mut aws_event_loop,
        handle: *mut aws_io_handle,
    ) -> ::core::ffi::c_int;
    #[doc = " Cleans up resources (user_data) associated with the I/O eventing subsystem for a given handle. This should only\n ever be necessary in the case where you are cleaning up an event loop during shutdown and its thread has already\n been joined."]
    pub fn aws_event_loop_free_io_event_resources(
        event_loop: *mut aws_event_loop,
        handle: *mut aws_io_handle,
    );
    #[doc = " Returns true if the event loop's thread is the same thread that called this function, otherwise false."]
    pub fn aws_event_loop_thread_is_callers_thread(event_loop: *mut aws_event_loop) -> bool;
    #[doc = " Gets the current timestamp for the event loop's clock, in nanoseconds. This function is thread-safe."]
    pub fn aws_event_loop_current_clock_time(
        event_loop: *mut aws_event_loop,
        time_nanos: *mut u64,
    ) -> ::core::ffi::c_int;
    #[doc = " Creates an event loop group, with clock, number of loops to manage, and the function to call for creating a new\n event loop."]
    pub fn aws_event_loop_group_new(
        alloc: *mut aws_allocator,
        clock: aws_io_clock_fn,
        el_count: u16,
        new_loop_fn: aws_new_event_loop_fn,
        new_loop_user_data: *mut ::core::ffi::c_void,
        shutdown_options: *const aws_shutdown_callback_options,
    ) -> *mut aws_event_loop_group;
    #[doc = " Creates an event loop group, with clock, number of loops to manage, the function to call for creating a new\n event loop, and also pins all loops to hw threads on the same cpu_group (e.g. NUMA nodes). Note:\n If el_count exceeds the number of hw threads in the cpu_group it will be ignored on the assumption that if you\n care about NUMA, you don't want hyper-threads doing your IO and you especially don't want IO on a different node."]
    pub fn aws_event_loop_group_new_pinned_to_cpu_group(
        alloc: *mut aws_allocator,
        clock: aws_io_clock_fn,
        el_count: u16,
        cpu_group: u16,
        new_loop_fn: aws_new_event_loop_fn,
        new_loop_user_data: *mut ::core::ffi::c_void,
        shutdown_options: *const aws_shutdown_callback_options,
    ) -> *mut aws_event_loop_group;
    #[doc = " Initializes an event loop group with platform defaults. If max_threads == 0, then the\n loop count will be the number of available processors on the machine / 2 (to exclude hyper-threads).\n Otherwise, max_threads will be the number of event loops in the group."]
    pub fn aws_event_loop_group_new_default(
        alloc: *mut aws_allocator,
        max_threads: u16,
        shutdown_options: *const aws_shutdown_callback_options,
    ) -> *mut aws_event_loop_group;
    #[doc = " Creates an event loop group, with clock, number of loops to manage, the function to call for creating a new\n event loop, and also pins all loops to hw threads on the same cpu_group (e.g. NUMA nodes). Note:\n If el_count exceeds the number of hw threads in the cpu_group it will be clamped to the number of hw threads\n on the assumption that if you care about NUMA, you don't want hyper-threads doing your IO and you especially\n don't want IO on a different node.\n\n If max_threads == 0, then the\n loop count will be the number of available processors in the cpu_group / 2 (to exclude hyper-threads)"]
    pub fn aws_event_loop_group_new_default_pinned_to_cpu_group(
        alloc: *mut aws_allocator,
        max_threads: u16,
        cpu_group: u16,
        shutdown_options: *const aws_shutdown_callback_options,
    ) -> *mut aws_event_loop_group;
    #[doc = " Increments the reference count on the event loop group, allowing the caller to take a reference to it.\n\n Returns the same event loop group passed in."]
    pub fn aws_event_loop_group_acquire(
        el_group: *mut aws_event_loop_group,
    ) -> *mut aws_event_loop_group;
    #[doc = " Decrements an event loop group's ref count.  When the ref count drops to zero, the event loop group will be\n destroyed."]
    pub fn aws_event_loop_group_release(el_group: *mut aws_event_loop_group);
    pub fn aws_event_loop_group_get_loop_at(
        el_group: *mut aws_event_loop_group,
        index: usize,
    ) -> *mut aws_event_loop;
    pub fn aws_event_loop_group_get_loop_count(el_group: *mut aws_event_loop_group) -> usize;
    #[doc = " Fetches the next loop for use. The purpose is to enable load balancing across loops. You should not depend on how\n this load balancing is done as it is subject to change in the future. Currently it uses the \"best-of-two\" algorithm\n based on the load factor of each loop."]
    pub fn aws_event_loop_group_get_next_loop(
        el_group: *mut aws_event_loop_group,
    ) -> *mut aws_event_loop;
    pub fn aws_future_impl_new_by_value(
        alloc: *mut aws_allocator,
        sizeof_result: usize,
    ) -> *mut aws_future_impl;
    pub fn aws_future_impl_new_by_value_with_clean_up(
        alloc: *mut aws_allocator,
        sizeof_result: usize,
        result_clean_up: aws_future_impl_result_clean_up_fn,
    ) -> *mut aws_future_impl;
    pub fn aws_future_impl_new_pointer(alloc: *mut aws_allocator) -> *mut aws_future_impl;
    pub fn aws_future_impl_new_pointer_with_destroy(
        alloc: *mut aws_allocator,
        result_destroy: aws_future_impl_result_destroy_fn,
    ) -> *mut aws_future_impl;
    pub fn aws_future_impl_new_pointer_with_release(
        alloc: *mut aws_allocator,
        result_release: aws_future_impl_result_release_fn,
    ) -> *mut aws_future_impl;
    pub fn aws_future_impl_release(promise: *mut aws_future_impl) -> *mut aws_future_impl;
    pub fn aws_future_impl_acquire(promise: *mut aws_future_impl) -> *mut aws_future_impl;
    pub fn aws_future_impl_set_error(promise: *mut aws_future_impl, error_code: ::core::ffi::c_int);
    pub fn aws_future_impl_set_result_by_move(
        promise: *mut aws_future_impl,
        src_address: *mut ::core::ffi::c_void,
    );
    pub fn aws_future_impl_is_done(future: *const aws_future_impl) -> bool;
    pub fn aws_future_impl_register_callback(
        future: *mut aws_future_impl,
        on_done: aws_future_callback_fn,
        user_data: *mut ::core::ffi::c_void,
    );
    pub fn aws_future_impl_register_callback_if_not_done(
        future: *mut aws_future_impl,
        on_done: aws_future_callback_fn,
        user_data: *mut ::core::ffi::c_void,
    ) -> bool;
    pub fn aws_future_impl_register_event_loop_callback(
        future: *mut aws_future_impl,
        event_loop: *mut aws_event_loop,
        on_done: aws_future_callback_fn,
        user_data: *mut ::core::ffi::c_void,
    );
    pub fn aws_future_impl_register_channel_callback(
        future: *mut aws_future_impl,
        channel: *mut aws_channel,
        on_done: aws_future_callback_fn,
        user_data: *mut ::core::ffi::c_void,
    );
    pub fn aws_future_impl_wait(future: *const aws_future_impl, timeout_ns: u64) -> bool;
    pub fn aws_future_impl_get_error(future: *const aws_future_impl) -> ::core::ffi::c_int;
    pub fn aws_future_impl_get_result_address(
        future: *const aws_future_impl,
    ) -> *mut ::core::ffi::c_void;
    pub fn aws_future_impl_get_result_by_move(
        future: *mut aws_future_impl,
        dst_address: *mut ::core::ffi::c_void,
    );
    pub fn aws_future_size_new(alloc: *mut aws_allocator) -> *mut aws_future_size;
    pub fn aws_future_size_set_result(future: *mut aws_future_size, result: usize);
    pub fn aws_future_size_get_result(future: *const aws_future_size) -> usize;
    pub fn aws_future_size_acquire(future: *mut aws_future_size) -> *mut aws_future_size;
    pub fn aws_future_size_release(future: *mut aws_future_size) -> *mut aws_future_size;
    pub fn aws_future_size_set_error(future: *mut aws_future_size, error_code: ::core::ffi::c_int);
    pub fn aws_future_size_is_done(future: *const aws_future_size) -> bool;
    pub fn aws_future_size_get_error(future: *const aws_future_size) -> ::core::ffi::c_int;
    pub fn aws_future_size_register_callback(
        future: *mut aws_future_size,
        on_done: aws_future_callback_fn,
        user_data: *mut ::core::ffi::c_void,
    );
    pub fn aws_future_size_register_callback_if_not_done(
        future: *mut aws_future_size,
        on_done: aws_future_callback_fn,
        user_data: *mut ::core::ffi::c_void,
    ) -> bool;
    pub fn aws_future_size_register_event_loop_callback(
        future: *mut aws_future_size,
        event_loop: *mut aws_event_loop,
        on_done: aws_future_callback_fn,
        user_data: *mut ::core::ffi::c_void,
    );
    pub fn aws_future_size_register_channel_callback(
        future: *mut aws_future_size,
        channel: *mut aws_channel,
        on_done: aws_future_callback_fn,
        user_data: *mut ::core::ffi::c_void,
    );
    pub fn aws_future_size_wait(future: *mut aws_future_size, timeout_ns: u64) -> bool;
    pub fn aws_future_bool_new(alloc: *mut aws_allocator) -> *mut aws_future_bool;
    pub fn aws_future_bool_set_result(future: *mut aws_future_bool, result: bool);
    pub fn aws_future_bool_get_result(future: *const aws_future_bool) -> bool;
    pub fn aws_future_bool_acquire(future: *mut aws_future_bool) -> *mut aws_future_bool;
    pub fn aws_future_bool_release(future: *mut aws_future_bool) -> *mut aws_future_bool;
    pub fn aws_future_bool_set_error(future: *mut aws_future_bool, error_code: ::core::ffi::c_int);
    pub fn aws_future_bool_is_done(future: *const aws_future_bool) -> bool;
    pub fn aws_future_bool_get_error(future: *const aws_future_bool) -> ::core::ffi::c_int;
    pub fn aws_future_bool_register_callback(
        future: *mut aws_future_bool,
        on_done: aws_future_callback_fn,
        user_data: *mut ::core::ffi::c_void,
    );
    pub fn aws_future_bool_register_callback_if_not_done(
        future: *mut aws_future_bool,
        on_done: aws_future_callback_fn,
        user_data: *mut ::core::ffi::c_void,
    ) -> bool;
    pub fn aws_future_bool_register_event_loop_callback(
        future: *mut aws_future_bool,
        event_loop: *mut aws_event_loop,
        on_done: aws_future_callback_fn,
        user_data: *mut ::core::ffi::c_void,
    );
    pub fn aws_future_bool_register_channel_callback(
        future: *mut aws_future_bool,
        channel: *mut aws_channel,
        on_done: aws_future_callback_fn,
        user_data: *mut ::core::ffi::c_void,
    );
    pub fn aws_future_bool_wait(future: *mut aws_future_bool, timeout_ns: u64) -> bool;
    #[doc = " aws_future<void>"]
    pub fn aws_future_void_new(alloc: *mut aws_allocator) -> *mut aws_future_void;
    pub fn aws_future_void_set_result(future: *mut aws_future_void);
    pub fn aws_future_void_acquire(future: *mut aws_future_void) -> *mut aws_future_void;
    pub fn aws_future_void_release(future: *mut aws_future_void) -> *mut aws_future_void;
    pub fn aws_future_void_set_error(future: *mut aws_future_void, error_code: ::core::ffi::c_int);
    pub fn aws_future_void_is_done(future: *const aws_future_void) -> bool;
    pub fn aws_future_void_get_error(future: *const aws_future_void) -> ::core::ffi::c_int;
    pub fn aws_future_void_register_callback(
        future: *mut aws_future_void,
        on_done: aws_future_callback_fn,
        user_data: *mut ::core::ffi::c_void,
    );
    pub fn aws_future_void_register_callback_if_not_done(
        future: *mut aws_future_void,
        on_done: aws_future_callback_fn,
        user_data: *mut ::core::ffi::c_void,
    ) -> bool;
    pub fn aws_future_void_register_event_loop_callback(
        future: *mut aws_future_void,
        event_loop: *mut aws_event_loop,
        on_done: aws_future_callback_fn,
        user_data: *mut ::core::ffi::c_void,
    );
    pub fn aws_future_void_register_channel_callback(
        future: *mut aws_future_void,
        channel: *mut aws_channel,
        on_done: aws_future_callback_fn,
        user_data: *mut ::core::ffi::c_void,
    );
    pub fn aws_future_void_wait(future: *mut aws_future_void, timeout_ns: u64) -> bool;
    pub fn aws_memory_pool_init(
        mempool: *mut aws_memory_pool,
        alloc: *mut aws_allocator,
        ideal_segment_count: u16,
        segment_size: usize,
    ) -> ::core::ffi::c_int;
    pub fn aws_memory_pool_clean_up(mempool: *mut aws_memory_pool);
    #[doc = " Acquires memory from the pool if available, otherwise, it attempts to allocate and returns the result."]
    pub fn aws_memory_pool_acquire(mempool: *mut aws_memory_pool) -> *mut ::core::ffi::c_void;
    #[doc = " Releases memory to the pool if space is available, otherwise frees `to_release`"]
    pub fn aws_memory_pool_release(
        mempool: *mut aws_memory_pool,
        to_release: *mut ::core::ffi::c_void,
    );
    #[doc = " Initializes message pool using 'msg_pool' as the backing pool, 'args' is copied."]
    pub fn aws_message_pool_init(
        msg_pool: *mut aws_message_pool,
        alloc: *mut aws_allocator,
        args: *mut aws_message_pool_creation_args,
    ) -> ::core::ffi::c_int;
    pub fn aws_message_pool_clean_up(msg_pool: *mut aws_message_pool);
    #[doc = " Acquires a message from the pool if available, otherwise, it attempts to allocate. If a message is acquired,\n note that size_hint is just a hint. the return value's capacity will be set to the actual buffer size."]
    pub fn aws_message_pool_acquire(
        msg_pool: *mut aws_message_pool,
        message_type: aws_io_message_type,
        size_hint: usize,
    ) -> *mut aws_io_message;
    #[doc = " Releases message to the pool if space is available, otherwise frees `message`\n @param message"]
    pub fn aws_message_pool_release(msg_pool: *mut aws_message_pool, message: *mut aws_io_message);
    #[doc = " Cleans up elements of pem_objects list 'aws_pem_objects_init_from_file_contents()'\n and 'aws_pem_objects_init_from_file_path()'."]
    pub fn aws_pem_objects_clean_up(pem_objects: *mut aws_array_list);
    #[doc = " Decodes PEM data and reads objects sequentially adding them to pem_objects.\n If it comes across an object it cannot read, list of all object read until\n that point is returned.\n If no objects can be read from PEM or objects could not be base 64 decoded,\n AWS_ERROR_PEM_MALFORMED is raised.\n out_pem_objects stores aws_pem_object struct by value.\n Function will initialize pem_objects list.\n This code is slow, and it allocates, so please try\n not to call this in the middle of something that needs to be fast or resource sensitive."]
    pub fn aws_pem_objects_init_from_file_contents(
        pem_objects: *mut aws_array_list,
        alloc: *mut aws_allocator,
        pem_cursor: aws_byte_cursor,
    ) -> ::core::ffi::c_int;
    #[doc = " Decodes PEM data from file and reads objects sequentially adding them to pem_objects.\n If it comes across an object it cannot read, list of all object read until\n that point is returned.\n If no objects can be read from PEM or objects could not be base 64 decoded,\n AWS_ERROR_PEM_MALFORMED is raised.\n out_pem_objects stores aws_pem_object struct by value.\n Function will initialize pem_objects list.\n This code is slow, and it allocates, so please try\n not to call this in the middle of something that needs to be fast or resource sensitive."]
    pub fn aws_pem_objects_init_from_file_path(
        pem_objects: *mut aws_array_list,
        allocator: *mut aws_allocator,
        filename: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    #[doc = " Opens an OS specific bidirectional pipe.\n The read direction is stored in read_end. Write direction is stored in write_end.\n Each end must be connected to an event-loop, and further calls to each end must happen on that event-loop's thread."]
    pub fn aws_pipe_init(
        read_end: *mut aws_pipe_read_end,
        read_end_event_loop: *mut aws_event_loop,
        write_end: *mut aws_pipe_write_end,
        write_end_event_loop: *mut aws_event_loop,
        allocator: *mut aws_allocator,
    ) -> ::core::ffi::c_int;
    #[doc = " Clean up the read-end of the pipe.\n This must be called on the thread of the connected event-loop."]
    pub fn aws_pipe_clean_up_read_end(read_end: *mut aws_pipe_read_end) -> ::core::ffi::c_int;
    #[doc = " Clean up the write-end of the pipe.\n This must be called on the thread of the connected event-loop."]
    pub fn aws_pipe_clean_up_write_end(write_end: *mut aws_pipe_write_end) -> ::core::ffi::c_int;
    #[doc = " Get the event-loop connected to the read-end of the pipe.\n This may be called on any thread."]
    pub fn aws_pipe_get_read_end_event_loop(
        read_end: *const aws_pipe_read_end,
    ) -> *mut aws_event_loop;
    #[doc = " Get the event-loop connected to the write-end of the pipe.\n This may be called on any thread."]
    pub fn aws_pipe_get_write_end_event_loop(
        write_end: *const aws_pipe_write_end,
    ) -> *mut aws_event_loop;
    #[doc = " Initiates an asynchrous write from the source buffer to the pipe.\n The data referenced by `src_buffer` must remain in memory until the operation completes.\n `on_complete` is called on the event-loop thread when the operation has either completed or failed.\n The callback's pipe argument will be NULL if the callback is invoked after the pipe has been cleaned up.\n This must be called on the thread of the connected event-loop."]
    pub fn aws_pipe_write(
        write_end: *mut aws_pipe_write_end,
        src_buffer: aws_byte_cursor,
        on_completed: aws_pipe_on_write_completed_fn,
        user_data: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    #[doc = " Read data from the pipe into the destination buffer.\n Attempts to read enough to fill all remaining space in the buffer, from `dst_buffer->len` to `dst_buffer->capacity`.\n `dst_buffer->len` is updated to reflect the buffer's new length.\n `num_bytes_read` (optional) is set to the total number of bytes read.\n This function never blocks. If no bytes could be read without blocking, then AWS_OP_ERR is returned and\n aws_last_error() code will be AWS_IO_READ_WOULD_BLOCK.\n This must be called on the thread of the connected event-loop."]
    pub fn aws_pipe_read(
        read_end: *mut aws_pipe_read_end,
        dst_buffer: *mut aws_byte_buf,
        num_bytes_read: *mut usize,
    ) -> ::core::ffi::c_int;
    #[doc = " Subscribe to be notified when the pipe becomes readable (edge-triggered), or an error occurs.\n `on_readable` is invoked on the event-loop's thread when the pipe has data to read, or the pipe has an error.\n `on_readable` is invoked again any time the user reads all data, and then more data arrives.\n Note that it will not be invoked again if the pipe still has unread data when more data arrives.\n This must be called on the thread of the connected event-loop."]
    pub fn aws_pipe_subscribe_to_readable_events(
        read_end: *mut aws_pipe_read_end,
        on_readable: aws_pipe_on_readable_fn,
        user_data: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    #[doc = " Stop receiving notifications about events on the read-end of the pipe.\n This must be called on the thread of the connected event-loop."]
    pub fn aws_pipe_unsubscribe_from_readable_events(
        read_end: *mut aws_pipe_read_end,
    ) -> ::core::ffi::c_int;
    #[doc = " Generate a unique pipe name.\n The suggested dst_size is 256."]
    pub fn aws_pipe_get_unique_name(
        dst: *mut ::core::ffi::c_char,
        dst_size: usize,
    ) -> ::core::ffi::c_int;
    #[doc = " Load and initialize a PKCS#11 library.\n See `aws_pkcs11_lib_options` for options.\n\n If successful a valid pointer is returned. You must call aws_pkcs11_lib_release() when you are done with it.\n If unsuccessful, NULL is returned and an error is set."]
    pub fn aws_pkcs11_lib_new(
        allocator: *mut aws_allocator,
        options: *const aws_pkcs11_lib_options,
    ) -> *mut aws_pkcs11_lib;
    #[doc = " Acquire a reference to a PKCS#11 library, preventing it from being cleaned up.\n You must call aws_pkcs11_lib_release() when you are done with it.\n This function returns whatever was passed in. It cannot fail."]
    pub fn aws_pkcs11_lib_acquire(pkcs11_lib: *mut aws_pkcs11_lib) -> *mut aws_pkcs11_lib;
    #[doc = " Release a reference to the PKCS#11 library.\n When the last reference is released, the library is cleaned up."]
    pub fn aws_pkcs11_lib_release(pkcs11_lib: *mut aws_pkcs11_lib);
    #[doc = " Acquire a reference count on retry_strategy."]
    pub fn aws_retry_strategy_acquire(retry_strategy: *mut aws_retry_strategy);
    #[doc = " Releases a reference count on retry_strategy."]
    pub fn aws_retry_strategy_release(retry_strategy: *mut aws_retry_strategy);
    #[doc = " Attempts to acquire a retry token for use with retries. On success, on_acquired will be invoked when a token is\n available, or an error will be returned if the timeout expires. partition_id identifies operations that should be\n grouped together. This allows for more sophisticated strategies such as AIMD and circuit breaker patterns. Pass NULL\n to use the global partition."]
    pub fn aws_retry_strategy_acquire_retry_token(
        retry_strategy: *mut aws_retry_strategy,
        partition_id: *const aws_byte_cursor,
        on_acquired: aws_retry_strategy_on_retry_token_acquired_fn,
        user_data: *mut ::core::ffi::c_void,
        timeout_ms: u64,
    ) -> ::core::ffi::c_int;
    #[doc = " Schedules a retry based on the backoff and token based strategies. retry_ready is invoked when the retry is either\n ready for execution or if it has been canceled due to application shutdown.\n\n This function can return an error to reject the retry attempt if, for example, a circuit breaker has opened. If this\n occurs users should fail their calls back to their callers.\n\n error_type is used for book keeping. See the comments above for aws_retry_error_type."]
    pub fn aws_retry_strategy_schedule_retry(
        token: *mut aws_retry_token,
        error_type: aws_retry_error_type,
        retry_ready: aws_retry_strategy_on_retry_ready_fn,
        user_data: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    #[doc = " Records a successful retry. This is used for making future decisions to open up token buckets, AIMD breakers etc...\n some strategies such as exponential backoff will ignore this, but you should always call it after a successful\n operation or your system will never recover during an outage."]
    pub fn aws_retry_token_record_success(token: *mut aws_retry_token) -> ::core::ffi::c_int;
    #[doc = " Increments reference count for token. This should be called any time you seat the token to a pointer you own."]
    pub fn aws_retry_token_acquire(token: *mut aws_retry_token);
    #[doc = " Releases the reference count for token. This should always be invoked after either calling\n aws_retry_strategy_schedule_retry() and failing, or after calling aws_retry_token_record_success()."]
    pub fn aws_retry_token_release(token: *mut aws_retry_token);
    #[doc = " Creates a retry strategy using exponential backoff. This strategy does not perform any bookkeeping on error types and\n success. There is no circuit breaker functionality in here. See the comments above for\n aws_exponential_backoff_retry_options."]
    pub fn aws_retry_strategy_new_exponential_backoff(
        allocator: *mut aws_allocator,
        config: *const aws_exponential_backoff_retry_options,
    ) -> *mut aws_retry_strategy;
    #[doc = " This is a retry implementation that cuts off traffic if it's\n detected that an endpoint partition is having availability\n problems. This is necessary to keep from making outages worse\n by scheduling work that's unlikely to succeed yet increases\n load on an already ailing system.\n\n We do this by creating a bucket for each partition. A partition\n is an arbitrary specifier. It can be anything: a region, a service,\n a combination of region and service, a literal dns name.... doesn't matter.\n\n Each bucket has a budget for maximum allowed retries. Different types of events\n carry different weights. Things that indicate an unhealthy partition such as\n transient errors (timeouts, unhealthy connection etc...) cost more.\n A retry for any other reason (service sending a 5xx response code) cost a bit less.\n When a retry is attempted this capacity is leased out to the retry. On success it is\n released back to the capacity pool. On failure, it remains leased.\n Operations that succeed without a retry slowly restore the capacity pool.\n\n If a partition runs out of capacity it is assumed unhealthy and retries will be blocked\n until capacity returns to the pool. To prevent a partition from staying unhealthy after\n an outage has recovered, new requests that succeed without a retry will increase the capacity\n slowly ( a new request gets a payback lease of 1, but the lease is never actually deducted from the capacity pool)."]
    pub fn aws_retry_strategy_new_standard(
        allocator: *mut aws_allocator,
        config: *const aws_standard_retry_options,
    ) -> *mut aws_retry_strategy;
    pub fn aws_shared_library_init(
        library: *mut aws_shared_library,
        library_path: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    pub fn aws_shared_library_clean_up(library: *mut aws_shared_library);
    pub fn aws_shared_library_find_function(
        library: *mut aws_shared_library,
        symbol_name: *const ::core::ffi::c_char,
        function_address: *mut aws_generic_function,
    ) -> ::core::ffi::c_int;
    #[doc = " Initializes a socket object with socket options. options will be copied."]
    pub fn aws_socket_init(
        socket: *mut aws_socket,
        alloc: *mut aws_allocator,
        options: *const aws_socket_options,
    ) -> ::core::ffi::c_int;
    #[doc = " Shuts down any pending operations on the socket, and cleans up state. The socket object can be re-initialized after\n this operation. This function calls aws_socket_close. If you have not already called aws_socket_close() on the\n socket, all of the rules for aws_socket_close() apply here. In this case it will not fail if you use the function\n improperly, but on some platforms you will certainly leak memory.\n\n If the socket has already been closed, you can safely, call this from any thread."]
    pub fn aws_socket_clean_up(socket: *mut aws_socket);
    #[doc = " Connects to a remote endpoint. In UDP, this simply binds the socket to a remote address for use with\n `aws_socket_write()`, and if the operation is successful, the socket can immediately be used for write operations.\n\n In TCP, LOCAL and VSOCK this function will not block. If the return value is successful, then you must wait on the\n `on_connection_result()` callback to be invoked before using the socket.\n\n If an event_loop is provided for UDP sockets, a notification will be sent on\n on_connection_result in the event-loop's thread. Upon completion, the socket will already be assigned\n an event loop. If NULL is passed for UDP, it will immediately return upon success, but you must call\n aws_socket_assign_to_event_loop before use."]
    pub fn aws_socket_connect(
        socket: *mut aws_socket,
        remote_endpoint: *const aws_socket_endpoint,
        event_loop: *mut aws_event_loop,
        on_connection_result: aws_socket_on_connection_result_fn,
        user_data: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    #[doc = " Binds the socket to a local address. In UDP mode, the socket is ready for `aws_socket_read()` operations. In\n connection oriented modes, you still must call `aws_socket_listen()` and `aws_socket_start_accept()` before using the\n socket. local_endpoint is copied."]
    pub fn aws_socket_bind(
        socket: *mut aws_socket,
        local_endpoint: *const aws_socket_endpoint,
    ) -> ::core::ffi::c_int;
    #[doc = " Get the local address which the socket is bound to.\n Raises an error if no address is bound."]
    pub fn aws_socket_get_bound_address(
        socket: *const aws_socket,
        out_address: *mut aws_socket_endpoint,
    ) -> ::core::ffi::c_int;
    #[doc = " TCP, LOCAL and VSOCK only. Sets up the socket to listen on the address bound to in `aws_socket_bind()`."]
    pub fn aws_socket_listen(
        socket: *mut aws_socket,
        backlog_size: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    #[doc = " TCP, LOCAL and VSOCK only. The socket will begin accepting new connections. This is an asynchronous operation. New\n connections or errors will arrive via the `on_accept_result` callback.\n\n aws_socket_bind() and aws_socket_listen() must be called before calling this function."]
    pub fn aws_socket_start_accept(
        socket: *mut aws_socket,
        accept_loop: *mut aws_event_loop,
        on_accept_result: aws_socket_on_accept_result_fn,
        user_data: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    #[doc = " TCP, LOCAL and VSOCK only. The listening socket will stop accepting new connections.\n It is safe to call `aws_socket_start_accept()` again after\n this operation. This can be called from any thread but be aware,\n on some platforms, if you call this from outside of the current event loop's thread, it will block\n until the event loop finishes processing the request for unsubscribe in it's own thread."]
    pub fn aws_socket_stop_accept(socket: *mut aws_socket) -> ::core::ffi::c_int;
    #[doc = " Calls `close()` on the socket and unregisters all io operations from the event loop. This function must be called\n from the event-loop's thread unless this is a listening socket. If it's a listening socket it can be called from any\n non-event-loop thread or the event-loop the socket is currently assigned to. If called from outside the event-loop,\n this function will block waiting on the socket to close. If this is called from an event-loop thread other than\n the one it's assigned to, it presents the possibility of a deadlock, so don't do it."]
    pub fn aws_socket_close(socket: *mut aws_socket) -> ::core::ffi::c_int;
    #[doc = " Calls `shutdown()` on the socket based on direction."]
    pub fn aws_socket_shutdown_dir(
        socket: *mut aws_socket,
        dir: aws_channel_direction,
    ) -> ::core::ffi::c_int;
    #[doc = " Sets new socket options on the underlying socket. This is mainly useful in context of accepting a new connection via:\n `on_incoming_connection()`. options is copied."]
    pub fn aws_socket_set_options(
        socket: *mut aws_socket,
        options: *const aws_socket_options,
    ) -> ::core::ffi::c_int;
    #[doc = " Assigns the socket to the event-loop. The socket will begin receiving read/write/error notifications after this call.\n\n Note: If you called connect for TCP or Unix Domain Sockets and received a connection_success callback, this has\n already happened. You only need to call this function when:\n\n a.) This socket is a server socket (e.g. a result of a call to start_accept())\n b.) This socket is a UDP socket."]
    pub fn aws_socket_assign_to_event_loop(
        socket: *mut aws_socket,
        event_loop: *mut aws_event_loop,
    ) -> ::core::ffi::c_int;
    #[doc = " Gets the event-loop the socket is assigned to."]
    pub fn aws_socket_get_event_loop(socket: *mut aws_socket) -> *mut aws_event_loop;
    #[doc = " Subscribes on_readable to notifications when the socket goes readable (edge-triggered). Errors will also be recieved\n in the callback.\n\n Note! This function is technically not thread safe, but we do not enforce which thread you call from.\n It's your responsibility to either call this in safely (e.g. just don't call it in parallel from multiple threads) or\n schedule a task to call it. If you call it before your first call to read, it will be fine."]
    pub fn aws_socket_subscribe_to_readable_events(
        socket: *mut aws_socket,
        on_readable: aws_socket_on_readable_fn,
        user_data: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    #[doc = " Reads from the socket. This call is non-blocking and will return `AWS_IO_SOCKET_READ_WOULD_BLOCK` if no data is\n available. `read` is the amount of data read into `buffer`.\n\n Attempts to read enough to fill all remaining space in the buffer, from `buffer->len` to `buffer->capacity`.\n `buffer->len` is updated to reflect the buffer's new length.\n\n\n Use aws_socket_subscribe_to_readable_events() to receive notifications of when the socket goes readable.\n\n NOTE! This function must be called from the event-loop used in aws_socket_assign_to_event_loop"]
    pub fn aws_socket_read(
        socket: *mut aws_socket,
        buffer: *mut aws_byte_buf,
        amount_read: *mut usize,
    ) -> ::core::ffi::c_int;
    #[doc = " Writes to the socket. This call is non-blocking and will attempt to write as much as it can, but will queue any\n remaining portion of the data for write when available. written_fn will be invoked once the entire cursor has been\n written, or the write failed or was cancelled.\n\n NOTE! This function must be called from the event-loop used in aws_socket_assign_to_event_loop\n\n For client sockets, connect() and aws_socket_assign_to_event_loop() must be called before calling this.\n\n For incoming sockets from a listener, aws_socket_assign_to_event_loop() must be called first."]
    pub fn aws_socket_write(
        socket: *mut aws_socket,
        cursor: *const aws_byte_cursor,
        written_fn: aws_socket_on_write_completed_fn,
        user_data: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    #[doc = " Gets the latest error from the socket. If no error has occurred AWS_OP_SUCCESS will be returned. This function does\n not raise any errors to the installed error handlers."]
    pub fn aws_socket_get_error(socket: *mut aws_socket) -> ::core::ffi::c_int;
    #[doc = " Returns true if the socket is still open (doesn't mean connected or listening, only that it hasn't had close()\n called."]
    pub fn aws_socket_is_open(socket: *mut aws_socket) -> bool;
    #[doc = " Raises AWS_IO_SOCKET_INVALID_ADDRESS and logs an error if connecting to this port is illegal.\n For example, port must be in range 1-65535 to connect with IPv4.\n These port values would fail eventually in aws_socket_connect(),\n but you can use this function to validate earlier."]
    pub fn aws_socket_validate_port_for_connect(
        port: u32,
        domain: aws_socket_domain,
    ) -> ::core::ffi::c_int;
    #[doc = " Raises AWS_IO_SOCKET_INVALID_ADDRESS and logs an error if binding to this port is illegal.\n For example, port must in range 0-65535 to bind with IPv4.\n These port values would fail eventually in aws_socket_bind(),\n but you can use this function to validate earlier."]
    pub fn aws_socket_validate_port_for_bind(
        port: u32,
        domain: aws_socket_domain,
    ) -> ::core::ffi::c_int;
    #[doc = " Assigns a random address (UUID) for use with AWS_SOCKET_LOCAL (Unix Domain Sockets).\n For use in internal tests only."]
    pub fn aws_socket_endpoint_init_local_address_for_test(endpoint: *mut aws_socket_endpoint);
    #[doc = " Socket handlers should be the first slot/handler in a channel. It interacts directly with the channel's event loop\n for read and write notifications. max_read_size is the maximum amount of data it will read from the socket\n before a context switch (a continuation task will be scheduled)."]
    pub fn aws_socket_handler_new(
        allocator: *mut aws_allocator,
        socket: *mut aws_socket,
        slot: *mut aws_channel_slot,
        max_read_size: usize,
    ) -> *mut aws_channel_handler;
    pub fn aws_socket_handler_get_socket(handler: *const aws_channel_handler) -> *const aws_socket;
    #[doc = " tls options init stuff ***********************/\n/**\n Initializes options with default client options"]
    pub fn aws_tls_ctx_options_init_default_client(
        options: *mut aws_tls_ctx_options,
        allocator: *mut aws_allocator,
    );
    #[doc = " Cleans up resources allocated by init_* functions"]
    pub fn aws_tls_ctx_options_clean_up(options: *mut aws_tls_ctx_options);
    #[doc = " Initializes options for use with mutual tls in client mode.\n cert_path and pkey_path are paths to files on disk. cert_path\n and pkey_path are treated as PKCS#7 PEM armored. They are loaded\n from disk and stored in buffers internally.\n\n NOTE: This is unsupported on iOS."]
    pub fn aws_tls_ctx_options_init_client_mtls_from_path(
        options: *mut aws_tls_ctx_options,
        allocator: *mut aws_allocator,
        cert_path: *const ::core::ffi::c_char,
        pkey_path: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    #[doc = " Initializes options for use with mutual tls in client mode.\n cert and pkey are copied. cert and pkey are treated as PKCS#7 PEM\n armored.\n\n NOTE: This is unsupported on iOS."]
    pub fn aws_tls_ctx_options_init_client_mtls(
        options: *mut aws_tls_ctx_options,
        allocator: *mut aws_allocator,
        cert: *const aws_byte_cursor,
        pkey: *const aws_byte_cursor,
    ) -> ::core::ffi::c_int;
    #[doc = " Increases the reference count for the passed-in aws_custom_key_op_handler and returns it."]
    pub fn aws_custom_key_op_handler_acquire(
        key_op_handler: *mut aws_custom_key_op_handler,
    ) -> *mut aws_custom_key_op_handler;
    #[doc = " Decreases the reference count for the passed-in aws_custom_key_op_handler and returns NULL."]
    pub fn aws_custom_key_op_handler_release(
        key_op_handler: *mut aws_custom_key_op_handler,
    ) -> *mut aws_custom_key_op_handler;
    #[doc = " Calls the on_key_operation vtable function. See aws_custom_key_op_handler_vtable for function details."]
    pub fn aws_custom_key_op_handler_perform_operation(
        key_op_handler: *mut aws_custom_key_op_handler,
        operation: *mut aws_tls_key_operation,
    );
    #[doc = " Initializes options for use with mutual TLS in client mode,\n where private key operations are handled by custom code.\n\n Note: cert_file_contents will be copied into a new buffer after this\n function is called, so you do not need to keep that data alive\n after calling this function.\n\n @param options               aws_tls_ctx_options to be initialized.\n @param allocator             Allocator to use.\n @param custom                Options for custom key operations.\n @param cert_file_contents    The contents of a certificate file."]
    pub fn aws_tls_ctx_options_init_client_mtls_with_custom_key_operations(
        options: *mut aws_tls_ctx_options,
        allocator: *mut aws_allocator,
        custom: *mut aws_custom_key_op_handler,
        cert_file_contents: *const aws_byte_cursor,
    ) -> ::core::ffi::c_int;
    #[doc = " Initializes options for use with mutual TLS in client mode,\n where a PKCS#11 library provides access to the private key.\n\n NOTE: This only works on Unix devices.\n\n @param options           aws_tls_ctx_options to be initialized.\n @param allocator         Allocator to use.\n @param pkcs11_options    Options for using PKCS#11 (contents are copied)"]
    pub fn aws_tls_ctx_options_init_client_mtls_with_pkcs11(
        options: *mut aws_tls_ctx_options,
        allocator: *mut aws_allocator,
        pkcs11_options: *const aws_tls_ctx_pkcs11_options,
    ) -> ::core::ffi::c_int;
    #[doc = " @Deprecated\n\n Sets a custom keychain path for storing the cert and pkey with mutual tls in client mode.\n\n NOTE: This only works on MacOS."]
    pub fn aws_tls_ctx_options_set_keychain_path(
        options: *mut aws_tls_ctx_options,
        keychain_path_cursor: *mut aws_byte_cursor,
    ) -> ::core::ffi::c_int;
    #[doc = " Initializes options for use with in server mode.\n cert_path and pkey_path are paths to files on disk. cert_path\n and pkey_path are treated as PKCS#7 PEM armored. They are loaded\n from disk and stored in buffers internally."]
    pub fn aws_tls_ctx_options_init_default_server_from_path(
        options: *mut aws_tls_ctx_options,
        allocator: *mut aws_allocator,
        cert_path: *const ::core::ffi::c_char,
        pkey_path: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    #[doc = " Initializes options for use with in server mode.\n cert and pkey are copied. cert and pkey are treated as PKCS#7 PEM\n armored."]
    pub fn aws_tls_ctx_options_init_default_server(
        options: *mut aws_tls_ctx_options,
        allocator: *mut aws_allocator,
        cert: *mut aws_byte_cursor,
        pkey: *mut aws_byte_cursor,
    ) -> ::core::ffi::c_int;
    #[doc = " Initializes options for use with mutual tls in client mode.\n cert_reg_path is the path to a system\n installed certficate/private key pair. Example:\n CurrentUser\\\\MY\\\\<thumprint>\n\n NOTE: This only works on Windows."]
    pub fn aws_tls_ctx_options_init_client_mtls_from_system_path(
        options: *mut aws_tls_ctx_options,
        allocator: *mut aws_allocator,
        cert_reg_path: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    #[doc = " Initializes options for use with server mode.\n cert_reg_path is the path to a system\n installed certficate/private key pair. Example:\n CurrentUser\\\\MY\\\\<thumprint>\n\n NOTE: This only works on Windows."]
    pub fn aws_tls_ctx_options_init_default_server_from_system_path(
        options: *mut aws_tls_ctx_options,
        allocator: *mut aws_allocator,
        cert_reg_path: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    #[doc = " Initializes options for use with mutual tls in client mode.\n pkcs12_path is a path to a file on disk containing a pkcs#12 file. The file is loaded\n into an internal buffer. pkcs_pwd is the corresponding password for the pkcs#12 file; it is copied.\n\n NOTE: This only works on Apple devices."]
    pub fn aws_tls_ctx_options_init_client_mtls_pkcs12_from_path(
        options: *mut aws_tls_ctx_options,
        allocator: *mut aws_allocator,
        pkcs12_path: *const ::core::ffi::c_char,
        pkcs_pwd: *const aws_byte_cursor,
    ) -> ::core::ffi::c_int;
    #[doc = " Initializes options for use with mutual tls in client mode.\n pkcs12 is a buffer containing a pkcs#12 certificate and private key; it is copied.\n pkcs_pwd is the corresponding password for the pkcs#12 buffer; it is copied.\n\n NOTE: This only works on Apple devices."]
    pub fn aws_tls_ctx_options_init_client_mtls_pkcs12(
        options: *mut aws_tls_ctx_options,
        allocator: *mut aws_allocator,
        pkcs12: *mut aws_byte_cursor,
        pkcs_pwd: *mut aws_byte_cursor,
    ) -> ::core::ffi::c_int;
    #[doc = " Initializes options for use in server mode.\n pkcs12_path is a path to a file on disk containing a pkcs#12 file. The file is loaded\n into an internal buffer. pkcs_pwd is the corresponding password for the pkcs#12 file; it is copied.\n\n NOTE: This only works on Apple devices."]
    pub fn aws_tls_ctx_options_init_server_pkcs12_from_path(
        options: *mut aws_tls_ctx_options,
        allocator: *mut aws_allocator,
        pkcs12_path: *const ::core::ffi::c_char,
        pkcs_password: *mut aws_byte_cursor,
    ) -> ::core::ffi::c_int;
    #[doc = " Initializes options for use in server mode.\n pkcs12 is a buffer containing a pkcs#12 certificate and private key; it is copied.\n pkcs_pwd is the corresponding password for the pkcs#12 buffer; it is copied.\n\n NOTE: This only works on Apple devices."]
    pub fn aws_tls_ctx_options_init_server_pkcs12(
        options: *mut aws_tls_ctx_options,
        allocator: *mut aws_allocator,
        pkcs12: *mut aws_byte_cursor,
        pkcs_password: *mut aws_byte_cursor,
    ) -> ::core::ffi::c_int;
    #[doc = " Sets alpn list in the form <protocol1;protocol2;...>. A maximum of 4 protocols are supported.\n alpn_list is copied."]
    pub fn aws_tls_ctx_options_set_alpn_list(
        options: *mut aws_tls_ctx_options,
        alpn_list: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    #[doc = " Enables or disables x.509 validation. Disable this only for testing. To enable mutual TLS in server mode,\n set verify_peer to true."]
    pub fn aws_tls_ctx_options_set_verify_peer(
        options: *mut aws_tls_ctx_options,
        verify_peer: bool,
    );
    #[doc = " Sets preferred TLS Cipher List"]
    pub fn aws_tls_ctx_options_set_tls_cipher_preference(
        options: *mut aws_tls_ctx_options,
        cipher_pref: aws_tls_cipher_pref,
    );
    #[doc = " Sets the minimum TLS version to allow."]
    pub fn aws_tls_ctx_options_set_minimum_tls_version(
        options: *mut aws_tls_ctx_options,
        minimum_tls_version: aws_tls_versions,
    );
    #[doc = " Override the default trust store. ca_file is a buffer containing a PEM armored chain of trusted CA certificates.\n ca_file is copied."]
    pub fn aws_tls_ctx_options_override_default_trust_store(
        options: *mut aws_tls_ctx_options,
        ca_file: *const aws_byte_cursor,
    ) -> ::core::ffi::c_int;
    #[doc = " Override the default trust store. ca_path is a path to a directory on disk containing trusted certificates. This is\n only supported on Unix systems (otherwise this parameter is ignored). ca_file is a path to a file on disk containing\n trusted certificates. ca_file is loaded from disk and stored in an internal buffer."]
    pub fn aws_tls_ctx_options_override_default_trust_store_from_path(
        options: *mut aws_tls_ctx_options,
        ca_path: *const ::core::ffi::c_char,
        ca_file: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    #[doc = " When implementing BYO_CRYPTO, if you need extra data to pass to your tls implementation, set it here. The lifetime of\n extension_data must outlive the options object and be cleaned up after options is cleaned up."]
    pub fn aws_tls_ctx_options_set_extension_data(
        options: *mut aws_tls_ctx_options,
        extension_data: *mut ::core::ffi::c_void,
    );
    #[doc = " Initializes default connection options from an instance ot aws_tls_ctx."]
    pub fn aws_tls_connection_options_init_from_ctx(
        conn_options: *mut aws_tls_connection_options,
        ctx: *mut aws_tls_ctx,
    );
    #[doc = " Cleans up resources in aws_tls_connection_options. This can be called immediately after initializing\n a tls handler, or if using the bootstrap api, immediately after asking for a channel."]
    pub fn aws_tls_connection_options_clean_up(connection_options: *mut aws_tls_connection_options);
    #[doc = " Copies 'from' to 'to'"]
    pub fn aws_tls_connection_options_copy(
        to: *mut aws_tls_connection_options,
        from: *const aws_tls_connection_options,
    ) -> ::core::ffi::c_int;
    #[doc = " Sets callbacks for use with a tls connection."]
    pub fn aws_tls_connection_options_set_callbacks(
        conn_options: *mut aws_tls_connection_options,
        on_negotiation_result: aws_tls_on_negotiation_result_fn,
        on_data_read: aws_tls_on_data_read_fn,
        on_error: aws_tls_on_error_fn,
        user_data: *mut ::core::ffi::c_void,
    );
    #[doc = " Sets server name to use for the SNI extension (supported everywhere), as well as x.509 validation. If you don't\n set this, your x.509 validation will likely fail."]
    pub fn aws_tls_connection_options_set_server_name(
        conn_options: *mut aws_tls_connection_options,
        allocator: *mut aws_allocator,
        server_name: *const aws_byte_cursor,
    ) -> ::core::ffi::c_int;
    #[doc = " Sets alpn list in the form <protocol1;protocol2;...>. A maximum of 4 protocols are supported.\n alpn_list is copied. This value is already inherited from aws_tls_ctx, but the aws_tls_ctx is expensive,\n and should be used across as many connections as possible. If you want to set this per connection, set it here."]
    pub fn aws_tls_connection_options_set_alpn_list(
        conn_options: *mut aws_tls_connection_options,
        allocator: *mut aws_allocator,
        alpn_list: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    #[doc = " Returns true if alpn is available in the underlying tls implementation.\n This function should always be called before setting an alpn list."]
    pub fn aws_tls_is_alpn_available() -> bool;
    #[doc = " Returns true if this Cipher Preference is available in the underlying TLS implementation.\n This function should always be called before setting a Cipher Preference"]
    pub fn aws_tls_is_cipher_pref_supported(cipher_pref: aws_tls_cipher_pref) -> bool;
    #[doc = " Creates a new tls channel handler in client mode. Options will be copied.\n You must call aws_tls_client_handler_start_negotiation and wait on the\n aws_tls_on_negotiation_result_fn callback before the handler can begin processing\n application data."]
    pub fn aws_tls_client_handler_new(
        allocator: *mut aws_allocator,
        options: *mut aws_tls_connection_options,
        slot: *mut aws_channel_slot,
    ) -> *mut aws_channel_handler;
    #[doc = " Creates a new tls channel handler in server mode. Options will be copied.\n You must wait on the aws_tls_on_negotiation_result_fn callback before the handler can begin processing\n application data."]
    pub fn aws_tls_server_handler_new(
        allocator: *mut aws_allocator,
        options: *mut aws_tls_connection_options,
        slot: *mut aws_channel_slot,
    ) -> *mut aws_channel_handler;
    #[doc = " Creates a channel handler, for client or server mode, that handles alpn. This isn't necessarily required\n since you can always call aws_tls_handler_protocol in the aws_tls_on_negotiation_result_fn callback, but\n this makes channel bootstrap easier to handle."]
    pub fn aws_tls_alpn_handler_new(
        allocator: *mut aws_allocator,
        on_protocol_negotiated: aws_tls_on_protocol_negotiated,
        user_data: *mut ::core::ffi::c_void,
    ) -> *mut aws_channel_handler;
    #[doc = " Kicks off the negotiation process. This function must be called when in client mode to initiate the\n TLS handshake. Once the handshake has completed the aws_tls_on_negotiation_result_fn will be invoked."]
    pub fn aws_tls_client_handler_start_negotiation(
        handler: *mut aws_channel_handler,
    ) -> ::core::ffi::c_int;
    #[doc = " Creates a new server ctx. This ctx can be used for the lifetime of the application assuming you want the same\n options for every incoming connection. Options will be copied."]
    pub fn aws_tls_server_ctx_new(
        alloc: *mut aws_allocator,
        options: *const aws_tls_ctx_options,
    ) -> *mut aws_tls_ctx;
    #[doc = " Creates a new client ctx. This ctx can be used for the lifetime of the application assuming you want the same\n options for every outgoing connection. Options will be copied."]
    pub fn aws_tls_client_ctx_new(
        alloc: *mut aws_allocator,
        options: *const aws_tls_ctx_options,
    ) -> *mut aws_tls_ctx;
    #[doc = " Increments the reference count on the tls context, allowing the caller to take a reference to it.\n\n Returns the same tls context passed in."]
    pub fn aws_tls_ctx_acquire(ctx: *mut aws_tls_ctx) -> *mut aws_tls_ctx;
    #[doc = " Decrements a tls context's ref count.  When the ref count drops to zero, the object will be destroyed."]
    pub fn aws_tls_ctx_release(ctx: *mut aws_tls_ctx);
    #[doc = " Not necessary if you are installing more handlers into the channel, but if you just want to have TLS for arbitrary\n data and use the channel handler directly, this function allows you to write data to the channel and have it\n encrypted."]
    pub fn aws_tls_handler_write(
        handler: *mut aws_channel_handler,
        slot: *mut aws_channel_slot,
        buf: *mut aws_byte_buf,
        on_write_completed: aws_channel_on_message_write_completed_fn,
        completion_user_data: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    #[doc = " Returns a byte buffer by copy of the negotiated protocols. If there is no agreed upon protocol, len will be 0 and\n buffer will be NULL."]
    pub fn aws_tls_handler_protocol(handler: *mut aws_channel_handler) -> aws_byte_buf;
    #[doc = " Client mode only. This is the server name that was used for SNI and host name validation."]
    pub fn aws_tls_handler_server_name(handler: *mut aws_channel_handler) -> aws_byte_buf;
    #[doc = " Complete a successful TLS private key operation by providing its output.\n The output is copied into the TLS connection.\n The operation is freed by this call.\n\n You MUST call this or aws_tls_key_operation_complete_with_error().\n Failure to do so will stall the TLS connection indefinitely and leak memory."]
    pub fn aws_tls_key_operation_complete(
        operation: *mut aws_tls_key_operation,
        output: aws_byte_cursor,
    );
    #[doc = " Complete an failed TLS private key operation.\n The TLS connection will fail.\n The operation is freed by this call.\n\n You MUST call this or aws_tls_key_operation_complete().\n Failure to do so will stall the TLS connection indefinitely and leak memory."]
    pub fn aws_tls_key_operation_complete_with_error(
        operation: *mut aws_tls_key_operation,
        error_code: ::core::ffi::c_int,
    );
    #[doc = " Returns the input data that needs to be operated on by the custom key operation."]
    pub fn aws_tls_key_operation_get_input(
        operation: *const aws_tls_key_operation,
    ) -> aws_byte_cursor;
    #[doc = " Returns the type of operation that needs to be performed by the custom key operation.\n If the implementation cannot perform the operation,\n use aws_tls_key_operation_complete_with_error() to preventing stalling the TLS connection."]
    pub fn aws_tls_key_operation_get_type(
        operation: *const aws_tls_key_operation,
    ) -> aws_tls_key_operation_type;
    #[doc = " Returns the algorithm the operation is expected to be operated with.\n If the implementation does not support the signature algorithm,\n use aws_tls_key_operation_complete_with_error() to preventing stalling the TLS connection."]
    pub fn aws_tls_key_operation_get_signature_algorithm(
        operation: *const aws_tls_key_operation,
    ) -> aws_tls_signature_algorithm;
    #[doc = " Returns the algorithm the operation digest is signed with.\n If the implementation does not support the digest algorithm,\n use aws_tls_key_operation_complete_with_error() to preventing stalling the TLS connection."]
    pub fn aws_tls_key_operation_get_digest_algorithm(
        operation: *const aws_tls_key_operation,
    ) -> aws_tls_hash_algorithm;
    #[doc = " Misc TLS related"]
    pub fn aws_channel_setup_client_tls(
        right_of_slot: *mut aws_channel_slot,
        tls_options: *mut aws_tls_connection_options,
    ) -> ::core::ffi::c_int;
    #[doc = " Given enum, return string like: AWS_TLS_HASH_SHA256 -> \"SHA256\""]
    pub fn aws_tls_hash_algorithm_str(hash: aws_tls_hash_algorithm) -> *const ::core::ffi::c_char;
    #[doc = " Given enum, return string like: AWS_TLS_SIGNATURE_RSA -> \"RSA\""]
    pub fn aws_tls_signature_algorithm_str(
        signature: aws_tls_signature_algorithm,
    ) -> *const ::core::ffi::c_char;
    #[doc = " Given enum, return string like: AWS_TLS_SIGNATURE_RSA -> \"RSA\""]
    pub fn aws_tls_key_operation_type_str(
        operation_type: aws_tls_key_operation_type,
    ) -> *const ::core::ffi::c_char;
    #[doc = " Initializes socket channel handler statistics"]
    pub fn aws_crt_statistics_socket_init(
        stats: *mut aws_crt_statistics_socket,
    ) -> ::core::ffi::c_int;
    #[doc = " Cleans up socket channel handler statistics"]
    pub fn aws_crt_statistics_socket_cleanup(stats: *mut aws_crt_statistics_socket);
    #[doc = " Resets socket channel handler statistics for the next gather interval.  Calculate-once results are left alone."]
    pub fn aws_crt_statistics_socket_reset(stats: *mut aws_crt_statistics_socket);
    #[doc = " Initializes tls channel handler statistics"]
    pub fn aws_crt_statistics_tls_init(stats: *mut aws_crt_statistics_tls) -> ::core::ffi::c_int;
    #[doc = " Cleans up tls channel handler statistics"]
    pub fn aws_crt_statistics_tls_cleanup(stats: *mut aws_crt_statistics_tls);
    #[doc = " Resets tls channel handler statistics for the next gather interval.  Calculate-once results are left alone."]
    pub fn aws_crt_statistics_tls_reset(stats: *mut aws_crt_statistics_tls);
    #[doc = " Increments the reference count on the input stream, allowing the caller to take a reference to it.\n\n Returns the same input stream passed in."]
    pub fn aws_input_stream_acquire(stream: *mut aws_input_stream) -> *mut aws_input_stream;
    #[doc = " Decrements a input stream's ref count.  When the ref count drops to zero, the input stream will be destroyed.\n\n Returns NULL always."]
    pub fn aws_input_stream_release(stream: *mut aws_input_stream) -> *mut aws_input_stream;
    pub fn aws_input_stream_seek(
        stream: *mut aws_input_stream,
        offset: i64,
        basis: aws_stream_seek_basis,
    ) -> ::core::ffi::c_int;
    pub fn aws_input_stream_read(
        stream: *mut aws_input_stream,
        dest: *mut aws_byte_buf,
    ) -> ::core::ffi::c_int;
    pub fn aws_input_stream_get_status(
        stream: *mut aws_input_stream,
        status: *mut aws_stream_status,
    ) -> ::core::ffi::c_int;
    pub fn aws_input_stream_get_length(
        stream: *mut aws_input_stream,
        out_length: *mut i64,
    ) -> ::core::ffi::c_int;
    pub fn aws_input_stream_destroy(stream: *mut aws_input_stream);
    pub fn aws_input_stream_new_from_cursor(
        allocator: *mut aws_allocator,
        cursor: *const aws_byte_cursor,
    ) -> *mut aws_input_stream;
    pub fn aws_input_stream_new_from_file(
        allocator: *mut aws_allocator,
        file_name: *const ::core::ffi::c_char,
    ) -> *mut aws_input_stream;
    pub fn aws_input_stream_new_from_open_file(
        allocator: *mut aws_allocator,
        file: *mut FILE,
    ) -> *mut aws_input_stream;
}
