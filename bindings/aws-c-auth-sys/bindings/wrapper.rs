/* automatically generated by rust-bindgen 0.69.1 */

#[doc = " Auth-specific error codes"]
pub type aws_auth_errors = ::core::ffi::c_uint;
#[doc = " Auth-specific logging subjects"]
pub type aws_auth_log_subject = ::core::ffi::c_uint;
pub type aws_on_get_credentials_callback_fn = ::core::option::Option<
    unsafe extern "C" fn(
        credentials: *mut aws_credentials,
        error_code: ::core::ffi::c_int,
        user_data: *mut ::core::ffi::c_void,
    ),
>;
pub type aws_credentials_provider_get_credentials_fn = ::core::option::Option<
    unsafe extern "C" fn(
        provider: *mut aws_credentials_provider,
        callback: aws_on_get_credentials_callback_fn,
        user_data: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int,
>;
pub type aws_credentials_provider_destroy_fn =
    ::core::option::Option<unsafe extern "C" fn(provider: *mut aws_credentials_provider)>;
pub type aws_credentials_provider_shutdown_completed_fn =
    ::core::option::Option<unsafe extern "C" fn(user_data: *mut ::core::ffi::c_void)>;
pub type aws_imds_protocol_version = ::core::ffi::c_uint;
pub type aws_credentials_provider_delegate_get_credentials_fn = ::core::option::Option<
    unsafe extern "C" fn(
        delegate_user_data: *mut ::core::ffi::c_void,
        callback: aws_on_get_credentials_callback_fn,
        callback_user_data: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int,
>;
pub type aws_imds_client_shutdown_completed_fn =
    ::core::option::Option<unsafe extern "C" fn(user_data: *mut ::core::ffi::c_void)>;
pub type aws_imds_client_on_get_resource_callback_fn = ::core::option::Option<
    unsafe extern "C" fn(
        resource: *const aws_byte_buf,
        error_code: ::core::ffi::c_int,
        user_data: *mut ::core::ffi::c_void,
    ),
>;
pub type aws_imds_client_on_get_array_callback_fn = ::core::option::Option<
    unsafe extern "C" fn(
        array: *const aws_array_list,
        error_code: ::core::ffi::c_int,
        user_data: *mut ::core::ffi::c_void,
    ),
>;
pub type aws_imds_client_on_get_credentials_callback_fn = ::core::option::Option<
    unsafe extern "C" fn(
        credentials: *const aws_credentials,
        error_code: ::core::ffi::c_int,
        user_data: *mut ::core::ffi::c_void,
    ),
>;
pub type aws_imds_client_on_get_iam_profile_callback_fn = ::core::option::Option<
    unsafe extern "C" fn(
        iam_profile_info: *const aws_imds_iam_profile,
        error_code: ::core::ffi::c_int,
        user_data: *mut ::core::ffi::c_void,
    ),
>;
pub type aws_imds_client_on_get_instance_info_callback_fn = ::core::option::Option<
    unsafe extern "C" fn(
        instance_info: *const aws_imds_instance_info,
        error_code: ::core::ffi::c_int,
        user_data: *mut ::core::ffi::c_void,
    ),
>;
pub type aws_signable_get_property_fn = ::core::option::Option<
    unsafe extern "C" fn(
        signable: *const aws_signable,
        name: *const aws_string,
        out_value: *mut aws_byte_cursor,
    ) -> ::core::ffi::c_int,
>;
pub type aws_signable_get_property_list_fn = ::core::option::Option<
    unsafe extern "C" fn(
        signable: *const aws_signable,
        name: *const aws_string,
        out_list: *mut *mut aws_array_list,
    ) -> ::core::ffi::c_int,
>;
pub type aws_signable_get_payload_stream_fn = ::core::option::Option<
    unsafe extern "C" fn(
        signable: *const aws_signable,
        out_input_stream: *mut *mut aws_input_stream,
    ) -> ::core::ffi::c_int,
>;
pub type aws_signable_destroy_fn =
    ::core::option::Option<unsafe extern "C" fn(signable: *mut aws_signable)>;
pub type aws_should_sign_header_fn = ::core::option::Option<
    unsafe extern "C" fn(name: *const aws_byte_cursor, userdata: *mut ::core::ffi::c_void) -> bool,
>;
#[doc = " A primitive RTTI indicator for signing configuration structs\n\n There must be one entry per config structure type and it's a fatal error\n to put the wrong value in the \"config_type\" member of your config structure."]
pub type aws_signing_config_type = ::core::ffi::c_uint;
#[doc = " What version of the AWS signing process should we use."]
pub type aws_signing_algorithm = ::core::ffi::c_uint;
#[doc = " What sort of signature should be computed from the signable?"]
pub type aws_signature_type = ::core::ffi::c_uint;
#[doc = " Controls if signing adds a header containing the canonical request's body value"]
pub type aws_signed_body_header_type = ::core::ffi::c_uint;
#[doc = " Gets called by the signing function when the signing is complete.\n\n Note that result will be destroyed after this function returns, so either copy it,\n or do all necessary adjustments inside the callback.\n\n When performing event or chunk signing, you will need to copy out the signature value in order\n to correctly configure the signable that wraps the event or chunk you want signed next.  The signature is\n found in the \"signature\" property on the signing result.  This value must be added as the\n \"previous-signature\" property on the next signable."]
pub type aws_signing_complete_fn = ::core::option::Option<
    unsafe extern "C" fn(
        result: *mut aws_signing_result,
        error_code: ::core::ffi::c_int,
        userdata: *mut ::core::ffi::c_void,
    ),
>;
#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_auth_http_system_vtable {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_credentials {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_credentials_provider_vtable {
    pub get_credentials: aws_credentials_provider_get_credentials_fn,
    pub destroy: aws_credentials_provider_destroy_fn,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_credentials_provider_shutdown_options {
    pub shutdown_callback: aws_credentials_provider_shutdown_completed_fn,
    pub shutdown_user_data: *mut ::core::ffi::c_void,
}
#[doc = " A baseclass for credentials providers.  A credentials provider is an object that has an asynchronous\n query function for retrieving AWS credentials.\n\n Ref-counted.  Thread-safe."]
#[repr(C)]
pub struct aws_credentials_provider {
    pub vtable: *mut aws_credentials_provider_vtable,
    pub allocator: *mut aws_allocator,
    pub shutdown_options: aws_credentials_provider_shutdown_options,
    pub impl_: *mut ::core::ffi::c_void,
    pub ref_count: aws_atomic_var,
}
#[doc = " Configuration options for a provider that returns a fixed set of credentials"]
#[repr(C)]
pub struct aws_credentials_provider_static_options {
    pub shutdown_options: aws_credentials_provider_shutdown_options,
    pub access_key_id: aws_byte_cursor,
    pub secret_access_key: aws_byte_cursor,
    pub session_token: aws_byte_cursor,
}
#[doc = " Configuration options for a provider that returns credentials based on environment variable values"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_credentials_provider_environment_options {
    pub shutdown_options: aws_credentials_provider_shutdown_options,
}
#[doc = " Configuration options for a provider that sources credentials from the aws config and credentials files\n (by default ~/.aws/config and ~/.aws/credentials)"]
#[repr(C)]
pub struct aws_credentials_provider_profile_options {
    pub shutdown_options: aws_credentials_provider_shutdown_options,
    pub profile_name_override: aws_byte_cursor,
    pub config_file_name_override: aws_byte_cursor,
    pub credentials_file_name_override: aws_byte_cursor,
    #[doc = " (Optional)\n Use a cached merged profile collection. A merge collection has both config file\n (~/.aws/config) and credentials file based profile collection (~/.aws/credentials) using\n `aws_profile_collection_new_from_merge`.\n If this option is provided, `config_file_name_override` and `credentials_file_name_override` will be ignored."]
    pub profile_collection_cached: *mut aws_profile_collection,
    pub bootstrap: *mut aws_client_bootstrap,
    pub tls_ctx: *mut aws_tls_ctx,
    pub function_table: *mut aws_auth_http_system_vtable,
}
#[doc = " Configuration options for a provider that functions as a caching decorator.  Credentials sourced through this\n provider will be cached within it until their expiration time.  When the cached credentials expire, new\n credentials will be fetched when next queried."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_credentials_provider_cached_options {
    pub shutdown_options: aws_credentials_provider_shutdown_options,
    pub source: *mut aws_credentials_provider,
    pub refresh_time_in_milliseconds: u64,
    pub high_res_clock_fn: aws_io_clock_fn,
    pub system_clock_fn: aws_io_clock_fn,
}
#[doc = " Configuration options for a provider that queries, in order, a list of providers.  This provider uses the\n first set of credentials successfully queried.  Providers are queried one at a time; a provider is not queried\n until the preceding provider has failed to source credentials."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_credentials_provider_chain_options {
    pub shutdown_options: aws_credentials_provider_shutdown_options,
    pub providers: *mut *mut aws_credentials_provider,
    pub provider_count: usize,
}
#[doc = " Configuration options for the provider that sources credentials from ec2 instance metadata"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_credentials_provider_imds_options {
    pub shutdown_options: aws_credentials_provider_shutdown_options,
    pub bootstrap: *mut aws_client_bootstrap,
    pub imds_version: aws_imds_protocol_version,
    pub ec2_metadata_v1_disabled: bool,
    pub function_table: *mut aws_auth_http_system_vtable,
}
#[repr(C)]
pub struct aws_credentials_provider_ecs_options {
    pub shutdown_options: aws_credentials_provider_shutdown_options,
    pub bootstrap: *mut aws_client_bootstrap,
    pub host: aws_byte_cursor,
    pub path_and_query: aws_byte_cursor,
    pub auth_token: aws_byte_cursor,
    pub tls_ctx: *mut aws_tls_ctx,
    pub function_table: *mut aws_auth_http_system_vtable,
    pub port: u32,
}
#[doc = " Configuration options for the X509 credentials provider\n\n The x509 credentials provider sources temporary credentials from AWS IoT Core using TLS mutual authentication.\n See details: https://docs.aws.amazon.com/iot/latest/developerguide/authorizing-direct-aws.html\n An end to end demo with detailed steps can be found here:\n https://aws.amazon.com/blogs/security/how-to-eliminate-the-need-for-hardcoded-aws-credentials-in-devices-by-using-the-aws-iot-credentials-provider/"]
#[repr(C)]
pub struct aws_credentials_provider_x509_options {
    pub shutdown_options: aws_credentials_provider_shutdown_options,
    pub bootstrap: *mut aws_client_bootstrap,
    pub tls_connection_options: *const aws_tls_connection_options,
    pub thing_name: aws_byte_cursor,
    pub role_alias: aws_byte_cursor,
    #[doc = " Per-account X509 credentials sourcing endpoint."]
    pub endpoint: aws_byte_cursor,
    #[doc = " (Optional) Http proxy configuration for the http request that fetches credentials"]
    pub proxy_options: *mut aws_http_proxy_options,
    pub function_table: *mut aws_auth_http_system_vtable,
}
#[doc = " Configuration options for the STS web identity provider\n\n Sts with web identity credentials provider sources a set of temporary security credentials for users who have been\n authenticated in a mobile or web application with a web identity provider.\n Example providers include Amazon Cognito, Login with Amazon, Facebook, Google, or any OpenID Connect-compatible\n identity provider like Elastic Kubernetes Service\n https://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRoleWithWebIdentity.html\n The required parameters used in the request (region, roleArn, sessionName, tokenFilePath) are automatically resolved\n by SDK from envrionment variables or config file if not set.\n---------------------------------------------------------------------------------\n| Parameter           | Environment Variable Name    | Config File Property Name |\n----------------------------------------------------------------------------------\n| region              | AWS_DEFAULT_REGION           | region                    |\n| role_arn            | AWS_ROLE_ARN                 | role_arn                  |\n| role_session_name   | AWS_ROLE_SESSION_NAME        | role_session_name         |\n| token_file_path     | AWS_WEB_IDENTITY_TOKEN_FILE  | web_identity_token_file   |\n|--------------------------------------------------------------------------------|\n The order of resolution is the following\n 1. Parameters\n 2. Environment Variables\n 3. Config File"]
#[repr(C)]
pub struct aws_credentials_provider_sts_web_identity_options {
    pub shutdown_options: aws_credentials_provider_shutdown_options,
    pub bootstrap: *mut aws_client_bootstrap,
    #[doc = " (Optional)\n Use a cached config profile collection. You can also pass a merged collection."]
    pub config_profile_collection_cached: *mut aws_profile_collection,
    pub tls_ctx: *mut aws_tls_ctx,
    pub function_table: *mut aws_auth_http_system_vtable,
    pub profile_name_override: aws_byte_cursor,
    pub region: aws_byte_cursor,
    pub role_arn: aws_byte_cursor,
    pub role_session_name: aws_byte_cursor,
    pub token_file_path: aws_byte_cursor,
}
#[repr(C)]
pub struct aws_credentials_provider_sso_options {
    pub shutdown_options: aws_credentials_provider_shutdown_options,
    pub profile_name_override: aws_byte_cursor,
    pub config_file_name_override: aws_byte_cursor,
    #[doc = " (Optional)\n Use a cached config profile collection. You can also pass a merged collection.\n config_file_name_override will be ignored if this option is provided."]
    pub config_file_cached: *mut aws_profile_collection,
    pub bootstrap: *mut aws_client_bootstrap,
    pub tls_ctx: *mut aws_tls_ctx,
    pub function_table: *mut aws_auth_http_system_vtable,
    pub system_clock_fn: aws_io_clock_fn,
}
#[doc = " Configuration options for the STS credentials provider"]
#[repr(C)]
pub struct aws_credentials_provider_sts_options {
    pub bootstrap: *mut aws_client_bootstrap,
    pub tls_ctx: *mut aws_tls_ctx,
    pub creds_provider: *mut aws_credentials_provider,
    pub role_arn: aws_byte_cursor,
    pub session_name: aws_byte_cursor,
    pub duration_seconds: u16,
    #[doc = " (Optional) Http proxy configuration for the AssumeRole http request that fetches credentials"]
    pub http_proxy_options: *const aws_http_proxy_options,
    pub shutdown_options: aws_credentials_provider_shutdown_options,
    pub function_table: *mut aws_auth_http_system_vtable,
    pub system_clock_fn: aws_io_clock_fn,
}
#[doc = " Configuration options for the process credentials provider\n\n The process credentials provider sources credentials from running a command or process.\n The command to run is sourced from a profile in the AWS config file, using the standard\n profile selection rules. The profile key the command is read from is \"credential_process.\"\n E.g.:\n  [default]\n  credential_process=/opt/amazon/bin/my-credential-fetcher --argsA=abc\n On successfully running the command, the output should be a json data with the following\n format:\n {\n\"Version\": 1,\n\"AccessKeyId\": \"accesskey\",\n\"SecretAccessKey\": \"secretAccessKey\"\n\"SessionToken\": \"....\",\n\"Expiration\": \"2019-05-29T00:21:43Z\"\n}\n Version here identifies the command output format version."]
#[repr(C)]
pub struct aws_credentials_provider_process_options {
    pub shutdown_options: aws_credentials_provider_shutdown_options,
    #[doc = " In which profile name to look for credential_process,\n if not provided, we will try environment variable: AWS_PROFILE."]
    pub profile_to_use: aws_byte_cursor,
    #[doc = " (Optional)\n Use a cached config profile collection. You can also pass a merged collection."]
    pub config_profile_collection_cached: *mut aws_profile_collection,
}
#[doc = " Configuration options for the default credentials provider chain."]
#[repr(C)]
pub struct aws_credentials_provider_chain_default_options {
    pub shutdown_options: aws_credentials_provider_shutdown_options,
    pub bootstrap: *mut aws_client_bootstrap,
    pub tls_ctx: *mut aws_tls_ctx,
    #[doc = " (Optional)\n Use a cached merged profile collection. A merge collection has both config file\n (~/.aws/config) and credentials file based profile collection (~/.aws/credentials) using\n `aws_profile_collection_new_from_merge`.\n If this option is provided, `config_file_name_override` and `credentials_file_name_override` will be ignored."]
    pub profile_collection_cached: *mut aws_profile_collection,
    pub profile_name_override: aws_byte_cursor,
}
#[doc = " Configuration options for the delegate credentials provider."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_credentials_provider_delegate_options {
    pub shutdown_options: aws_credentials_provider_shutdown_options,
    #[doc = " Delegated get_credentials() callback."]
    pub get_credentials: aws_credentials_provider_delegate_get_credentials_fn,
    #[doc = " User data for delegated callbacks."]
    pub delegate_user_data: *mut ::core::ffi::c_void,
}
#[doc = " A (string) pair defining an identity provider and a valid login token sourced from it."]
#[repr(C)]
pub struct aws_cognito_identity_provider_token_pair {
    #[doc = " Name of an identity provider"]
    pub identity_provider_name: aws_byte_cursor,
    #[doc = " Valid login token source from the identity provider"]
    pub identity_provider_token: aws_byte_cursor,
}
#[doc = " Configuration options needed to create a Cognito-based Credentials Provider"]
#[repr(C)]
pub struct aws_credentials_provider_cognito_options {
    pub shutdown_options: aws_credentials_provider_shutdown_options,
    #[doc = " Cognito service regional endpoint to source credentials from."]
    pub endpoint: aws_byte_cursor,
    #[doc = " Cognito identity to fetch credentials relative to."]
    pub identity: aws_byte_cursor,
    #[doc = " Optional set of identity provider token pairs to allow for authenticated identity access."]
    pub logins: *mut aws_cognito_identity_provider_token_pair,
    pub login_count: usize,
    #[doc = " Optional ARN of the role to be assumed when multiple roles were received in the token from the identity provider."]
    pub custom_role_arn: *mut aws_byte_cursor,
    pub bootstrap: *mut aws_client_bootstrap,
    pub tls_ctx: *mut aws_tls_ctx,
    #[doc = " (Optional) Http proxy configuration for the http request that fetches credentials"]
    pub http_proxy_options: *const aws_http_proxy_options,
    pub function_table: *mut aws_auth_http_system_vtable,
}
#[doc = " Optional callback and user data to be invoked when an imds client has fully shut down"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_imds_client_shutdown_options {
    pub shutdown_callback: aws_imds_client_shutdown_completed_fn,
    pub shutdown_user_data: *mut ::core::ffi::c_void,
}
#[doc = " Configuration options when creating an imds client"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_imds_client_options {
    pub shutdown_options: aws_imds_client_shutdown_options,
    pub bootstrap: *mut aws_client_bootstrap,
    pub retry_strategy: *mut aws_retry_strategy,
    pub imds_version: aws_imds_protocol_version,
    pub ec2_metadata_v1_disabled: bool,
    pub function_table: *mut aws_auth_http_system_vtable,
}
#[doc = " https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instancedata-data-categories.html"]
#[repr(C)]
pub struct aws_imds_iam_profile {
    pub last_updated: aws_date_time,
    pub instance_profile_arn: aws_byte_cursor,
    pub instance_profile_id: aws_byte_cursor,
}
#[doc = " Block of per-instance EC2-specific data\n\n https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-identity-documents.html"]
#[repr(C)]
pub struct aws_imds_instance_info {
    pub marketplace_product_codes: aws_array_list,
    pub availability_zone: aws_byte_cursor,
    pub private_ip: aws_byte_cursor,
    pub version: aws_byte_cursor,
    pub instance_id: aws_byte_cursor,
    pub billing_products: aws_array_list,
    pub instance_type: aws_byte_cursor,
    pub account_id: aws_byte_cursor,
    pub image_id: aws_byte_cursor,
    pub pending_time: aws_date_time,
    pub architecture: aws_byte_cursor,
    pub kernel_id: aws_byte_cursor,
    pub ramdisk_id: aws_byte_cursor,
    pub region: aws_byte_cursor,
}
#[doc = " AWS EC2 Metadata Client is used to retrieve AWS EC2 Instance Metadata info."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_imds_client {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct aws_signable_property_list_pair {
    pub name: aws_byte_cursor,
    pub value: aws_byte_cursor,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_signable_vtable {
    pub get_property: aws_signable_get_property_fn,
    pub get_property_list: aws_signable_get_property_list_fn,
    pub get_payload_stream: aws_signable_get_payload_stream_fn,
    pub destroy: aws_signable_destroy_fn,
}
#[doc = " Signable is a generic interface for any kind of object that can be cryptographically signed.\n\n Like signing_result, the signable interface presents\n\n   (1) Properties - A set of key-value pairs\n   (2) Property Lists - A set of named key-value pair lists\n\n as well as\n\n   (3) A message payload modeled as a stream\n\n When creating a signable \"subclass\" the query interface should map to retrieving\n the properties of the underlying object needed by signing algorithms that can operate on it.\n\n As an example, if a signable implementation wrapped an http request, you would query\n request elements like method and uri from the property interface, headers would be queried\n via the property list interface, and the request body would map to the payload stream.\n\n String constants that map to agreed on keys for particular signable types\n (\"METHOD\", \"URI\", \"HEADERS\", etc...) are exposed in appropriate header files."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_signable {
    pub allocator: *mut aws_allocator,
    pub impl_: *mut ::core::ffi::c_void,
    pub vtable: *mut aws_signable_vtable,
}
#[doc = " All signing configuration structs must match this by having\n the config_type member as the first member."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_signing_config_base {
    pub config_type: aws_signing_config_type,
}
#[doc = " A configuration structure for use in AWS-related signing.  Currently covers sigv4 only, but is not required to."]
#[repr(C)]
pub struct aws_signing_config_aws {
    #[doc = " What kind of config structure is this?"]
    pub config_type: aws_signing_config_type,
    #[doc = " What signing algorithm to use."]
    pub algorithm: aws_signing_algorithm,
    #[doc = " What sort of signature should be computed?"]
    pub signature_type: aws_signature_type,
    pub region: aws_byte_cursor,
    #[doc = " name of service to sign a request for"]
    pub service: aws_byte_cursor,
    #[doc = " Raw date to use during the signing process."]
    pub date: aws_date_time,
    #[doc = " Optional function to control which headers are a part of the canonical request.\n Skipping auth-required headers will result in an unusable signature.  Headers injected by the signing process\n are not skippable.\n\n This function does not override the internal check function (x-amzn-trace-id, user-agent), but rather\n supplements it.  In particular, a header will get signed if and only if it returns true to both\n the internal check (skips x-amzn-trace-id, user-agent) and this function (if defined)."]
    pub should_sign_header: aws_should_sign_header_fn,
    pub should_sign_header_ud: *mut ::core::ffi::c_void,
    pub flags: aws_signing_config_aws__bindgen_ty_1,
    #[doc = " Optional string to use as the canonical request's body value.\n If string is empty, a value will be calculated from the payload during signing.\n Typically, this is the SHA-256 of the (request/chunk/event) payload, written as lowercase hex.\n If this has been precalculated, it can be set here. Special values used by certain services can also be set\n (e.g. \"UNSIGNED-PAYLOAD\" \"STREAMING-AWS4-HMAC-SHA256-PAYLOAD\" \"STREAMING-AWS4-HMAC-SHA256-EVENTS\")."]
    pub signed_body_value: aws_byte_cursor,
    #[doc = " Controls what body \"hash\" header, if any, should be added to the canonical request and the signed request:\n   AWS_SBHT_NONE - no header should be added\n   AWS_SBHT_X_AMZ_CONTENT_SHA256 - the body \"hash\" should be added in the X-Amz-Content-Sha256 header"]
    pub signed_body_header: aws_signed_body_header_type,
    pub credentials: *const aws_credentials,
    pub credentials_provider: *mut aws_credentials_provider,
    #[doc = " If non-zero and the signing transform is query param, then signing will add X-Amz-Expires to the query\n string, equal to the value specified here.  If this value is zero or if header signing is being used then\n this parameter has no effect."]
    pub expiration_in_seconds: u64,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct aws_signing_config_aws__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_signing_result_property {
    pub name: *mut aws_string,
    pub value: *mut aws_string,
}
#[doc = " A structure for tracking all the signer-requested changes to a signable.  Interpreting\n these changes is signing-algorithm specific.\n\n A signing result consists of\n\n   (1) Properties - A set of key-value pairs\n   (2) Property Lists - A set of named key-value pair lists\n\n The hope is that these two generic structures are enough to model the changes required\n by any generic message-signing algorithm.\n\n Note that the key-value pairs of a signing_result are different types (but same intent) as\n the key-value pairs in the signable interface.  This is because the signing result stands alone\n and owns its own copies of all values, whereas a signable can wrap an existing object and thus\n use non-owning references (like byte cursors) if appropriate to its implementation."]
#[repr(C)]
pub struct aws_signing_result {
    pub allocator: *mut aws_allocator,
    pub properties: aws_hash_table,
    pub property_lists: aws_hash_table,
}
pub const AWS_C_AUTH_PACKAGE_ID: u32 = 6;
pub const AWS_AUTH_PROFILE_PARSE_RECOVERABLE_ERROR: aws_auth_errors = 15362;
pub const AWS_AUTH_PROFILE_PARSE_FATAL_ERROR: aws_auth_errors = 15361;
pub const AWS_AUTH_SIGNING_UNSUPPORTED_ALGORITHM: aws_auth_errors = 6144;
pub const AWS_AUTH_SIGNING_MISMATCHED_CONFIGURATION: aws_auth_errors = 6145;
pub const AWS_AUTH_SIGNING_NO_CREDENTIALS: aws_auth_errors = 6146;
pub const AWS_AUTH_SIGNING_ILLEGAL_REQUEST_QUERY_PARAM: aws_auth_errors = 6147;
pub const AWS_AUTH_SIGNING_ILLEGAL_REQUEST_HEADER: aws_auth_errors = 6148;
pub const AWS_AUTH_SIGNING_INVALID_CONFIGURATION: aws_auth_errors = 6149;
pub const AWS_AUTH_CREDENTIALS_PROVIDER_INVALID_ENVIRONMENT: aws_auth_errors = 6150;
pub const AWS_AUTH_CREDENTIALS_PROVIDER_INVALID_DELEGATE: aws_auth_errors = 6151;
pub const AWS_AUTH_CREDENTIALS_PROVIDER_PROFILE_SOURCE_FAILURE: aws_auth_errors = 6152;
pub const AWS_AUTH_CREDENTIALS_PROVIDER_IMDS_SOURCE_FAILURE: aws_auth_errors = 6153;
pub const AWS_AUTH_CREDENTIALS_PROVIDER_STS_SOURCE_FAILURE: aws_auth_errors = 6154;
pub const AWS_AUTH_CREDENTIALS_PROVIDER_HTTP_STATUS_FAILURE: aws_auth_errors = 6155;
pub const AWS_AUTH_PROVIDER_PARSER_UNEXPECTED_RESPONSE: aws_auth_errors = 6156;
pub const AWS_AUTH_CREDENTIALS_PROVIDER_ECS_SOURCE_FAILURE: aws_auth_errors = 6157;
pub const AWS_AUTH_CREDENTIALS_PROVIDER_X509_SOURCE_FAILURE: aws_auth_errors = 6158;
pub const AWS_AUTH_CREDENTIALS_PROVIDER_PROCESS_SOURCE_FAILURE: aws_auth_errors = 6159;
pub const AWS_AUTH_CREDENTIALS_PROVIDER_STS_WEB_IDENTITY_SOURCE_FAILURE: aws_auth_errors = 6160;
pub const AWS_AUTH_SIGNING_UNSUPPORTED_SIGNATURE_TYPE: aws_auth_errors = 6161;
pub const AWS_AUTH_SIGNING_MISSING_PREVIOUS_SIGNATURE: aws_auth_errors = 6162;
pub const AWS_AUTH_SIGNING_INVALID_CREDENTIALS: aws_auth_errors = 6163;
pub const AWS_AUTH_CANONICAL_REQUEST_MISMATCH: aws_auth_errors = 6164;
pub const AWS_AUTH_SIGV4A_SIGNATURE_VALIDATION_FAILURE: aws_auth_errors = 6165;
pub const AWS_AUTH_CREDENTIALS_PROVIDER_COGNITO_SOURCE_FAILURE: aws_auth_errors = 6166;
pub const AWS_AUTH_CREDENTIALS_PROVIDER_DELEGATE_FAILURE: aws_auth_errors = 6167;
pub const AWS_AUTH_SSO_TOKEN_PROVIDER_SOURCE_FAILURE: aws_auth_errors = 6168;
pub const AWS_AUTH_SSO_TOKEN_INVALID: aws_auth_errors = 6169;
pub const AWS_AUTH_SSO_TOKEN_EXPIRED: aws_auth_errors = 6170;
pub const AWS_AUTH_CREDENTIALS_PROVIDER_SSO_SOURCE_FAILURE: aws_auth_errors = 6171;
pub const AWS_AUTH_IMDS_CLIENT_SOURCE_FAILURE: aws_auth_errors = 6172;
pub const AWS_AUTH_ERROR_END_RANGE: aws_auth_errors = 7167;
pub const AWS_LS_AUTH_GENERAL: aws_auth_log_subject = 6144;
pub const AWS_LS_AUTH_PROFILE: aws_auth_log_subject = 6145;
pub const AWS_LS_AUTH_CREDENTIALS_PROVIDER: aws_auth_log_subject = 6146;
pub const AWS_LS_AUTH_SIGNING: aws_auth_log_subject = 6147;
pub const AWS_LS_IMDS_CLIENT: aws_auth_log_subject = 6148;
pub const AWS_LS_AUTH_LAST: aws_auth_log_subject = 7167;
#[doc = " Defaults to IMDS_PROTOCOL_V2. It can be set to either one and IMDS Client\n will figure out (by looking at response code) which protocol an instance\n is using. But a more clear setting will reduce unnecessary network request."]
pub const IMDS_PROTOCOL_V2: aws_imds_protocol_version = 0;
#[doc = " Defaults to IMDS_PROTOCOL_V2. It can be set to either one and IMDS Client\n will figure out (by looking at response code) which protocol an instance\n is using. But a more clear setting will reduce unnecessary network request."]
pub const IMDS_PROTOCOL_V1: aws_imds_protocol_version = 1;
pub const AWS_SIGNING_CONFIG_AWS: aws_signing_config_type = 1;
pub const AWS_SIGNING_ALGORITHM_V4: aws_signing_algorithm = 0;
pub const AWS_SIGNING_ALGORITHM_V4_ASYMMETRIC: aws_signing_algorithm = 1;
pub const AWS_SIGNING_ALGORITHM_V4_S3EXPRESS: aws_signing_algorithm = 2;
#[doc = " A signature for a full http request should be computed, with header updates applied to the signing result."]
pub const AWS_ST_HTTP_REQUEST_HEADERS: aws_signature_type = 0;
#[doc = " A signature for a full http request should be computed, with query param updates applied to the signing result."]
pub const AWS_ST_HTTP_REQUEST_QUERY_PARAMS: aws_signature_type = 1;
#[doc = " Compute a signature for a payload chunk. The signable's input stream should be the chunk data and the\n signable should contain the most recent signature value (either the original http request or the most recent\n chunk) in the \"previous-signature\" property."]
pub const AWS_ST_HTTP_REQUEST_CHUNK: aws_signature_type = 2;
#[doc = " Compute a signature for an event stream event. The signable's input stream should be the encoded event-stream\n message (headers + payload), the signable should contain the most recent signature value (either the original\n http request or the most recent event) in the \"previous-signature\" property.\n\n This option is only supported for Sigv4 for now."]
pub const AWS_ST_HTTP_REQUEST_EVENT: aws_signature_type = 3;
#[doc = " Compute a signature for an http request via it's already-computed canonical request.  Only the authorization\n signature header is added to the signing result."]
pub const AWS_ST_CANONICAL_REQUEST_HEADERS: aws_signature_type = 4;
#[doc = " Compute a signature for an http request via it's already-computed canonical request.  Only the authorization\n signature query param is added to the signing result."]
pub const AWS_ST_CANONICAL_REQUEST_QUERY_PARAMS: aws_signature_type = 5;
#[doc = " Compute a signature for the trailing headers.\n the signable should contain the most recent signature value (either the original http request or the most recent\n chunk) in the \"previous-signature\" property."]
pub const AWS_ST_HTTP_REQUEST_TRAILING_HEADERS: aws_signature_type = 6;
#[doc = " Do not add a header"]
pub const AWS_SBHT_NONE: aws_signed_body_header_type = 0;
#[doc = " Add the \"x-amz-content-sha256\" header with the canonical request's body value"]
pub const AWS_SBHT_X_AMZ_CONTENT_SHA256: aws_signed_body_header_type = 1;
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
impl aws_signing_config_aws__bindgen_ty_1 {
    #[inline]
    pub fn use_double_uri_encode(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_use_double_uri_encode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn should_normalize_uri_path(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_should_normalize_uri_path(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn omit_session_token(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_omit_session_token(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        use_double_uri_encode: u32,
        should_normalize_uri_path: u32,
        omit_session_token: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let use_double_uri_encode: u32 =
                unsafe { ::core::mem::transmute(use_double_uri_encode) };
            use_double_uri_encode as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let should_normalize_uri_path: u32 =
                unsafe { ::core::mem::transmute(should_normalize_uri_path) };
            should_normalize_uri_path as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let omit_session_token: u32 = unsafe { ::core::mem::transmute(omit_session_token) };
            omit_session_token as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    #[doc = " Initializes internal datastructures used by aws-c-auth.\n Must be called before using any functionality in aws-c-auth.\n\n @param allocator memory allocator to use for any module-level memory allocation"]
    pub fn aws_auth_library_init(allocator: *mut aws_allocator);
    #[doc = " Clean up internal datastructures used by aws-c-auth.\n Must not be called until application is done using functionality in aws-c-auth."]
    pub fn aws_auth_library_clean_up();
    #[doc = " Creates a new set of aws credentials\n\n @param allocator memory allocator to use\n @param access_key_id_cursor value for the aws access key id field\n @param secret_access_key_cursor value for the secret access key field\n @param session_token_cursor (optional) security token associated with the credentials\n @param expiration_timepoint_seconds timepoint, in seconds since epoch, that the credentials will no longer\n be valid past.  For credentials that do not expire, use UINT64_MAX\n\n @return a valid credentials object, or NULL"]
    pub fn aws_credentials_new(
        allocator: *mut aws_allocator,
        access_key_id_cursor: aws_byte_cursor,
        secret_access_key_cursor: aws_byte_cursor,
        session_token_cursor: aws_byte_cursor,
        expiration_timepoint_seconds: u64,
    ) -> *mut aws_credentials;
    #[doc = " Creates a new set of aws anonymous credentials.\n Use Anonymous credentials, when you want to skip the signing process.\n\n @param allocator memory allocator to use\n\n @return a valid credentials object, or NULL"]
    pub fn aws_credentials_new_anonymous(allocator: *mut aws_allocator) -> *mut aws_credentials;
    #[doc = " Creates a new set of AWS credentials\n\n @param allocator memory allocator to use\n @param access_key_id  value for the aws access key id field\n @param secret_access_key value for the secret access key field\n @param session_token (optional) security token associated with the credentials\n @param expiration_timepoint_seconds timepoint, in seconds since epoch, that the credentials will no longer\n be valid past.  For credentials that do not expire, use UINT64_MAX\n\n @return a valid credentials object, or NULL"]
    pub fn aws_credentials_new_from_string(
        allocator: *mut aws_allocator,
        access_key_id: *const aws_string,
        secret_access_key: *const aws_string,
        session_token: *const aws_string,
        expiration_timepoint_seconds: u64,
    ) -> *mut aws_credentials;
    #[doc = " Creates a set of AWS credentials that includes an ECC key pair.  These credentials do not have a value for\n the secret access key; the ecc key takes over that field's role in sigv4a signing.\n\n @param allocator memory allocator to use for all memory allocation\n @param access_key_id access key id for the credential set\n @param ecc_key ecc key to use during signing when using these credentials\n @param session_token (optional) session token associated with the credentials\n @param expiration_timepoint_in_seconds (optional) if session-based, time at which these credentials expire\n @return a new pair of AWS credentials, or NULL"]
    pub fn aws_credentials_new_ecc(
        allocator: *mut aws_allocator,
        access_key_id: aws_byte_cursor,
        ecc_key: *mut aws_ecc_key_pair,
        session_token: aws_byte_cursor,
        expiration_timepoint_in_seconds: u64,
    ) -> *mut aws_credentials;
    pub fn aws_credentials_new_ecc_from_aws_credentials(
        allocator: *mut aws_allocator,
        credentials: *const aws_credentials,
    ) -> *mut aws_credentials;
    #[doc = " Add a reference to some credentials\n\n @param credentials credentials to increment the ref count on"]
    pub fn aws_credentials_acquire(credentials: *const aws_credentials);
    #[doc = " Remove a reference to some credentials\n\n @param credentials credentials to decrement the ref count on"]
    pub fn aws_credentials_release(credentials: *const aws_credentials);
    #[doc = " Get the AWS access key id from a set of credentials\n\n @param credentials credentials to get the access key id from\n @return a byte cursor to the access key id"]
    pub fn aws_credentials_get_access_key_id(
        credentials: *const aws_credentials,
    ) -> aws_byte_cursor;
    #[doc = " Get the AWS secret access key from a set of credentials\n\n @param credentials credentials to get the secret access key from\n @return a byte cursor to the secret access key"]
    pub fn aws_credentials_get_secret_access_key(
        credentials: *const aws_credentials,
    ) -> aws_byte_cursor;
    #[doc = " Get the AWS session token from a set of credentials\n\n @param credentials credentials to get the session token from\n @return a byte cursor to the session token or an empty byte cursor if there is no session token"]
    pub fn aws_credentials_get_session_token(
        credentials: *const aws_credentials,
    ) -> aws_byte_cursor;
    #[doc = " Get the expiration timepoint (in seconds since epoch) associated with a set of credentials\n\n @param credentials credentials to get the expiration timepoint for\n @return the time, in seconds since epoch, the credentials will expire; UINT64_MAX for credentials\n without a specific expiration time"]
    pub fn aws_credentials_get_expiration_timepoint_seconds(
        credentials: *const aws_credentials,
    ) -> u64;
    #[doc = " Get the elliptic curve key associated with this set of credentials\n @param credentials credentials to get the the elliptic curve key for\n @return the elliptic curve key associated with the credentials, or NULL if no key is associated with\n these credentials"]
    pub fn aws_credentials_get_ecc_key_pair(
        credentials: *const aws_credentials,
    ) -> *mut aws_ecc_key_pair;
    #[doc = " If credentials are anonymous, then the signing process is skipped.\n\n @param credentials credentials to check\n\n @return true if the credentials are anonymous; false otherwise."]
    pub fn aws_credentials_is_anonymous(credentials: *const aws_credentials) -> bool;
    #[doc = " Release a reference to a credentials provider\n\n @param provider provider to decrement the ref count on"]
    pub fn aws_credentials_provider_release(
        provider: *mut aws_credentials_provider,
    ) -> *mut aws_credentials_provider;
    pub fn aws_credentials_provider_acquire(
        provider: *mut aws_credentials_provider,
    ) -> *mut aws_credentials_provider;
    pub fn aws_credentials_provider_get_credentials(
        provider: *mut aws_credentials_provider,
        callback: aws_on_get_credentials_callback_fn,
        user_data: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    #[doc = " Creates a simple provider that just returns a fixed set of credentials\n\n @param allocator memory allocator to use for all memory allocation\n @param options provider-specific configuration options\n\n @return the newly-constructed credentials provider, or NULL if an error occurred."]
    pub fn aws_credentials_provider_new_static(
        allocator: *mut aws_allocator,
        options: *const aws_credentials_provider_static_options,
    ) -> *mut aws_credentials_provider;
    #[doc = " Creates a simple anonymous credentials provider\n\n @param allocator memory allocator to use for all memory allocation\n @param shutdown_options an optional shutdown callback that gets\n invoked when the resources used by the provider are no longer in use.\n\n @return the newly-constructed credentials provider, or NULL if an error occurred."]
    pub fn aws_credentials_provider_new_anonymous(
        allocator: *mut aws_allocator,
        shutdown_options: *const aws_credentials_provider_shutdown_options,
    ) -> *mut aws_credentials_provider;
    #[doc = " Creates a provider that returns credentials sourced from the environment variables:\n\n AWS_ACCESS_KEY_ID\n AWS_SECRET_ACCESS_KEY\n AWS_SESSION_TOKEN\n\n @param allocator memory allocator to use for all memory allocation\n @param options provider-specific configuration options\n\n @return the newly-constructed credentials provider, or NULL if an error occurred."]
    pub fn aws_credentials_provider_new_environment(
        allocator: *mut aws_allocator,
        options: *const aws_credentials_provider_environment_options,
    ) -> *mut aws_credentials_provider;
    #[doc = " Creates a provider that functions as a caching decorating of another provider.\n\n For example, the default chain is implemented as:\n\n CachedProvider -> ProviderChain(EnvironmentProvider -> ProfileProvider -> ECS/EC2IMD etc...)\n\n A reference is taken on the target provider\n\n @param allocator memory allocator to use for all memory allocation\n @param options provider-specific configuration options\n\n @return the newly-constructed credentials provider, or NULL if an error occurred."]
    pub fn aws_credentials_provider_new_cached(
        allocator: *mut aws_allocator,
        options: *const aws_credentials_provider_cached_options,
    ) -> *mut aws_credentials_provider;
    #[doc = " Creates a provider that sources credentials from key-value profiles loaded from the aws credentials\n file (\"~/.aws/credentials\" by default) and the aws config file (\"~/.aws/config\" by\n default)\n\n @param allocator memory allocator to use for all memory allocation\n @param options provider-specific configuration options\n\n @return the newly-constructed credentials provider, or NULL if an error occurred."]
    pub fn aws_credentials_provider_new_profile(
        allocator: *mut aws_allocator,
        options: *const aws_credentials_provider_profile_options,
    ) -> *mut aws_credentials_provider;
    #[doc = " Creates a provider that assumes an IAM role via. STS AssumeRole() API. This provider will fetch new credentials\n upon each call to aws_credentials_provider_get_credentials().\n\n @param allocator memory allocator to use for all memory allocation\n @param options provider-specific configuration options\n\n @return the newly-constructed credentials provider, or NULL if an error occurred."]
    pub fn aws_credentials_provider_new_sts(
        allocator: *mut aws_allocator,
        options: *const aws_credentials_provider_sts_options,
    ) -> *mut aws_credentials_provider;
    #[doc = " Creates a provider that sources credentials from an ordered sequence of providers, with the overall result\n being from the first provider to return a valid set of credentials\n\n References are taken on all supplied providers\n\n @param allocator memory allocator to use for all memory allocation\n @param options provider-specific configuration options\n\n @return the newly-constructed credentials provider, or NULL if an error occurred."]
    pub fn aws_credentials_provider_new_chain(
        allocator: *mut aws_allocator,
        options: *const aws_credentials_provider_chain_options,
    ) -> *mut aws_credentials_provider;
    #[doc = " Creates a provider that sources credentials from the ec2 instance metadata service\n\n @param allocator memory allocator to use for all memory allocation\n @param options provider-specific configuration options\n\n @return the newly-constructed credentials provider, or NULL if an error occurred."]
    pub fn aws_credentials_provider_new_imds(
        allocator: *mut aws_allocator,
        options: *const aws_credentials_provider_imds_options,
    ) -> *mut aws_credentials_provider;
    #[doc = " Creates a provider that sources credentials from the ecs role credentials service\n\n @param allocator memory allocator to use for all memory allocation\n @param options provider-specific configuration options\n\n @return the newly-constructed credentials provider, or NULL if an error occurred."]
    pub fn aws_credentials_provider_new_ecs(
        allocator: *mut aws_allocator,
        options: *const aws_credentials_provider_ecs_options,
    ) -> *mut aws_credentials_provider;
    #[doc = " Creates a provider that sources credentials from IoT Core\n\n @param allocator memory allocator to use for all memory allocation\n @param options provider-specific configuration options\n\n @return the newly-constructed credentials provider, or NULL if an error occurred."]
    pub fn aws_credentials_provider_new_x509(
        allocator: *mut aws_allocator,
        options: *const aws_credentials_provider_x509_options,
    ) -> *mut aws_credentials_provider;
    #[doc = " Creates a provider that sources credentials from STS using AssumeRoleWithWebIdentity\n\n @param allocator memory allocator to use for all memory allocation\n @param options provider-specific configuration options\n\n @return the newly-constructed credentials provider, or NULL if an error occurred."]
    pub fn aws_credentials_provider_new_sts_web_identity(
        allocator: *mut aws_allocator,
        options: *const aws_credentials_provider_sts_web_identity_options,
    ) -> *mut aws_credentials_provider;
    #[doc = " Creates a provider that sources credentials from SSO using a SSOToken.\n\n @param allocator memory allocator to use for all memory allocation\n @param options provider-specific configuration options\n\n @return the newly-constructed credentials provider, or NULL if an error occurred."]
    pub fn aws_credentials_provider_new_sso(
        allocator: *mut aws_allocator,
        options: *const aws_credentials_provider_sso_options,
    ) -> *mut aws_credentials_provider;
    pub fn aws_credentials_provider_new_process(
        allocator: *mut aws_allocator,
        options: *const aws_credentials_provider_process_options,
    ) -> *mut aws_credentials_provider;
    #[doc = " Create a credentials provider depends on provided vtable to fetch the credentials.\n\n @param allocator memory allocator to use for all memory allocation\n @param options provider-specific configuration options\n\n @return the newly-constructed credentials provider, or NULL if an error occurred."]
    pub fn aws_credentials_provider_new_delegate(
        allocator: *mut aws_allocator,
        options: *const aws_credentials_provider_delegate_options,
    ) -> *mut aws_credentials_provider;
    #[doc = " Creates a provider that sources credentials from the Cognito-Identity service via an\n invocation of the GetCredentialsForIdentity API call.\n\n @param allocator memory allocator to use for all memory allocation\n @param options provider-specific configuration options\n\n @return the newly-constructed credentials provider, or NULL if an error occurred."]
    pub fn aws_credentials_provider_new_cognito(
        allocator: *mut aws_allocator,
        options: *const aws_credentials_provider_cognito_options,
    ) -> *mut aws_credentials_provider;
    #[doc = " Creates a cognito-based provider that has a caching layer wrapped around it\n\n @param allocator memory allocator to use for all memory allocation\n @param options cognito-specific configuration options\n\n @return the newly-constructed credentials provider, or NULL if an error occurred."]
    pub fn aws_credentials_provider_new_cognito_caching(
        allocator: *mut aws_allocator,
        options: *const aws_credentials_provider_cognito_options,
    ) -> *mut aws_credentials_provider;
    #[doc = " Creates the default provider chain used by most AWS SDKs.\n\n Generally:\n\n (1) Environment\n (2) Profile\n (3) STS web identity\n (4) (conditional, off by default) ECS\n (5) (conditional, on by default) EC2 Instance Metadata\n\n Support for environmental control of the default provider chain is not yet\n implemented.\n\n @param allocator memory allocator to use for all memory allocation\n @param options provider-specific configuration options\n\n @return the newly-constructed credentials provider, or NULL if an error occurred."]
    pub fn aws_credentials_provider_new_chain_default(
        allocator: *mut aws_allocator,
        options: *const aws_credentials_provider_chain_default_options,
    ) -> *mut aws_credentials_provider;
    #[doc = " Creates a new imds client\n\n @param allocator memory allocator to use for creation and queries\n @param options configuration options for the imds client\n\n @return a newly-constructed imds client, or NULL on failure"]
    pub fn aws_imds_client_new(
        allocator: *mut aws_allocator,
        options: *const aws_imds_client_options,
    ) -> *mut aws_imds_client;
    #[doc = " Increments the ref count on the client\n\n @param client imds client to acquire a reference to"]
    pub fn aws_imds_client_acquire(client: *mut aws_imds_client);
    #[doc = " Decrements the ref count on the client\n\n @param client imds client to release a reference to"]
    pub fn aws_imds_client_release(client: *mut aws_imds_client);
    #[doc = " Queries a generic resource (string) from the ec2 instance metadata document\n\n @param client imds client to use for the query\n @param resource_path path of the resource to query\n @param callback callback function to invoke on query success or failure\n @param user_data opaque data to invoke the completion callback with\n @return AWS_OP_SUCCESS if the query was successfully started, AWS_OP_ERR otherwise"]
    pub fn aws_imds_client_get_resource_async(
        client: *mut aws_imds_client,
        resource_path: aws_byte_cursor,
        callback: aws_imds_client_on_get_resource_callback_fn,
        user_data: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    #[doc = " Gets the ami id of the ec2 instance from the instance metadata document\n\n @param client imds client to use for the query\n @param callback callback function to invoke on query success or failure\n @param user_data opaque data to invoke the completion callback with\n @return AWS_OP_SUCCESS if the query was successfully started, AWS_OP_ERR otherwise"]
    pub fn aws_imds_client_get_ami_id(
        client: *mut aws_imds_client,
        callback: aws_imds_client_on_get_resource_callback_fn,
        user_data: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    #[doc = " Gets the ami launch index of the ec2 instance from the instance metadata document\n\n @param client imds client to use for the query\n @param callback callback function to invoke on query success or failure\n @param user_data opaque data to invoke the completion callback with\n @return AWS_OP_SUCCESS if the query was successfully started, AWS_OP_ERR otherwise"]
    pub fn aws_imds_client_get_ami_launch_index(
        client: *mut aws_imds_client,
        callback: aws_imds_client_on_get_resource_callback_fn,
        user_data: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    #[doc = " Gets the ami manifest path of the ec2 instance from the instance metadata document\n\n @param client imds client to use for the query\n @param callback callback function to invoke on query success or failure\n @param user_data opaque data to invoke the completion callback with\n @return AWS_OP_SUCCESS if the query was successfully started, AWS_OP_ERR otherwise"]
    pub fn aws_imds_client_get_ami_manifest_path(
        client: *mut aws_imds_client,
        callback: aws_imds_client_on_get_resource_callback_fn,
        user_data: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    #[doc = " Gets the list of ancestor ami ids of the ec2 instance from the instance metadata document\n\n @param client imds client to use for the query\n @param callback callback function to invoke on query success or failure\n @param user_data opaque data to invoke the completion callback with\n @return AWS_OP_SUCCESS if the query was successfully started, AWS_OP_ERR otherwise"]
    pub fn aws_imds_client_get_ancestor_ami_ids(
        client: *mut aws_imds_client,
        callback: aws_imds_client_on_get_array_callback_fn,
        user_data: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    #[doc = " Gets the instance-action of the ec2 instance from the instance metadata document\n\n @param client imds client to use for the query\n @param callback callback function to invoke on query success or failure\n @param user_data opaque data to invoke the completion callback with\n @return AWS_OP_SUCCESS if the query was successfully started, AWS_OP_ERR otherwise"]
    pub fn aws_imds_client_get_instance_action(
        client: *mut aws_imds_client,
        callback: aws_imds_client_on_get_resource_callback_fn,
        user_data: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    #[doc = " Gets the instance id of the ec2 instance from the instance metadata document\n\n @param client imds client to use for the query\n @param callback callback function to invoke on query success or failure\n @param user_data opaque data to invoke the completion callback with\n @return AWS_OP_SUCCESS if the query was successfully started, AWS_OP_ERR otherwise"]
    pub fn aws_imds_client_get_instance_id(
        client: *mut aws_imds_client,
        callback: aws_imds_client_on_get_resource_callback_fn,
        user_data: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    #[doc = " Gets the instance type of the ec2 instance from the instance metadata document\n\n @param client imds client to use for the query\n @param callback callback function to invoke on query success or failure\n @param user_data opaque data to invoke the completion callback with\n @return AWS_OP_SUCCESS if the query was successfully started, AWS_OP_ERR otherwise"]
    pub fn aws_imds_client_get_instance_type(
        client: *mut aws_imds_client,
        callback: aws_imds_client_on_get_resource_callback_fn,
        user_data: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    #[doc = " Gets the mac address of the ec2 instance from the instance metadata document\n\n @param client imds client to use for the query\n @param callback callback function to invoke on query success or failure\n @param user_data opaque data to invoke the completion callback with\n @return AWS_OP_SUCCESS if the query was successfully started, AWS_OP_ERR otherwise"]
    pub fn aws_imds_client_get_mac_address(
        client: *mut aws_imds_client,
        callback: aws_imds_client_on_get_resource_callback_fn,
        user_data: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    #[doc = " Gets the private ip address of the ec2 instance from the instance metadata document\n\n @param client imds client to use for the query\n @param callback callback function to invoke on query success or failure\n @param user_data opaque data to invoke the completion callback with\n @return AWS_OP_SUCCESS if the query was successfully started, AWS_OP_ERR otherwise"]
    pub fn aws_imds_client_get_private_ip_address(
        client: *mut aws_imds_client,
        callback: aws_imds_client_on_get_resource_callback_fn,
        user_data: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    #[doc = " Gets the availability zone of the ec2 instance from the instance metadata document\n\n @param client imds client to use for the query\n @param callback callback function to invoke on query success or failure\n @param user_data opaque data to invoke the completion callback with\n @return AWS_OP_SUCCESS if the query was successfully started, AWS_OP_ERR otherwise"]
    pub fn aws_imds_client_get_availability_zone(
        client: *mut aws_imds_client,
        callback: aws_imds_client_on_get_resource_callback_fn,
        user_data: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    #[doc = " Gets the product codes of the ec2 instance from the instance metadata document\n\n @param client imds client to use for the query\n @param callback callback function to invoke on query success or failure\n @param user_data opaque data to invoke the completion callback with\n @return AWS_OP_SUCCESS if the query was successfully started, AWS_OP_ERR otherwise"]
    pub fn aws_imds_client_get_product_codes(
        client: *mut aws_imds_client,
        callback: aws_imds_client_on_get_resource_callback_fn,
        user_data: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    #[doc = " Gets the public key of the ec2 instance from the instance metadata document\n\n @param client imds client to use for the query\n @param callback callback function to invoke on query success or failure\n @param user_data opaque data to invoke the completion callback with\n @return AWS_OP_SUCCESS if the query was successfully started, AWS_OP_ERR otherwise"]
    pub fn aws_imds_client_get_public_key(
        client: *mut aws_imds_client,
        callback: aws_imds_client_on_get_resource_callback_fn,
        user_data: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    #[doc = " Gets the ramdisk id of the ec2 instance from the instance metadata document\n\n @param client imds client to use for the query\n @param callback callback function to invoke on query success or failure\n @param user_data opaque data to invoke the completion callback with\n @return AWS_OP_SUCCESS if the query was successfully started, AWS_OP_ERR otherwise"]
    pub fn aws_imds_client_get_ramdisk_id(
        client: *mut aws_imds_client,
        callback: aws_imds_client_on_get_resource_callback_fn,
        user_data: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    #[doc = " Gets the reservation id of the ec2 instance from the instance metadata document\n\n @param client imds client to use for the query\n @param callback callback function to invoke on query success or failure\n @param user_data opaque data to invoke the completion callback with\n @return AWS_OP_SUCCESS if the query was successfully started, AWS_OP_ERR otherwise"]
    pub fn aws_imds_client_get_reservation_id(
        client: *mut aws_imds_client,
        callback: aws_imds_client_on_get_resource_callback_fn,
        user_data: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    #[doc = " Gets the list of the security groups of the ec2 instance from the instance metadata document\n\n @param client imds client to use for the query\n @param callback callback function to invoke on query success or failure\n @param user_data opaque data to invoke the completion callback with\n @return AWS_OP_SUCCESS if the query was successfully started, AWS_OP_ERR otherwise"]
    pub fn aws_imds_client_get_security_groups(
        client: *mut aws_imds_client,
        callback: aws_imds_client_on_get_array_callback_fn,
        user_data: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    #[doc = " Gets the list of block device mappings of the ec2 instance from the instance metadata document\n\n @param client imds client to use for the query\n @param callback callback function to invoke on query success or failure\n @param user_data opaque data to invoke the completion callback with\n @return AWS_OP_SUCCESS if the query was successfully started, AWS_OP_ERR otherwise"]
    pub fn aws_imds_client_get_block_device_mapping(
        client: *mut aws_imds_client,
        callback: aws_imds_client_on_get_array_callback_fn,
        user_data: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    #[doc = " Gets the attached iam role of the ec2 instance from the instance metadata document\n\n @param client imds client to use for the query\n @param callback callback function to invoke on query success or failure\n @param user_data opaque data to invoke the completion callback with\n @return AWS_OP_SUCCESS if the query was successfully started, AWS_OP_ERR otherwise"]
    pub fn aws_imds_client_get_attached_iam_role(
        client: *mut aws_imds_client,
        callback: aws_imds_client_on_get_resource_callback_fn,
        user_data: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    #[doc = " Gets temporary credentials based on the attached iam role of the ec2 instance\n\n @param client imds client to use for the query\n @param iam_role_name iam role name to get temporary credentials through\n @param callback callback function to invoke on query success or failure\n @param user_data opaque data to invoke the completion callback with\n @return AWS_OP_SUCCESS if the query was successfully started, AWS_OP_ERR otherwise"]
    pub fn aws_imds_client_get_credentials(
        client: *mut aws_imds_client,
        iam_role_name: aws_byte_cursor,
        callback: aws_imds_client_on_get_credentials_callback_fn,
        user_data: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    #[doc = " Gets the iam profile information of the ec2 instance from the instance metadata document\n\n @param client imds client to use for the query\n @param callback callback function to invoke on query success or failure\n @param user_data opaque data to invoke the completion callback with\n @return AWS_OP_SUCCESS if the query was successfully started, AWS_OP_ERR otherwise"]
    pub fn aws_imds_client_get_iam_profile(
        client: *mut aws_imds_client,
        callback: aws_imds_client_on_get_iam_profile_callback_fn,
        user_data: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    #[doc = " Gets the user data of the ec2 instance from the instance metadata document\n\n @param client imds client to use for the query\n @param callback callback function to invoke on query success or failure\n @param user_data opaque data to invoke the completion callback with\n @return AWS_OP_SUCCESS if the query was successfully started, AWS_OP_ERR otherwise"]
    pub fn aws_imds_client_get_user_data(
        client: *mut aws_imds_client,
        callback: aws_imds_client_on_get_resource_callback_fn,
        user_data: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    #[doc = " Gets the signature of the ec2 instance from the instance metadata document\n\n @param client imds client to use for the query\n @param callback callback function to invoke on query success or failure\n @param user_data opaque data to invoke the completion callback with\n @return AWS_OP_SUCCESS if the query was successfully started, AWS_OP_ERR otherwise"]
    pub fn aws_imds_client_get_instance_signature(
        client: *mut aws_imds_client,
        callback: aws_imds_client_on_get_resource_callback_fn,
        user_data: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    #[doc = " Gets the instance information data block of the ec2 instance from the instance metadata document\n\n @param client imds client to use for the query\n @param callback callback function to invoke on query success or failure\n @param user_data opaque data to invoke the completion callback with\n @return AWS_OP_SUCCESS if the query was successfully started, AWS_OP_ERR otherwise"]
    pub fn aws_imds_client_get_instance_info(
        client: *mut aws_imds_client,
        callback: aws_imds_client_on_get_instance_info_callback_fn,
        user_data: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    #[doc = " Cleans up and frees all resources associated with a signable instance\n\n @param signable signable object to destroy"]
    pub fn aws_signable_destroy(signable: *mut aws_signable);
    #[doc = " Retrieves a property (key-value pair) from a signable.  Global property name constants are\n included below.\n\n @param signable signable object to retrieve a property from\n @param name name of the property to query\n @param out_value output parameter for the property's value\n\n @return AWS_OP_SUCCESS if the property was successfully fetched, AWS_OP_ERR otherwise"]
    pub fn aws_signable_get_property(
        signable: *const aws_signable,
        name: *const aws_string,
        out_value: *mut aws_byte_cursor,
    ) -> ::core::ffi::c_int;
    #[doc = " Retrieves a named property list (list of key-value pairs) from a signable.  Global property list name\n constants are included below.\n\n @param signable signable object to retrieve a property list from\n @param name name of the property list to fetch\n @param out_property_list output parameter for the fetched property list\n\n @return AWS_OP_SUCCESS if the property list was successfully fetched, AWS_OP_ERR otherwise"]
    pub fn aws_signable_get_property_list(
        signable: *const aws_signable,
        name: *const aws_string,
        out_property_list: *mut *mut aws_array_list,
    ) -> ::core::ffi::c_int;
    #[doc = " Retrieves the signable's message payload as a stream.\n\n @param signable signable to get the payload of\n @param out_input_stream output parameter for the payload stream\n\n @return AWS_OP_SUCCESS if successful, AWS_OP_ERR otherwise"]
    pub fn aws_signable_get_payload_stream(
        signable: *const aws_signable,
        out_input_stream: *mut *mut aws_input_stream,
    ) -> ::core::ffi::c_int;
    #[doc = " Creates a signable wrapper around an http request.\n\n @param allocator memory allocator to use to create the signable\n @param request http request to create a signable for\n\n @return the new signable object, or NULL if failure"]
    pub fn aws_signable_new_http_request(
        allocator: *mut aws_allocator,
        request: *mut aws_http_message,
    ) -> *mut aws_signable;
    #[doc = " Creates a signable that represents a unit of chunked encoding within an http request.\n This can also be used for Transcribe event signing with encoded payload as chunk_data.\n\n @param allocator memory allocator use to create the signable\n @param chunk_data stream representing the data in the chunk; it should be in its final, encoded form\n @param previous_signature the signature computed in the most recent signing that preceded this one.  It can be\n found by copying the \"signature\" property from the signing_result of that most recent signing.\n\n @return the new signable object, or NULL if failure"]
    pub fn aws_signable_new_chunk(
        allocator: *mut aws_allocator,
        chunk_data: *mut aws_input_stream,
        previous_signature: aws_byte_cursor,
    ) -> *mut aws_signable;
    #[doc = " Creates a signable wrapper around a set of headers.\n\n @param allocator memory allocator use to create the signable\n @param trailing_headers http headers to create a signable for\n @param previous_signature the signature computed in the most recent signing that preceded this one.  It can be\n found by copying the \"signature\" property from the signing_result of that most recent signing.\n\n @return the new signable object, or NULL if failure"]
    pub fn aws_signable_new_trailing_headers(
        allocator: *mut aws_allocator,
        trailing_headers: *mut aws_http_headers,
        previous_signature: aws_byte_cursor,
    ) -> *mut aws_signable;
    #[doc = " Creates a signable that represents a pre-computed canonical request from an http request\n @param allocator memory allocator use to create the signable\n @param canonical_request text of the canonical request\n @return the new signable object, or NULL if failure"]
    pub fn aws_signable_new_canonical_request(
        allocator: *mut aws_allocator,
        canonical_request: aws_byte_cursor,
    ) -> *mut aws_signable;
    #[doc = " Returns a c-string that describes the supplied signing algorithm\n\n @param algorithm signing algorithm to get a friendly string name for\n\n @return friendly string name of the supplied algorithm, or \"Unknown\" if the algorithm is not recognized"]
    pub fn aws_signing_algorithm_to_string(
        algorithm: aws_signing_algorithm,
    ) -> *const ::core::ffi::c_char;
    #[doc = " Initialize a signing result to its starting state\n\n @param result signing result to initialize\n @param allocator allocator to use for all memory allocation\n\n @return AWS_OP_SUCCESS if initialization was successful, AWS_OP_ERR otherwise"]
    pub fn aws_signing_result_init(
        result: *mut aws_signing_result,
        allocator: *mut aws_allocator,
    ) -> ::core::ffi::c_int;
    #[doc = " Clean up all resources held by the signing result\n\n @param result signing result to clean up resources for"]
    pub fn aws_signing_result_clean_up(result: *mut aws_signing_result);
    #[doc = " Sets the value of a property on a signing result\n\n @param result signing result to modify\n @param property_name name of the property to set\n @param property_value value that the property should assume\n\n @return AWS_OP_SUCCESS if the set was successful, AWS_OP_ERR otherwise"]
    pub fn aws_signing_result_set_property(
        result: *mut aws_signing_result,
        property_name: *const aws_string,
        property_value: *const aws_byte_cursor,
    ) -> ::core::ffi::c_int;
    #[doc = " Gets the value of a property on a signing result\n\n @param result signing result to query from\n @param property_name name of the property to query the value of\n @param out_property_value output parameter for the property value\n\n @return AWS_OP_SUCCESS if the get was successful, AWS_OP_ERR otherwise"]
    pub fn aws_signing_result_get_property(
        result: *const aws_signing_result,
        property_name: *const aws_string,
        out_property_value: *mut *mut aws_string,
    ) -> ::core::ffi::c_int;
    #[doc = " Adds a key-value pair to a named property list.  If the named list does not yet exist, it will be created as\n an empty list before the pair is added.  No uniqueness checks are made against existing pairs.\n\n @param result signing result to modify\n @param list_name name of the list to add the property key-value pair to\n @param property_name key value of the key-value pair to append\n @param property_value property value of the key-value pair to append\n\n @return AWS_OP_SUCCESS if the operation was successful, AWS_OP_ERR otherwise"]
    pub fn aws_signing_result_append_property_list(
        result: *mut aws_signing_result,
        list_name: *const aws_string,
        property_name: *const aws_byte_cursor,
        property_value: *const aws_byte_cursor,
    ) -> ::core::ffi::c_int;
    #[doc = " Gets a named property list on the signing result.  If the list does not exist, *out_list will be set to null\n\n @param result signing result to query\n @param list_name name of the list of key-value pairs to get\n @param out_list output parameter for the list of key-value pairs\n"]
    pub fn aws_signing_result_get_property_list(
        result: *const aws_signing_result,
        list_name: *const aws_string,
        out_list: *mut *mut aws_array_list,
    );
    #[doc = " Looks for a property within a named property list on the signing result.  If the list does not exist, or the property\n does not exist within the list, *out_value will be set to NULL.\n\n @param result signing result to query\n @param list_name name of the list of key-value pairs to search through for the property\n @param property_name name of the property to search for within the list\n @param out_value output parameter for the property value, if found\n"]
    pub fn aws_signing_result_get_property_value_in_property_list(
        result: *const aws_signing_result,
        list_name: *const aws_string,
        property_name: *const aws_string,
        out_value: *mut *mut aws_string,
    );
    #[doc = " (Asynchronous) entry point to sign something (a request, a chunk, an event) with an AWS signing process.\n Depending on the configuration, the signing process may or may not complete synchronously.\n\n @param allocator memory allocator to use throughout the signing process\n @param signable the thing to be signed.  See signable.h for common constructors for signables that\n wrap different types.\n @param base_config pointer to a signing configuration, currently this must be of type aws_signing_config_aws\n @param on_complete completion callback to be invoked when signing has finished\n @param user_data opaque user data that will be passed to the completion callback\n\n @return AWS_OP_SUCCESS if the signing attempt was *initiated* successfully, AWS_OP_ERR otherwise"]
    pub fn aws_sign_request_aws(
        allocator: *mut aws_allocator,
        signable: *const aws_signable,
        base_config: *const aws_signing_config_base,
        on_complete: aws_signing_complete_fn,
        userdata: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
}
