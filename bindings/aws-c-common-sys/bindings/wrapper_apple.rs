/* automatically generated by rust-bindgen 0.69.1 */

#[doc = " @deprecated Use int64_t instead for offsets in public APIs."]
pub type aws_off_t = i64;
pub type aws_mem_trace_level = ::core::ffi::c_uint;
pub type aws_error_handler_fn = ::core::option::Option<
    unsafe extern "C" fn(err: ::core::ffi::c_int, ctx: *mut ::core::ffi::c_void),
>;
pub type aws_common_error = ::core::ffi::c_uint;
#[doc = " Prototype for a comparator function for sorting elements.\n\n a and b should be cast to pointers to the element type held in the list\n before being dereferenced. The function should compare the elements and\n return a positive number if a > b, zero if a = b, and a negative number\n if a < b."]
pub type aws_array_list_comparator_fn = ::core::option::Option<
    unsafe extern "C" fn(
        a: *const ::core::ffi::c_void,
        b: *const ::core::ffi::c_void,
    ) -> ::core::ffi::c_int,
>;
pub type aws_memory_order = ::core::ffi::c_uint;
pub type aws_atomic_impl_int_t = usize;
#[doc = " Signature for function argument to trim APIs"]
pub type aws_byte_predicate_fn = ::core::option::Option<unsafe extern "C" fn(value: u8) -> bool>;
pub type aws_hash_iter_status = ::core::ffi::c_uint;
#[doc = " Prototype for a key hashing function pointer."]
pub type aws_hash_fn =
    ::core::option::Option<unsafe extern "C" fn(key: *const ::core::ffi::c_void) -> u64>;
#[doc = " Prototype for a hash table equality check function pointer.\n\n This type is usually used for a function that compares two hash table\n keys, but note that the same type is used for a function that compares\n two hash table values in aws_hash_table_eq.\n\n Equality functions used in a hash table must be be reflexive (a == a),\n symmetric (a == b => b == a), transitive (a == b, b == c => a == c)\n and consistent (result does not change with time)."]
pub type aws_hash_callback_eq_fn = ::core::option::Option<
    unsafe extern "C" fn(a: *const ::core::ffi::c_void, b: *const ::core::ffi::c_void) -> bool,
>;
#[doc = " Prototype for a hash table key or value destructor function pointer.\n\n This function is used to destroy elements in the hash table when the\n table is cleared or cleaned up.\n\n Note that functions which remove individual elements from the hash\n table provide options of whether or not to invoke the destructors\n on the key and value of a removed element."]
pub type aws_hash_callback_destroy_fn =
    ::core::option::Option<unsafe extern "C" fn(key_or_value: *mut ::core::ffi::c_void)>;
pub type aws_timestamp_unit = ::core::ffi::c_uint;
pub type aws_cli_options_has_arg = ::core::ffi::c_uint;
#[doc = " Invoked when a subcommand is encountered. argc and argv[] begins at the command encountered.\n command_name is the name of the command being handled."]
pub type aws_cli_options_subcommand_fn = ::core::option::Option<
    unsafe extern "C" fn(
        argc: ::core::ffi::c_int,
        argv: *const [*mut ::core::ffi::c_char; 0usize],
        command_name: *const ::core::ffi::c_char,
        user_data: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int,
>;
pub type aws_condition_predicate_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void) -> bool>;
pub type aws_cpu_feature_name = ::core::ffi::c_uint;
pub type aws_date_format = ::core::ffi::c_uint;
pub type aws_date_month = ::core::ffi::c_uint;
pub type aws_date_day_of_week = ::core::ffi::c_uint;
pub type aws_text_encoding = ::core::ffi::c_uint;
pub type aws_file_type = ::core::ffi::c_uint;
#[doc = " Invoked during calls to aws_directory_traverse() as an entry is encountered. entry will contain\n the parsed directory entry info.\n\n Return true to continue the traversal, or alternatively, if you have a reason to abort the traversal, return false."]
pub type aws_on_directory_entry = ::core::option::Option<
    unsafe extern "C" fn(
        entry: *const aws_directory_entry,
        user_data: *mut ::core::ffi::c_void,
    ) -> bool,
>;
#[doc = " @brief callback for iterating members of an object\n Iteration can be controlled as follows:\n - return AWS_OP_SUCCESS and out_should_continue is set to true (default value) -\n   continue iteration without error\n - return AWS_OP_SUCCESS and out_continue is set to false -\n   stop iteration without error\n - return AWS_OP_ERR - stop iteration with error"]
pub type aws_json_on_member_encountered_const_fn = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const aws_byte_cursor,
        value: *const aws_json_value,
        out_should_continue: *mut bool,
        user_data: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int,
>;
#[doc = " @brief callback for iterating values of an array.\n Iteration can be controlled as follows:\n - return AWS_OP_SUCCESS and out_should_continue is set to true (default value) -\n   continue iteration without error\n - return AWS_OP_SUCCESS and out_continue is set to false -\n   stop iteration without error\n - return AWS_OP_ERR - stop iteration with error"]
pub type aws_json_on_value_encountered_const_fn = ::core::option::Option<
    unsafe extern "C" fn(
        index: usize,
        value: *const aws_json_value,
        out_should_continue: *mut bool,
        user_data: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int,
>;
pub type aws_thread_detach_state = ::core::ffi::c_uint;
#[doc = " Specifies the join strategy used on an aws_thread, which in turn controls whether or not a thread participates\n in the managed thread system.  The managed thread system provides logic to guarantee a join on all participating\n threads at the cost of laziness (the user cannot control when joins happen).\n\n Manual - thread does not participate in the managed thread system; any joins must be done by the user.  This\n is the default.  The user must call aws_thread_clean_up(), but only after any desired join operation has completed.\n Not doing so will cause the windows handle to leak.\n\n Managed - the managed thread system will automatically perform a join some time after the thread's run function\n has completed.  It is an error to call aws_thread_join on a thread configured with the managed join strategy.  The\n managed thread system will call aws_thread_clean_up() on the thread after the background join has completed.\n\n Additionally, an API exists, aws_thread_join_all_managed(), which blocks and returns when all outstanding threads\n with the managed strategy have fully joined.  This API is useful for tests (rather than waiting for many individual\n signals) and program shutdown or DLL unload.  This API is automatically invoked by the common library clean up\n function.  If the common library clean up is called from a managed thread, this will cause deadlock.\n\n Lazy thread joining is done only when threads finish their run function or when the user calls\n aws_thread_join_all_managed().  This means it may be a long time between thread function completion and the join\n being applied, but the queue of unjoined threads is always one or fewer so there is no critical resource\n backlog.\n\n Currently, only event loop group async cleanup and host resolver threads participate in the managed thread system.\n Additionally, event loop threads will increment and decrement the pending join count (they are manually joined\n internally) in order to have an accurate view of internal thread usage and also to prevent failure to release\n an event loop group fully from allowing aws_thread_join_all_managed() from running to completion when its\n intent is such that it should block instead."]
pub type aws_thread_join_strategy = ::core::ffi::c_uint;
pub type aws_thread_once = [u64; 2usize];
pub type aws_thread_id_t = pthread_t;
pub type aws_thread_atexit_fn =
    ::core::option::Option<unsafe extern "C" fn(user_data: *mut ::core::ffi::c_void)>;
#[doc = " Controls what log calls pass through the logger and what log calls get filtered out.\n If a log level has a value of X, then all log calls using a level <= X will appear, while\n those using a value > X will not occur.\n\n You can filter both dynamically (by setting the log level on the logger object) or statically\n (by defining AWS_STATIC_LOG_LEVEL to be an appropriate integer module-wide).  Statically filtered\n log calls will be completely compiled out but require a rebuild if you want to get more detail\n about what's happening."]
pub type aws_log_level = ::core::ffi::c_uint;
#[doc = " Log subject is a way of designating the topic of logging.\n\n The general idea is to support a finer-grained approach to log level control.  The primary use case\n is for situations that require more detailed logging within a specific domain, where enabling that detail\n globally leads to an untenable flood of information.\n\n For example, enable TRACE logging for tls-related log statements (handshake binary payloads), but\n only WARN logging everywhere else (because http payloads would blow up the log files).\n\n Log subject is an enum similar to aws error: each library has its own value-space and someone is\n responsible for registering the value <-> string connections."]
pub type aws_log_subject_t = u32;
pub type aws_common_log_subject = ::core::ffi::c_uint;
pub type aws_log_channel_send_fn = ::core::option::Option<
    unsafe extern "C" fn(
        channel: *mut aws_log_channel,
        output: *mut aws_string,
    ) -> ::core::ffi::c_int,
>;
pub type aws_log_channel_clean_up_fn =
    ::core::option::Option<unsafe extern "C" fn(channel: *mut aws_log_channel)>;
pub type aws_log_formatter_clean_up_fn =
    ::core::option::Option<unsafe extern "C" fn(logger: *mut aws_log_formatter)>;
pub type aws_log_writer_write_fn = ::core::option::Option<
    unsafe extern "C" fn(
        writer: *mut aws_log_writer,
        output: *const aws_string,
    ) -> ::core::ffi::c_int,
>;
pub type aws_log_writer_clean_up_fn =
    ::core::option::Option<unsafe extern "C" fn(writer: *mut aws_log_writer)>;
pub type aws_priority_queue_compare_fn = ::core::option::Option<
    unsafe extern "C" fn(
        a: *const ::core::ffi::c_void,
        b: *const ::core::ffi::c_void,
    ) -> ::core::ffi::c_int,
>;
pub type aws_simple_completion_callback =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>;
pub type aws_crt_statistics_category_t = u32;
#[doc = " The common-specific range of the aws_crt_statistics_category cross-library enum.\n\n This enum functions as an RTTI value that lets statistics handler's interpret (via cast) a\n specific statistics structure if the RTTI value is understood.\n\n Common doesn't have any statistics structures presently, so its range is essentially empty.\n"]
pub type aws_crt_common_statistics_category = ::core::ffi::c_uint;
pub type aws_crt_statistics_handler_process_statistics_fn = ::core::option::Option<
    unsafe extern "C" fn(
        handler: *mut aws_crt_statistics_handler,
        interval: *mut aws_crt_statistics_sample_interval,
        stats: *mut aws_array_list,
        context: *mut ::core::ffi::c_void,
    ),
>;
pub type aws_crt_statistics_handler_destroy_fn =
    ::core::option::Option<unsafe extern "C" fn(handler: *mut aws_crt_statistics_handler)>;
pub type aws_crt_statistics_handler_get_report_interval_ms_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut aws_crt_statistics_handler) -> u64>;
pub type aws_platform_os = ::core::ffi::c_uint;
pub type aws_task_status = ::core::ffi::c_uint;
#[doc = " A scheduled function."]
pub type aws_task_fn = ::core::option::Option<
    unsafe extern "C" fn(task: *mut aws_task, arg: *mut ::core::ffi::c_void, arg1: aws_task_status),
>;
#[doc = " Callback for when an xml node is encountered in the document. As a user you have a few options:\n\n 1. fail the parse by returning AWS_OP_ERR (after an error has been raised). This will stop any further parsing.\n 2. call aws_xml_node_traverse() on the node to descend into the node with a new callback and user_data.\n 3. call aws_xml_node_as_body() to retrieve the contents of the node as text.\n\n You MUST NOT call both aws_xml_node_traverse() and aws_xml_node_as_body() on the same node.\n\n return true to continue the parsing operation."]
pub type aws_xml_parser_on_node_encountered_fn = ::core::option::Option<
    unsafe extern "C" fn(
        node: *mut aws_xml_node,
        user_data: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_allocator {
    pub mem_acquire: ::core::option::Option<
        unsafe extern "C" fn(
            allocator: *mut aws_allocator,
            size: usize,
        ) -> *mut ::core::ffi::c_void,
    >,
    pub mem_release: ::core::option::Option<
        unsafe extern "C" fn(allocator: *mut aws_allocator, ptr: *mut ::core::ffi::c_void),
    >,
    pub mem_realloc: ::core::option::Option<
        unsafe extern "C" fn(
            allocator: *mut aws_allocator,
            oldptr: *mut ::core::ffi::c_void,
            oldsize: usize,
            newsize: usize,
        ) -> *mut ::core::ffi::c_void,
    >,
    pub mem_calloc: ::core::option::Option<
        unsafe extern "C" fn(
            allocator: *mut aws_allocator,
            num: usize,
            size: usize,
        ) -> *mut ::core::ffi::c_void,
    >,
    pub impl_: *mut ::core::ffi::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_error_info {
    pub error_code: ::core::ffi::c_int,
    pub literal_name: *const ::core::ffi::c_char,
    pub error_str: *const ::core::ffi::c_char,
    pub lib_name: *const ::core::ffi::c_char,
    pub formatted_name: *const ::core::ffi::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_error_info_list {
    pub error_list: *const aws_error_info,
    pub count: u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_array_list {
    pub alloc: *mut aws_allocator,
    pub current_size: usize,
    pub length: usize,
    pub item_size: usize,
    pub data: *mut ::core::ffi::c_void,
}
#[doc = " struct aws_atomic_var represents an atomic variable - a value which can hold an integer or pointer\n that can be manipulated atomically. struct aws_atomic_vars should normally only be manipulated\n with atomics methods defined in this header."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_atomic_var {
    pub value: *mut ::core::ffi::c_void,
}
#[doc = " Represents a length-delimited binary string or buffer. If byte buffer points\n to constant memory or memory that should otherwise not be freed by this\n struct, set allocator to NULL and free function will be a no-op.\n\n This structure used to define the output for all functions that write to a buffer.\n\n Note that this structure allocates memory at the buffer pointer only. The\n struct itself does not get dynamically allocated and must be either\n maintained or copied to avoid losing access to the memory."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_byte_buf {
    pub len: usize,
    pub buffer: *mut u8,
    pub capacity: usize,
    pub allocator: *mut aws_allocator,
}
#[doc = " Represents a movable pointer within a larger binary string or buffer.\n\n This structure is used to define buffers for reading."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_byte_cursor {
    pub len: usize,
    pub ptr: *mut u8,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct aws_hash_table {
    pub _bindgen_opaque_blob: u64,
}
#[doc = " Represents an element in the hash table. Various operations on the hash\n table may provide pointers to elements stored within the hash table;\n generally, calling code may alter value, but must not alter key (or any\n information used to compute key's hash code).\n\n Pointers to elements within the hash are invalidated whenever an operation\n which may change the number of elements in the hash is invoked (i.e. put,\n delete, clear, and clean_up), regardless of whether the number of elements\n actually changes."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_hash_element {
    pub key: *const ::core::ffi::c_void,
    pub value: *mut ::core::ffi::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_hash_iter {
    pub map: *const aws_hash_table,
    pub element: aws_hash_element,
    pub slot: usize,
    pub limit: usize,
    pub status: aws_hash_iter_status,
    pub unused_0: ::core::ffi::c_int,
    pub unused_1: *mut ::core::ffi::c_void,
    pub unused_2: *mut ::core::ffi::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_linked_list_node {
    pub next: *mut aws_linked_list_node,
    pub prev: *mut aws_linked_list_node,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_linked_list {
    pub head: aws_linked_list_node,
    pub tail: aws_linked_list_node,
}
#[doc = " Simple linked hash table. Preserves insertion order, and can be iterated in insertion order.\n\n You can also change the order safely without altering the shape of the underlying hash table."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_linked_hash_table {
    pub allocator: *mut aws_allocator,
    pub list: aws_linked_list,
    pub table: aws_hash_table,
    pub user_on_value_destroy: aws_hash_callback_destroy_fn,
    pub user_on_key_destroy: aws_hash_callback_destroy_fn,
}
#[doc = " Linked-List node stored in the table. This is the node type that will be returned in\n aws_linked_hash_table_get_iteration_list()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_linked_hash_table_node {
    pub node: aws_linked_list_node,
    pub table: *mut aws_linked_hash_table,
    pub key: *const ::core::ffi::c_void,
    pub value: *mut ::core::ffi::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_cache_vtable {
    pub destroy: ::core::option::Option<unsafe extern "C" fn(cache: *mut aws_cache)>,
    pub find: ::core::option::Option<
        unsafe extern "C" fn(
            cache: *mut aws_cache,
            key: *const ::core::ffi::c_void,
            p_value: *mut *mut ::core::ffi::c_void,
        ) -> ::core::ffi::c_int,
    >,
    pub put: ::core::option::Option<
        unsafe extern "C" fn(
            cache: *mut aws_cache,
            key: *const ::core::ffi::c_void,
            p_value: *mut ::core::ffi::c_void,
        ) -> ::core::ffi::c_int,
    >,
    pub remove: ::core::option::Option<
        unsafe extern "C" fn(
            cache: *mut aws_cache,
            key: *const ::core::ffi::c_void,
        ) -> ::core::ffi::c_int,
    >,
    pub clear: ::core::option::Option<unsafe extern "C" fn(cache: *mut aws_cache)>,
    pub get_element_count:
        ::core::option::Option<unsafe extern "C" fn(cache: *const aws_cache) -> usize>,
}
#[doc = " Base stucture for caches, used the linked hash table implementation."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_cache {
    pub allocator: *mut aws_allocator,
    pub vtable: *const aws_cache_vtable,
    pub table: aws_linked_hash_table,
    pub max_items: usize,
    pub impl_: *mut ::core::ffi::c_void,
}
#[doc = " Dispatch table to dispatch cli commands from.\n command_name should be the exact string for the command you want to handle from the command line."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_cli_subcommand_dispatch {
    pub subcommand_fn: aws_cli_options_subcommand_fn,
    pub command_name: *const ::core::ffi::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_cli_option {
    pub name: *const ::core::ffi::c_char,
    pub has_arg: aws_cli_options_has_arg,
    pub flag: *mut ::core::ffi::c_int,
    pub val: ::core::ffi::c_int,
}
#[repr(C)]
pub struct aws_condition_variable {
    pub condition_handle: pthread_cond_t,
    pub initialized: bool,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_cross_process_lock {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct aws_date_time {
    pub timestamp: time_t,
    pub milliseconds: u16,
    pub tz: [::core::ffi::c_char; 6usize],
    pub gmt_time: tm,
    pub local_time: tm,
    pub utc_assumed: bool,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_utf8_decoder_options {
    #[doc = " Optional.\n Callback invoked for each Unicode codepoint.\n Use this callback to store codepoints as they're decoded,\n or to perform additional validation. RFC-3629 is already enforced,\n which forbids codepoints between U+D800 and U+DFFF,\n but you may whish to forbid codepoints like U+0000.\n\n @return AWS_OP_SUCCESS to continue processing the string, otherwise\n return AWS_OP_ERROR and raise an error (i.e. AWS_ERROR_INVALID_UTF8)\n to stop processing the string and report failure."]
    pub on_codepoint: ::core::option::Option<
        unsafe extern "C" fn(
            codepoint: u32,
            user_data: *mut ::core::ffi::c_void,
        ) -> ::core::ffi::c_int,
    >,
    pub user_data: *mut ::core::ffi::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_utf8_decoder {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_directory_iterator {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_directory_entry {
    #[doc = " Absolute path to the entry from the current process root."]
    pub path: aws_byte_cursor,
    #[doc = " Path to the entry relative to the current working directory."]
    pub relative_path: aws_byte_cursor,
    #[doc = " Bit-field of enum aws_file_type"]
    pub file_type: ::core::ffi::c_int,
    #[doc = " Size of the file on disk."]
    pub file_size: i64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_json_value {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_string {
    pub allocator: *mut aws_allocator,
    pub len: usize,
    pub bytes: [u8; 1usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_thread_options {
    pub stack_size: usize,
    pub cpu_id: i32,
    pub join_strategy: aws_thread_join_strategy,
    #[doc = " Thread name, for debugging purpose.\n The length should not exceed AWS_THREAD_NAME_RECOMMENDED_STRLEN(15)\n if you want it to display properly on all platforms."]
    pub name: aws_byte_cursor,
}
#[repr(C)]
pub struct aws_thread {
    pub allocator: *mut aws_allocator,
    pub detach_state: aws_thread_detach_state,
    pub thread_id: aws_thread_id_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_log_subject_info {
    pub subject_id: aws_log_subject_t,
    pub subject_name: *const ::core::ffi::c_char,
    pub subject_description: *const ::core::ffi::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_log_subject_info_list {
    pub subject_list: *mut aws_log_subject_info,
    pub count: usize,
}
#[doc = " We separate the log level function from the log call itself so that we can do the filter check in the macros (see\n below)\n\n By doing so, we make it so that the variadic format arguments are not even evaluated if the filter check does not\n succeed."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_logger_vtable {
    pub log: ::core::option::Option<
        unsafe extern "C" fn(
            logger: *mut aws_logger,
            log_level: aws_log_level,
            subject: aws_log_subject_t,
            format: *const ::core::ffi::c_char,
            ...
        ) -> ::core::ffi::c_int,
    >,
    pub get_log_level: ::core::option::Option<
        unsafe extern "C" fn(logger: *mut aws_logger, subject: aws_log_subject_t) -> aws_log_level,
    >,
    pub clean_up: ::core::option::Option<unsafe extern "C" fn(logger: *mut aws_logger)>,
    pub set_log_level: ::core::option::Option<
        unsafe extern "C" fn(logger: *mut aws_logger, arg1: aws_log_level) -> ::core::ffi::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_logger {
    pub vtable: *mut aws_logger_vtable,
    pub allocator: *mut aws_allocator,
    pub p_impl: *mut ::core::ffi::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_logger_pipeline {
    pub formatter: *mut aws_log_formatter,
    pub channel: *mut aws_log_channel,
    pub writer: *mut aws_log_writer,
    pub allocator: *mut aws_allocator,
    pub level: aws_atomic_var,
}
#[doc = " Options for aws_logger_init_standard().\n Set `filename` to open a file for logging and close it when the logger cleans up.\n Set `file` to use a file that is already open, such as `stderr` or `stdout`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_logger_standard_options {
    pub level: aws_log_level,
    pub filename: *const ::core::ffi::c_char,
    pub file: *mut FILE,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_log_channel_vtable {
    pub send: aws_log_channel_send_fn,
    pub clean_up: aws_log_channel_clean_up_fn,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_log_channel {
    pub vtable: *mut aws_log_channel_vtable,
    pub allocator: *mut aws_allocator,
    pub writer: *mut aws_log_writer,
    pub impl_: *mut ::core::ffi::c_void,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct aws_log_formatter_vtable {
    pub _bindgen_opaque_blob: [u64; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_log_formatter {
    pub vtable: *mut aws_log_formatter_vtable,
    pub allocator: *mut aws_allocator,
    pub impl_: *mut ::core::ffi::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_log_formatter_standard_options {
    pub date_format: aws_date_format,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_logging_standard_formatting_data {
    pub log_line_buffer: *mut ::core::ffi::c_char,
    pub total_length: usize,
    pub level: aws_log_level,
    pub subject_name: *const ::core::ffi::c_char,
    pub format: *const ::core::ffi::c_char,
    pub date_format: aws_date_format,
    pub allocator: *mut aws_allocator,
    pub amount_written: usize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_log_writer_vtable {
    pub write: aws_log_writer_write_fn,
    pub clean_up: aws_log_writer_clean_up_fn,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_log_writer {
    pub vtable: *mut aws_log_writer_vtable,
    pub allocator: *mut aws_allocator,
    pub impl_: *mut ::core::ffi::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_log_writer_file_options {
    pub filename: *const ::core::ffi::c_char,
    pub file: *mut FILE,
}
#[repr(C)]
pub struct aws_mutex {
    pub mutex_handle: pthread_mutex_t,
    pub initialized: bool,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_priority_queue {
    #[doc = " predicate that determines the priority of the elements in the queue."]
    pub pred: aws_priority_queue_compare_fn,
    #[doc = " The underlying container storing the queue elements."]
    pub container: aws_array_list,
    #[doc = " An array of pointers to backpointer elements. This array is initialized when\n the first call to aws_priority_queue_push_bp is made, and is subsequently maintained\n through any heap node manipulations.\n\n Each element is a struct aws_priority_queue_node *, pointing to a backpointer field\n owned by the calling code, or a NULL. The backpointer field is continually updated\n with information needed to locate and remove a specific node later on."]
    pub backpointers: aws_array_list,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_priority_queue_node {
    #[doc = " The current index of the node in question, or SIZE_MAX if the node has been removed."]
    pub current_index: usize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_run_command_result {
    pub ret_code: ::core::ffi::c_int,
    #[doc = " captured stdout message from running the command,\n caller is responsible for releasing the memory."]
    pub std_out: *mut aws_string,
    #[doc = " captured stderr message from running the command,\n caller is responsible for releasing the memory.\n It's currently not implemented and the value will be set to NULL."]
    pub std_err: *mut aws_string,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_run_command_options {
    #[doc = " command path and commandline options of running that command."]
    pub command: *const ::core::ffi::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_promise {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_ref_count {
    pub ref_count: aws_atomic_var,
    pub object: *mut ::core::ffi::c_void,
    pub on_zero_fn: aws_simple_completion_callback,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_shutdown_callback_options {
    pub shutdown_callback_fn: aws_simple_completion_callback,
    pub shutdown_callback_user_data: *mut ::core::ffi::c_void,
}
#[doc = " Lockless ring buffer implementation that is thread safe assuming a single thread acquires and a single thread\n releases. For any other use case (other than the single-threaded use-case), you must manage thread-safety manually.\n\n Also, a very important note: release must happen in the same order as acquire. If you do not your application, and\n possibly computers within a thousand mile radius, may die terrible deaths, and the local drinking water will be\n poisoned for generations with fragments of what is left of your radioactive corrupted memory."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_ring_buffer {
    pub allocator: *mut aws_allocator,
    pub allocation: *mut u8,
    pub head: aws_atomic_var,
    pub tail: aws_atomic_var,
    pub allocation_end: *mut u8,
}
#[repr(C)]
pub struct aws_rw_lock {
    pub lock_handle: pthread_rwlock_t,
}
#[doc = " Pattern-struct that functions as a base \"class\" for all statistics structures.  To conform\n to the pattern, a statistics structure must have its first member be the category.  In that\n case it becomes \"safe\" to cast from aws_crt_statistics_base to the specific statistics structure\n based on the category value."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_crt_statistics_base {
    pub category: aws_crt_statistics_category_t,
}
#[doc = " The start and end time, in milliseconds-since-epoch, that a set of statistics was gathered over."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_crt_statistics_sample_interval {
    pub begin_time_ms: u64,
    pub end_time_ms: u64,
}
#[doc = " Vtable for functions that all statistics handlers must implement"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_crt_statistics_handler_vtable {
    pub process_statistics: aws_crt_statistics_handler_process_statistics_fn,
    pub destroy: aws_crt_statistics_handler_destroy_fn,
    pub get_report_interval_ms: aws_crt_statistics_handler_get_report_interval_ms_fn,
}
#[doc = " Base structure for all statistics handler implementations.\n\n A statistics handler is an object that listens to a stream of polymorphic (via the category RTTI enum) statistics\n structures emitted from some arbitrary source.  In the initial implementation, statistics handlers are primarily\n attached to channels, where they monitor IO throughput and state data (from channel handlers) to determine a\n connection's health.\n\n Statistics handlers are a generalization of the timeout and bandwidth filters that are often associated with\n SDK network connections.  Configurable, default implementations are defined at the protocol level (http, etc...)\n where they can be attached at connection (channel) creation time."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_crt_statistics_handler {
    pub vtable: *mut aws_crt_statistics_handler_vtable,
    pub allocator: *mut aws_allocator,
    pub impl_: *mut ::core::ffi::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_cpu_info {
    pub cpu_id: i32,
    pub suspected_hyper_thread: bool,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_system_environment {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_memory_usage_stats {
    pub maxrss: usize,
    pub page_faults: usize,
    pub _reserved: [usize; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aws_task {
    pub fn_: aws_task_fn,
    pub arg: *mut ::core::ffi::c_void,
    pub timestamp: u64,
    pub node: aws_linked_list_node,
    pub priority_queue_node: aws_priority_queue_node,
    pub type_tag: *const ::core::ffi::c_char,
    pub abi_extension: aws_task__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_task_scheduler {
    pub alloc: *mut aws_allocator,
    pub timed_queue: aws_priority_queue,
    pub timed_list: aws_linked_list,
    pub asap_list: aws_linked_list,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_thread_scheduler {
    _unused: [u8; 0],
}
#[doc = " Data representing a URI. uri_str is always allocated and filled in.\n The other portions are merely storing offsets into uri_str."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_uri {
    pub self_size: usize,
    pub allocator: *mut aws_allocator,
    pub uri_str: aws_byte_buf,
    pub scheme: aws_byte_cursor,
    pub authority: aws_byte_cursor,
    pub userinfo: aws_byte_cursor,
    pub user: aws_byte_cursor,
    pub password: aws_byte_cursor,
    pub host_name: aws_byte_cursor,
    pub port: u32,
    pub path: aws_byte_cursor,
    pub query_string: aws_byte_cursor,
    pub path_and_query: aws_byte_cursor,
}
#[doc = " key/value pairs for a query string. If the query fragment was not in format key=value, the fragment value\n will be stored in key"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_uri_param {
    pub key: aws_byte_cursor,
    pub value: aws_byte_cursor,
}
#[doc = " Arguments for building a URI instance. All members must\n be initialized before passing them to aws_uri_init().\n\n query_string and query_params are exclusive to each other. If you set\n query_string, do not prepend it with '?'"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_uri_builder_options {
    pub scheme: aws_byte_cursor,
    pub path: aws_byte_cursor,
    pub host_name: aws_byte_cursor,
    pub port: u32,
    pub query_params: *mut aws_array_list,
    pub query_string: aws_byte_cursor,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_uuid {
    pub uuid_data: [u8; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_xml_node {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_xml_attribute {
    pub name: aws_byte_cursor,
    pub value: aws_byte_cursor,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_xml_parser_options {
    pub doc: aws_byte_cursor,
    pub max_depth: usize,
    pub on_root_encountered: aws_xml_parser_on_node_encountered_fn,
    pub user_data: *mut ::core::ffi::c_void,
}
pub const AWS_PACKAGE_SLOTS: u32 = 16;
pub const AWS_C_COMMON_PACKAGE_ID: u32 = 0;
pub const AWS_OP_SUCCESS: u32 = 0;
pub const AWS_OP_ERR: i32 = -1;
pub const AWS_ERROR_ENUM_STRIDE_BITS: u32 = 10;
pub const AWS_ERROR_ENUM_STRIDE: u32 = 1024;
pub const AWS_PATH_DELIM: u8 = 47u8;
#[allow(unsafe_code)]
pub const AWS_PATH_DELIM_STR: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"/\0") };
pub const AWS_THREAD_NAME_RECOMMENDED_STRLEN: u32 = 15;
pub const AWS_LOG_LEVEL_NONE: u32 = 0;
pub const AWS_LOG_LEVEL_FATAL: u32 = 1;
pub const AWS_LOG_LEVEL_ERROR: u32 = 2;
pub const AWS_LOG_LEVEL_WARN: u32 = 3;
pub const AWS_LOG_LEVEL_INFO: u32 = 4;
pub const AWS_LOG_LEVEL_DEBUG: u32 = 5;
pub const AWS_LOG_LEVEL_TRACE: u32 = 6;
pub const AWS_MEMTRACE_NONE: aws_mem_trace_level = 0;
pub const AWS_MEMTRACE_BYTES: aws_mem_trace_level = 1;
pub const AWS_MEMTRACE_STACKS: aws_mem_trace_level = 2;
pub const AWS_ERROR_SUCCESS: aws_common_error = 0;
pub const AWS_ERROR_OOM: aws_common_error = 1;
pub const AWS_ERROR_NO_SPACE: aws_common_error = 2;
pub const AWS_ERROR_UNKNOWN: aws_common_error = 3;
pub const AWS_ERROR_SHORT_BUFFER: aws_common_error = 4;
pub const AWS_ERROR_OVERFLOW_DETECTED: aws_common_error = 5;
pub const AWS_ERROR_UNSUPPORTED_OPERATION: aws_common_error = 6;
pub const AWS_ERROR_INVALID_BUFFER_SIZE: aws_common_error = 7;
pub const AWS_ERROR_INVALID_HEX_STR: aws_common_error = 8;
pub const AWS_ERROR_INVALID_BASE64_STR: aws_common_error = 9;
pub const AWS_ERROR_INVALID_INDEX: aws_common_error = 10;
pub const AWS_ERROR_THREAD_INVALID_SETTINGS: aws_common_error = 11;
pub const AWS_ERROR_THREAD_INSUFFICIENT_RESOURCE: aws_common_error = 12;
pub const AWS_ERROR_THREAD_NO_PERMISSIONS: aws_common_error = 13;
pub const AWS_ERROR_THREAD_NOT_JOINABLE: aws_common_error = 14;
pub const AWS_ERROR_THREAD_NO_SUCH_THREAD_ID: aws_common_error = 15;
pub const AWS_ERROR_THREAD_DEADLOCK_DETECTED: aws_common_error = 16;
pub const AWS_ERROR_MUTEX_NOT_INIT: aws_common_error = 17;
pub const AWS_ERROR_MUTEX_TIMEOUT: aws_common_error = 18;
pub const AWS_ERROR_MUTEX_CALLER_NOT_OWNER: aws_common_error = 19;
pub const AWS_ERROR_MUTEX_FAILED: aws_common_error = 20;
pub const AWS_ERROR_COND_VARIABLE_INIT_FAILED: aws_common_error = 21;
pub const AWS_ERROR_COND_VARIABLE_TIMED_OUT: aws_common_error = 22;
pub const AWS_ERROR_COND_VARIABLE_ERROR_UNKNOWN: aws_common_error = 23;
pub const AWS_ERROR_CLOCK_FAILURE: aws_common_error = 24;
pub const AWS_ERROR_LIST_EMPTY: aws_common_error = 25;
pub const AWS_ERROR_DEST_COPY_TOO_SMALL: aws_common_error = 26;
pub const AWS_ERROR_LIST_EXCEEDS_MAX_SIZE: aws_common_error = 27;
pub const AWS_ERROR_LIST_STATIC_MODE_CANT_SHRINK: aws_common_error = 28;
pub const AWS_ERROR_PRIORITY_QUEUE_FULL: aws_common_error = 29;
pub const AWS_ERROR_PRIORITY_QUEUE_EMPTY: aws_common_error = 30;
pub const AWS_ERROR_PRIORITY_QUEUE_BAD_NODE: aws_common_error = 31;
pub const AWS_ERROR_HASHTBL_ITEM_NOT_FOUND: aws_common_error = 32;
pub const AWS_ERROR_INVALID_DATE_STR: aws_common_error = 33;
pub const AWS_ERROR_INVALID_ARGUMENT: aws_common_error = 34;
pub const AWS_ERROR_RANDOM_GEN_FAILED: aws_common_error = 35;
pub const AWS_ERROR_MALFORMED_INPUT_STRING: aws_common_error = 36;
pub const AWS_ERROR_UNIMPLEMENTED: aws_common_error = 37;
pub const AWS_ERROR_INVALID_STATE: aws_common_error = 38;
pub const AWS_ERROR_ENVIRONMENT_GET: aws_common_error = 39;
pub const AWS_ERROR_ENVIRONMENT_SET: aws_common_error = 40;
pub const AWS_ERROR_ENVIRONMENT_UNSET: aws_common_error = 41;
pub const AWS_ERROR_STREAM_UNSEEKABLE: aws_common_error = 42;
pub const AWS_ERROR_NO_PERMISSION: aws_common_error = 43;
pub const AWS_ERROR_FILE_INVALID_PATH: aws_common_error = 44;
pub const AWS_ERROR_MAX_FDS_EXCEEDED: aws_common_error = 45;
pub const AWS_ERROR_SYS_CALL_FAILURE: aws_common_error = 46;
pub const AWS_ERROR_C_STRING_BUFFER_NOT_NULL_TERMINATED: aws_common_error = 47;
pub const AWS_ERROR_STRING_MATCH_NOT_FOUND: aws_common_error = 48;
pub const AWS_ERROR_DIVIDE_BY_ZERO: aws_common_error = 49;
pub const AWS_ERROR_INVALID_FILE_HANDLE: aws_common_error = 50;
pub const AWS_ERROR_OPERATION_INTERUPTED: aws_common_error = 51;
pub const AWS_ERROR_DIRECTORY_NOT_EMPTY: aws_common_error = 52;
pub const AWS_ERROR_PLATFORM_NOT_SUPPORTED: aws_common_error = 53;
pub const AWS_ERROR_INVALID_UTF8: aws_common_error = 54;
pub const AWS_ERROR_GET_HOME_DIRECTORY_FAILED: aws_common_error = 55;
pub const AWS_ERROR_INVALID_XML: aws_common_error = 56;
pub const AWS_ERROR_FILE_OPEN_FAILURE: aws_common_error = 57;
pub const AWS_ERROR_FILE_READ_FAILURE: aws_common_error = 58;
pub const AWS_ERROR_FILE_WRITE_FAILURE: aws_common_error = 59;
pub const AWS_ERROR_END_COMMON_RANGE: aws_common_error = 1023;
#[doc = " No particular ordering constraints are guaranteed relative to other\n operations at all; we merely ensure that the operation itself is atomic."]
pub const aws_memory_order_relaxed: aws_memory_order = 0;
#[doc = " Specifies acquire ordering. No reads or writes on the current thread can be\n reordered to happen before this operation. This is typically paired with a release\n ordering; any writes that happened on the releasing operation will be visible\n after the paired acquire operation.\n\n Acquire ordering is only meaningful on load or load-store operations."]
pub const aws_memory_order_acquire: aws_memory_order = 2;
#[doc = " Specifies release order. No reads or writes can be reordered to come after this\n operation. Typically paired with an acquire operation.\n\n Release ordering is only meaningful on store or load-store operations."]
pub const aws_memory_order_release: aws_memory_order = 3;
#[doc = " Specifies acquire-release order; if this operation acts as a load, it acts as an\n acquire operation; if it acts as a store, it acts as a release operation; if it's\n a load-store, it does both."]
pub const aws_memory_order_acq_rel: aws_memory_order = 4;
#[doc = " Specifies acquire-release order; if this operation acts as a load, it acts as an\n acquire operation; if it acts as a store, it acts as a release operation; if it's\n a load-store, it does both."]
pub const aws_memory_order_seq_cst: aws_memory_order = 5;
pub const AWS_HASH_ITER_STATUS_DONE: aws_hash_iter_status = 0;
pub const AWS_HASH_ITER_STATUS_DELETE_CALLED: aws_hash_iter_status = 1;
pub const AWS_HASH_ITER_STATUS_READY_FOR_USE: aws_hash_iter_status = 2;
pub const AWS_TIMESTAMP_SECS: aws_timestamp_unit = 1;
pub const AWS_TIMESTAMP_MILLIS: aws_timestamp_unit = 1000;
pub const AWS_TIMESTAMP_MICROS: aws_timestamp_unit = 1000000;
pub const AWS_TIMESTAMP_NANOS: aws_timestamp_unit = 1000000000;
pub const AWS_CLI_OPTIONS_NO_ARGUMENT: aws_cli_options_has_arg = 0;
pub const AWS_CLI_OPTIONS_REQUIRED_ARGUMENT: aws_cli_options_has_arg = 1;
pub const AWS_CLI_OPTIONS_OPTIONAL_ARGUMENT: aws_cli_options_has_arg = 2;
pub const AWS_CPU_FEATURE_CLMUL: aws_cpu_feature_name = 0;
pub const AWS_CPU_FEATURE_SSE_4_1: aws_cpu_feature_name = 1;
pub const AWS_CPU_FEATURE_SSE_4_2: aws_cpu_feature_name = 2;
pub const AWS_CPU_FEATURE_AVX2: aws_cpu_feature_name = 3;
pub const AWS_CPU_FEATURE_AVX512: aws_cpu_feature_name = 4;
pub const AWS_CPU_FEATURE_ARM_CRC: aws_cpu_feature_name = 5;
pub const AWS_CPU_FEATURE_BMI2: aws_cpu_feature_name = 6;
pub const AWS_CPU_FEATURE_COUNT: aws_cpu_feature_name = 7;
pub const AWS_DATE_FORMAT_RFC822: aws_date_format = 0;
pub const AWS_DATE_FORMAT_ISO_8601: aws_date_format = 1;
pub const AWS_DATE_FORMAT_ISO_8601_BASIC: aws_date_format = 2;
pub const AWS_DATE_FORMAT_AUTO_DETECT: aws_date_format = 3;
pub const AWS_DATE_MONTH_JANUARY: aws_date_month = 0;
pub const AWS_DATE_MONTH_FEBRUARY: aws_date_month = 1;
pub const AWS_DATE_MONTH_MARCH: aws_date_month = 2;
pub const AWS_DATE_MONTH_APRIL: aws_date_month = 3;
pub const AWS_DATE_MONTH_MAY: aws_date_month = 4;
pub const AWS_DATE_MONTH_JUNE: aws_date_month = 5;
pub const AWS_DATE_MONTH_JULY: aws_date_month = 6;
pub const AWS_DATE_MONTH_AUGUST: aws_date_month = 7;
pub const AWS_DATE_MONTH_SEPTEMBER: aws_date_month = 8;
pub const AWS_DATE_MONTH_OCTOBER: aws_date_month = 9;
pub const AWS_DATE_MONTH_NOVEMBER: aws_date_month = 10;
pub const AWS_DATE_MONTH_DECEMBER: aws_date_month = 11;
pub const AWS_DATE_DAY_OF_WEEK_SUNDAY: aws_date_day_of_week = 0;
pub const AWS_DATE_DAY_OF_WEEK_MONDAY: aws_date_day_of_week = 1;
pub const AWS_DATE_DAY_OF_WEEK_TUESDAY: aws_date_day_of_week = 2;
pub const AWS_DATE_DAY_OF_WEEK_WEDNESDAY: aws_date_day_of_week = 3;
pub const AWS_DATE_DAY_OF_WEEK_THURSDAY: aws_date_day_of_week = 4;
pub const AWS_DATE_DAY_OF_WEEK_FRIDAY: aws_date_day_of_week = 5;
pub const AWS_DATE_DAY_OF_WEEK_SATURDAY: aws_date_day_of_week = 6;
pub const AWS_TEXT_UNKNOWN: aws_text_encoding = 0;
pub const AWS_TEXT_UTF8: aws_text_encoding = 1;
pub const AWS_TEXT_UTF16: aws_text_encoding = 2;
pub const AWS_TEXT_UTF32: aws_text_encoding = 3;
pub const AWS_TEXT_ASCII: aws_text_encoding = 4;
pub const AWS_FILE_TYPE_FILE: aws_file_type = 1;
pub const AWS_FILE_TYPE_SYM_LINK: aws_file_type = 2;
pub const AWS_FILE_TYPE_DIRECTORY: aws_file_type = 4;
pub const AWS_THREAD_NOT_CREATED: aws_thread_detach_state = 1;
pub const AWS_THREAD_JOINABLE: aws_thread_detach_state = 2;
pub const AWS_THREAD_JOIN_COMPLETED: aws_thread_detach_state = 3;
pub const AWS_THREAD_MANAGED: aws_thread_detach_state = 4;
pub const AWS_TJS_MANUAL: aws_thread_join_strategy = 0;
pub const AWS_TJS_MANAGED: aws_thread_join_strategy = 1;
pub const AWS_LL_NONE: aws_log_level = 0;
pub const AWS_LL_FATAL: aws_log_level = 1;
pub const AWS_LL_ERROR: aws_log_level = 2;
pub const AWS_LL_WARN: aws_log_level = 3;
pub const AWS_LL_INFO: aws_log_level = 4;
pub const AWS_LL_DEBUG: aws_log_level = 5;
pub const AWS_LL_TRACE: aws_log_level = 6;
pub const AWS_LL_COUNT: aws_log_level = 7;
pub const AWS_LS_COMMON_GENERAL: aws_common_log_subject = 0;
pub const AWS_LS_COMMON_TASK_SCHEDULER: aws_common_log_subject = 1;
pub const AWS_LS_COMMON_THREAD: aws_common_log_subject = 2;
pub const AWS_LS_COMMON_MEMTRACE: aws_common_log_subject = 3;
pub const AWS_LS_COMMON_XML_PARSER: aws_common_log_subject = 4;
pub const AWS_LS_COMMON_IO: aws_common_log_subject = 5;
pub const AWS_LS_COMMON_BUS: aws_common_log_subject = 6;
pub const AWS_LS_COMMON_TEST: aws_common_log_subject = 7;
pub const AWS_LS_COMMON_JSON_PARSER: aws_common_log_subject = 8;
pub const AWS_LS_COMMON_LAST: aws_common_log_subject = 1023;
pub const AWSCRT_STAT_CAT_INVALID: aws_crt_common_statistics_category = 0;
pub const AWS_PLATFORM_OS_WINDOWS: aws_platform_os = 0;
pub const AWS_PLATFORM_OS_MAC: aws_platform_os = 1;
pub const AWS_PLATFORM_OS_UNIX: aws_platform_os = 2;
pub const AWS_TASK_STATUS_RUN_READY: aws_task_status = 0;
pub const AWS_TASK_STATUS_CANCELED: aws_task_status = 1;
#[repr(C)]
#[derive(Copy, Clone)]
pub union aws_task__bindgen_ty_1 {
    pub scheduled: bool,
    pub reserved: usize,
}
extern "C" {
    pub fn aws_fatal_assert(
        cond_str: *const ::core::ffi::c_char,
        file: *const ::core::ffi::c_char,
        line: ::core::ffi::c_int,
    ) -> !;
    #[doc = " Inexpensive (constant time) check of data-structure invariants."]
    pub fn aws_allocator_is_valid(alloc: *const aws_allocator) -> bool;
    pub fn aws_default_allocator() -> *mut aws_allocator;
    pub fn aws_aligned_allocator() -> *mut aws_allocator;
    #[doc = " Wraps a CFAllocator around aws_allocator. For Mac only. Use this anytime you need a CFAllocatorRef for interacting\n with Apple Frameworks. Unfortunately, it allocates memory so we can't make it static file scope, be sure to call\n aws_wrapped_cf_allocator_destroy when finished."]
    pub fn aws_wrapped_cf_allocator_new(allocator: *mut aws_allocator) -> CFAllocatorRef;
    #[doc = " Cleans up any resources alloced in aws_wrapped_cf_allocator_new."]
    pub fn aws_wrapped_cf_allocator_destroy(allocator: CFAllocatorRef);
    #[doc = " Returns at least `size` of memory ready for usage. In versions v0.6.8 and prior, this function was allowed to return\n NULL. In later versions, if allocator->mem_acquire() returns NULL, this function will assert and exit. To handle\n conditions where OOM is not a fatal error, allocator->mem_acquire() is responsible for finding/reclaiming/running a\n GC etc...before returning."]
    pub fn aws_mem_acquire(allocator: *mut aws_allocator, size: usize) -> *mut ::core::ffi::c_void;
    #[doc = " Allocates a block of memory for an array of num elements, each of them size bytes long, and initializes all its bits\n to zero. In versions v0.6.8 and prior, this function was allowed to return NULL.\n In later versions, if allocator->mem_calloc() returns NULL, this function will assert and exit. To handle\n conditions where OOM is not a fatal error, allocator->mem_calloc() is responsible for finding/reclaiming/running a\n GC etc...before returning."]
    pub fn aws_mem_calloc(
        allocator: *mut aws_allocator,
        num: usize,
        size: usize,
    ) -> *mut ::core::ffi::c_void;
    #[doc = " Allocates many chunks of bytes into a single block. Expects to be called with alternating void ** (dest), size_t\n (size). The first void ** will be set to the root of the allocation. Alignment is assumed to be sizeof(intmax_t).\n\n This is useful for allocating structs using the pimpl pattern, as you may allocate the public object and impl object\n in the same contiguous block of memory.\n\n Returns a pointer to the allocation.\n\n In versions v0.6.8 and prior, this function was allowed to return\n NULL. In later versions, if allocator->mem_acquire() returns NULL, this function will assert and exit. To handle\n conditions where OOM is not a fatal error, allocator->mem_acquire() is responsible for finding/reclaiming/running a\n GC etc...before returning."]
    pub fn aws_mem_acquire_many(
        allocator: *mut aws_allocator,
        count: usize,
        ...
    ) -> *mut ::core::ffi::c_void;
    #[doc = " Releases ptr back to whatever allocated it.\n Nothing happens if ptr is NULL."]
    pub fn aws_mem_release(allocator: *mut aws_allocator, ptr: *mut ::core::ffi::c_void);
    #[doc = " Attempts to adjust the size of the pointed-to memory buffer from oldsize to\n newsize. The pointer (*ptr) may be changed if the memory needs to be\n reallocated.\n\n In versions v0.6.8 and prior, this function was allowed to return\n NULL. In later versions, if allocator->mem_realloc() returns NULL, this function will assert and exit. To handle\n conditions where OOM is not a fatal error, allocator->mem_realloc() is responsible for finding/reclaiming/running a\n GC etc...before returning."]
    pub fn aws_mem_realloc(
        allocator: *mut aws_allocator,
        ptr: *mut *mut ::core::ffi::c_void,
        oldsize: usize,
        newsize: usize,
    ) -> ::core::ffi::c_int;
    pub fn aws_mem_tracer_new(
        allocator: *mut aws_allocator,
        deprecated: *mut aws_allocator,
        level: aws_mem_trace_level,
        frames_per_stack: usize,
    ) -> *mut aws_allocator;
    pub fn aws_mem_tracer_destroy(trace_allocator: *mut aws_allocator) -> *mut aws_allocator;
    pub fn aws_mem_tracer_dump(trace_allocator: *mut aws_allocator);
    pub fn aws_mem_tracer_bytes(trace_allocator: *mut aws_allocator) -> usize;
    pub fn aws_mem_tracer_count(trace_allocator: *mut aws_allocator) -> usize;
    pub fn aws_small_block_allocator_new(
        allocator: *mut aws_allocator,
        multi_threaded: bool,
    ) -> *mut aws_allocator;
    pub fn aws_small_block_allocator_destroy(sba_allocator: *mut aws_allocator);
    pub fn aws_small_block_allocator_bytes_active(sba_allocator: *mut aws_allocator) -> usize;
    pub fn aws_small_block_allocator_bytes_reserved(sba_allocator: *mut aws_allocator) -> usize;
    pub fn aws_small_block_allocator_page_size(sba_allocator: *mut aws_allocator) -> usize;
    pub fn aws_small_block_allocator_page_size_available(
        sba_allocator: *mut aws_allocator,
    ) -> usize;
    pub fn aws_last_error() -> ::core::ffi::c_int;
    pub fn aws_error_str(err: ::core::ffi::c_int) -> *const ::core::ffi::c_char;
    pub fn aws_error_name(err: ::core::ffi::c_int) -> *const ::core::ffi::c_char;
    pub fn aws_error_lib_name(err: ::core::ffi::c_int) -> *const ::core::ffi::c_char;
    pub fn aws_error_debug_str(err: ::core::ffi::c_int) -> *const ::core::ffi::c_char;
    pub fn aws_raise_error_private(err: ::core::ffi::c_int);
    pub fn aws_reset_error();
    pub fn aws_restore_error(err: ::core::ffi::c_int);
    pub fn aws_set_global_error_handler_fn(
        handler: aws_error_handler_fn,
        ctx: *mut ::core::ffi::c_void,
    ) -> aws_error_handler_fn;
    pub fn aws_set_thread_local_error_handler_fn(
        handler: aws_error_handler_fn,
        ctx: *mut ::core::ffi::c_void,
    ) -> aws_error_handler_fn;
    #[doc = " TODO: this needs to be a private function (wait till we have the cmake story\n better before moving it though). It should be external for the purpose of\n other libs we own, but customers should not be able to hit it without going\n out of their way to do so."]
    pub fn aws_register_error_info(error_info: *const aws_error_info_list);
    pub fn aws_unregister_error_info(error_info: *const aws_error_info_list);
    #[doc = " Convert a c library io error into an aws error, and raise it.\n If no conversion is found, fallback_aws_error_code is raised.\n Always returns AWS_OP_ERR."]
    pub fn aws_translate_and_raise_io_error_or(
        error_no: ::core::ffi::c_int,
        fallback_aws_error_code: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    #[doc = " Convert a c library io error into an aws error, and raise it.\n If no conversion is found, AWS_ERROR_SYS_CALL_FAILURE is raised.\n Always returns AWS_OP_ERR."]
    pub fn aws_translate_and_raise_io_error(error_no: ::core::ffi::c_int) -> ::core::ffi::c_int;
    #[doc = " Securely zeroes a memory buffer. This function will attempt to ensure that\n the compiler will not optimize away this zeroing operation."]
    pub fn aws_secure_zero(pBuf: *mut ::core::ffi::c_void, bufsize: usize);
    #[doc = " Initializes internal data structures used by aws-c-common.\n Must be called before using any functionality in aws-c-common."]
    pub fn aws_common_library_init(allocator: *mut aws_allocator);
    #[doc = " Shuts down the internal data structures used by aws-c-common."]
    pub fn aws_common_library_clean_up();
    pub fn aws_common_fatal_assert_library_initialized();
    #[doc = " Adds [num] arguments (expected to be of size_t), and returns the result in *r.\n If the result overflows, returns AWS_OP_ERR; otherwise returns AWS_OP_SUCCESS."]
    pub fn aws_add_size_checked_varargs(num: usize, r: *mut usize, ...) -> ::core::ffi::c_int;
    #[doc = " If in dynamic mode, shrinks the allocated array size to the minimum amount necessary to store its elements."]
    pub fn aws_array_list_shrink_to_fit(list: *mut aws_array_list) -> ::core::ffi::c_int;
    #[doc = " Copies the elements from from to to. If to is in static mode, it must at least be the same length as from. Any data\n in to will be overwritten in this copy."]
    pub fn aws_array_list_copy(
        from: *const aws_array_list,
        to: *mut aws_array_list,
    ) -> ::core::ffi::c_int;
    #[doc = " Ensures that the array list has enough capacity to store a value at the specified index. If there is not already\n enough capacity, and the list is in dynamic mode, this function will attempt to allocate more memory, expanding the\n list. In static mode, if 'index' is beyond the maximum index, AWS_ERROR_INVALID_INDEX will be raised."]
    pub fn aws_array_list_ensure_capacity(
        list: *mut aws_array_list,
        index: usize,
    ) -> ::core::ffi::c_int;
    #[doc = " Swap elements at the specified indices, which must be within the bounds of the array."]
    pub fn aws_array_list_swap(list: *mut aws_array_list, a: usize, b: usize);
    #[doc = " Sort elements in the list in-place according to the comparator function."]
    pub fn aws_array_list_sort(list: *mut aws_array_list, compare_fn: aws_array_list_comparator_fn);
    #[doc = " Compare two arrays.\n Return whether their contents are equivalent.\n NULL may be passed as the array pointer if its length is declared to be 0."]
    pub fn aws_array_eq(
        array_a: *const ::core::ffi::c_void,
        len_a: usize,
        array_b: *const ::core::ffi::c_void,
        len_b: usize,
    ) -> bool;
    #[doc = " Perform a case-insensitive string comparison of two arrays.\n Return whether their contents are equivalent.\n NULL may be passed as the array pointer if its length is declared to be 0.\n The \"C\" locale is used for comparing upper and lowercase letters.\n Data is assumed to be ASCII text, UTF-8 will work fine too."]
    pub fn aws_array_eq_ignore_case(
        array_a: *const ::core::ffi::c_void,
        len_a: usize,
        array_b: *const ::core::ffi::c_void,
        len_b: usize,
    ) -> bool;
    #[doc = " Compare an array and a null-terminated string.\n Returns true if their contents are equivalent.\n The array should NOT contain a null-terminator, or the comparison will always return false.\n NULL may be passed as the array pointer if its length is declared to be 0."]
    pub fn aws_array_eq_c_str(
        array: *const ::core::ffi::c_void,
        array_len: usize,
        c_str: *const ::core::ffi::c_char,
    ) -> bool;
    #[doc = " Perform a case-insensitive string comparison of an array and a null-terminated string.\n Return whether their contents are equivalent.\n The array should NOT contain a null-terminator, or the comparison will always return false.\n NULL may be passed as the array pointer if its length is declared to be 0.\n The \"C\" locale is used for comparing upper and lowercase letters.\n Data is assumed to be ASCII text, UTF-8 will work fine too."]
    pub fn aws_array_eq_c_str_ignore_case(
        array: *const ::core::ffi::c_void,
        array_len: usize,
        c_str: *const ::core::ffi::c_char,
    ) -> bool;
    pub fn aws_byte_buf_init(
        buf: *mut aws_byte_buf,
        allocator: *mut aws_allocator,
        capacity: usize,
    ) -> ::core::ffi::c_int;
    #[doc = " Initializes an aws_byte_buf structure base on another valid one.\n Requires: *src and *allocator are valid objects.\n Ensures: *dest is a valid aws_byte_buf with a new backing array dest->buffer\n which is a copy of the elements from src->buffer."]
    pub fn aws_byte_buf_init_copy(
        dest: *mut aws_byte_buf,
        allocator: *mut aws_allocator,
        src: *const aws_byte_buf,
    ) -> ::core::ffi::c_int;
    #[doc = " Reads 'filename' into 'out_buf'. If successful, 'out_buf' is allocated and filled with the data;\n It is your responsibility to call 'aws_byte_buf_clean_up()' on it. Otherwise, 'out_buf' remains\n unused. In the very unfortunate case where some API needs to treat out_buf as a c_string, a null terminator\n is appended, but is not included as part of the length field."]
    pub fn aws_byte_buf_init_from_file(
        out_buf: *mut aws_byte_buf,
        alloc: *mut aws_allocator,
        filename: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    #[doc = " Same as aws_byte_buf_init_from_file(), but for reading \"special files\" like /proc/cpuinfo.\n These files don't accurately report their size, so size_hint is used as initial buffer size,\n and the buffer grows until the while file is read."]
    pub fn aws_byte_buf_init_from_file_with_size_hint(
        out_buf: *mut aws_byte_buf,
        alloc: *mut aws_allocator,
        filename: *const ::core::ffi::c_char,
        size_hint: usize,
    ) -> ::core::ffi::c_int;
    #[doc = " Evaluates the set of properties that define the shape of all valid aws_byte_buf structures.\n It is also a cheap check, in the sense it run in constant time (i.e., no loops or recursion)."]
    pub fn aws_byte_buf_is_valid(buf: *const aws_byte_buf) -> bool;
    #[doc = " Evaluates the set of properties that define the shape of all valid aws_byte_cursor structures.\n It is also a cheap check, in the sense it runs in constant time (i.e., no loops or recursion)."]
    pub fn aws_byte_cursor_is_valid(cursor: *const aws_byte_cursor) -> bool;
    #[doc = " Copies src buffer into dest and sets the correct len and capacity.\n A new memory zone is allocated for dest->buffer. When dest is no longer needed it will have to be cleaned-up using\n aws_byte_buf_clean_up(dest).\n Dest capacity and len will be equal to the src len. Allocator of the dest will be identical with parameter allocator.\n If src buffer is null the dest will have a null buffer with a len and a capacity of 0\n Returns AWS_OP_SUCCESS in case of success or AWS_OP_ERR when memory can't be allocated."]
    pub fn aws_byte_buf_init_copy_from_cursor(
        dest: *mut aws_byte_buf,
        allocator: *mut aws_allocator,
        src: aws_byte_cursor,
    ) -> ::core::ffi::c_int;
    #[doc = " Init buffer with contents of multiple cursors, and update cursors to reference the memory stored in the buffer.\n Each cursor arg must be an `struct aws_byte_cursor *`. NULL must be passed as the final arg.\n NOTE: Do not append/grow/resize buffers initialized this way, or the cursors will end up referencing invalid memory.\n Returns AWS_OP_SUCCESS in case of success.\n AWS_OP_ERR is returned if memory can't be allocated or the total cursor length exceeds SIZE_MAX."]
    pub fn aws_byte_buf_init_cache_and_update_cursors(
        dest: *mut aws_byte_buf,
        allocator: *mut aws_allocator,
        ...
    ) -> ::core::ffi::c_int;
    pub fn aws_byte_buf_clean_up(buf: *mut aws_byte_buf);
    #[doc = " Equivalent to calling aws_byte_buf_secure_zero and then aws_byte_buf_clean_up\n on the buffer."]
    pub fn aws_byte_buf_clean_up_secure(buf: *mut aws_byte_buf);
    #[doc = " Resets the len of the buffer to 0, but does not free the memory. The buffer can then be reused.\n Optionally zeroes the contents, if the \"zero_contents\" flag is true."]
    pub fn aws_byte_buf_reset(buf: *mut aws_byte_buf, zero_contents: bool);
    #[doc = " Sets all bytes of buffer to zero and resets len to zero."]
    pub fn aws_byte_buf_secure_zero(buf: *mut aws_byte_buf);
    #[doc = " Compare two aws_byte_buf structures.\n Return whether their contents are equivalent."]
    pub fn aws_byte_buf_eq(a: *const aws_byte_buf, b: *const aws_byte_buf) -> bool;
    #[doc = " Perform a case-insensitive string comparison of two aws_byte_buf structures.\n Return whether their contents are equivalent.\n The \"C\" locale is used for comparing upper and lowercase letters.\n Data is assumed to be ASCII text, UTF-8 will work fine too."]
    pub fn aws_byte_buf_eq_ignore_case(a: *const aws_byte_buf, b: *const aws_byte_buf) -> bool;
    #[doc = " Compare an aws_byte_buf and a null-terminated string.\n Returns true if their contents are equivalent.\n The buffer should NOT contain a null-terminator, or the comparison will always return false."]
    pub fn aws_byte_buf_eq_c_str(
        buf: *const aws_byte_buf,
        c_str: *const ::core::ffi::c_char,
    ) -> bool;
    #[doc = " Perform a case-insensitive string comparison of an aws_byte_buf and a null-terminated string.\n Return whether their contents are equivalent.\n The buffer should NOT contain a null-terminator, or the comparison will always return false.\n The \"C\" locale is used for comparing upper and lowercase letters.\n Data is assumed to be ASCII text, UTF-8 will work fine too."]
    pub fn aws_byte_buf_eq_c_str_ignore_case(
        buf: *const aws_byte_buf,
        c_str: *const ::core::ffi::c_char,
    ) -> bool;
    #[doc = " No copies, no buffer allocations. Iterates over input_str, and returns the\n next substring between split_on instances relative to previous substr.\n Behaves similar to strtok with substr being used as state for next split.\n\n Returns true each time substr is set and false when there is no more splits\n (substr is set to empty in that case).\n\n Example usage.\n struct aws_byte_cursor substr = {0};\n while (aws_byte_cursor_next_split(&input_str, ';', &substr)) {\n   // ...use substr...\n }\n\n Note: It is the user's responsibility zero-initialize substr before the first call.\n\n Edge case rules are as follows:\n empty input will have single empty split. ex. \"\" splits into \"\"\n if input starts with split_on then first split is empty. ex \";A\" splits into \"\", \"A\"\n adjacent split tokens result in empty split. ex \"A;;B\" splits into \"A\", \"\", \"B\"\n If the input ends with split_on, last split is empty. ex. \"A;\" splits into \"A\", \"\"\n\n It is the user's responsibility to make sure the input buffer stays in memory\n long enough to use the results."]
    pub fn aws_byte_cursor_next_split(
        input_str: *const aws_byte_cursor,
        split_on: ::core::ffi::c_char,
        substr: *mut aws_byte_cursor,
    ) -> bool;
    #[doc = " No copies, no buffer allocations. Fills in output with a list of\n aws_byte_cursor instances where buffer is an offset into the input_str and\n len is the length of that string in the original buffer.\n\n Edge case rules are as follows:\n if the input begins with split_on, an empty cursor will be the first entry in\n output. if the input has two adjacent split_on tokens, an empty cursor will\n be inserted into the output. if the input ends with split_on, an empty cursor\n will be appended to the output.\n\n It is the user's responsibility to properly initialize output. Recommended number of preallocated elements from\n output is your most likely guess for the upper bound of the number of elements resulting from the split.\n\n The type that will be stored in output is struct aws_byte_cursor (you'll need\n this for the item size param).\n\n It is the user's responsibility to make sure the input buffer stays in memory\n long enough to use the results."]
    pub fn aws_byte_cursor_split_on_char(
        input_str: *const aws_byte_cursor,
        split_on: ::core::ffi::c_char,
        output: *mut aws_array_list,
    ) -> ::core::ffi::c_int;
    #[doc = " No copies, no buffer allocations. Fills in output with a list of aws_byte_cursor instances where buffer is\n an offset into the input_str and len is the length of that string in the original buffer. N is the max number of\n splits, if this value is zero, it will add all splits to the output.\n\n Edge case rules are as follows:\n if the input begins with split_on, an empty cursor will be the first entry in output\n if the input has two adjacent split_on tokens, an empty cursor will be inserted into the output.\n if the input ends with split_on, an empty cursor will be appended to the output.\n\n It is the user's responsibility to properly initialize output. Recommended number of preallocated elements from\n output is your most likely guess for the upper bound of the number of elements resulting from the split.\n\n If the output array is not large enough, input_str will be updated to point to the first character after the last\n processed split_on instance.\n\n The type that will be stored in output is struct aws_byte_cursor (you'll need this for the item size param).\n\n It is the user's responsibility to make sure the input buffer stays in memory long enough to use the results."]
    pub fn aws_byte_cursor_split_on_char_n(
        input_str: *const aws_byte_cursor,
        split_on: ::core::ffi::c_char,
        n: usize,
        output: *mut aws_array_list,
    ) -> ::core::ffi::c_int;
    #[doc = " Search for an exact byte match inside a cursor. The first match will be returned. Returns AWS_OP_SUCCESS\n on successful match and first_find will be set to the offset in input_str, and length will be the remaining length\n from input_str past the returned offset. If the match was not found, AWS_OP_ERR will be returned and\n AWS_ERROR_STRING_MATCH_NOT_FOUND will be raised."]
    pub fn aws_byte_cursor_find_exact(
        input_str: *const aws_byte_cursor,
        to_find: *const aws_byte_cursor,
        first_find: *mut aws_byte_cursor,
    ) -> ::core::ffi::c_int;
    #[doc = " Shrinks a byte cursor from the right for as long as the supplied predicate is true"]
    pub fn aws_byte_cursor_right_trim_pred(
        source: *const aws_byte_cursor,
        predicate: aws_byte_predicate_fn,
    ) -> aws_byte_cursor;
    #[doc = " Shrinks a byte cursor from the left for as long as the supplied predicate is true"]
    pub fn aws_byte_cursor_left_trim_pred(
        source: *const aws_byte_cursor,
        predicate: aws_byte_predicate_fn,
    ) -> aws_byte_cursor;
    #[doc = " Shrinks a byte cursor from both sides for as long as the supplied predicate is true"]
    pub fn aws_byte_cursor_trim_pred(
        source: *const aws_byte_cursor,
        predicate: aws_byte_predicate_fn,
    ) -> aws_byte_cursor;
    #[doc = " Returns true if the byte cursor's range of bytes all satisfy the predicate"]
    pub fn aws_byte_cursor_satisfies_pred(
        source: *const aws_byte_cursor,
        predicate: aws_byte_predicate_fn,
    ) -> bool;
    #[doc = " Copies from to to. If to is too small, AWS_ERROR_DEST_COPY_TOO_SMALL will be\n returned. dest->len will contain the amount of data actually copied to dest.\n\n from and to may be the same buffer, permitting copying a buffer into itself."]
    pub fn aws_byte_buf_append(
        to: *mut aws_byte_buf,
        from: *const aws_byte_cursor,
    ) -> ::core::ffi::c_int;
    #[doc = " Copies from to to while converting bytes via the passed in lookup table.\n If to is too small, AWS_ERROR_DEST_COPY_TOO_SMALL will be\n returned. to->len will contain its original size plus the amount of data actually copied to to.\n\n from and to should not be the same buffer (overlap is not handled)\n lookup_table must be at least 256 bytes"]
    pub fn aws_byte_buf_append_with_lookup(
        to: *mut aws_byte_buf,
        from: *const aws_byte_cursor,
        lookup_table: *const u8,
    ) -> ::core::ffi::c_int;
    #[doc = " Copies from to to. If to is too small, the buffer will be grown appropriately and\n the old contents copied to, before the new contents are appended.\n\n If the grow fails (overflow or OOM), then an error will be returned.\n\n from and to may be the same buffer, permitting copying a buffer into itself."]
    pub fn aws_byte_buf_append_dynamic(
        to: *mut aws_byte_buf,
        from: *const aws_byte_cursor,
    ) -> ::core::ffi::c_int;
    #[doc = " Copies `from` to `to`. If `to` is too small, the buffer will be grown appropriately and\n the old contents copied over, before the new contents are appended.\n\n If the grow fails (overflow or OOM), then an error will be returned.\n\n If the buffer is grown, the old buffer will be securely cleared before getting freed.\n\n `from` and `to` may be the same buffer, permitting copying a buffer into itself."]
    pub fn aws_byte_buf_append_dynamic_secure(
        to: *mut aws_byte_buf,
        from: *const aws_byte_cursor,
    ) -> ::core::ffi::c_int;
    #[doc = " Copies a single byte into `to`. If `to` is too small, the buffer will be grown appropriately and\n the old contents copied over, before the byte is appended.\n\n If the grow fails (overflow or OOM), then an error will be returned."]
    pub fn aws_byte_buf_append_byte_dynamic(
        buffer: *mut aws_byte_buf,
        value: u8,
    ) -> ::core::ffi::c_int;
    #[doc = " Copies a single byte into `to`. If `to` is too small, the buffer will be grown appropriately and\n the old contents copied over, before the byte is appended.\n\n If the grow fails (overflow or OOM), then an error will be returned.\n\n If the buffer is grown, the old buffer will be securely cleared before getting freed."]
    pub fn aws_byte_buf_append_byte_dynamic_secure(
        buffer: *mut aws_byte_buf,
        value: u8,
    ) -> ::core::ffi::c_int;
    #[doc = " Copy contents of cursor to buffer, then update cursor to reference the memory stored in the buffer.\n If buffer is too small, AWS_ERROR_DEST_COPY_TOO_SMALL will be returned.\n\n The cursor is permitted to reference memory from earlier in the buffer."]
    pub fn aws_byte_buf_append_and_update(
        to: *mut aws_byte_buf,
        from_and_update: *mut aws_byte_cursor,
    ) -> ::core::ffi::c_int;
    #[doc = " Appends '\\0' at the end of the buffer."]
    pub fn aws_byte_buf_append_null_terminator(buf: *mut aws_byte_buf) -> ::core::ffi::c_int;
    #[doc = " Attempts to increase the capacity of a buffer to the requested capacity\n\n If the the buffer's capacity is currently larger than the request capacity, the\n function does nothing (no shrink is performed)."]
    pub fn aws_byte_buf_reserve(
        buffer: *mut aws_byte_buf,
        requested_capacity: usize,
    ) -> ::core::ffi::c_int;
    #[doc = " Convenience function that attempts to increase the capacity of a buffer relative to the current\n length.\n\n  aws_byte_buf_reserve_relative(buf, x) ~~ aws_byte_buf_reserve(buf, buf->len + x)\n"]
    pub fn aws_byte_buf_reserve_relative(
        buffer: *mut aws_byte_buf,
        additional_length: usize,
    ) -> ::core::ffi::c_int;
    #[doc = " Concatenates a variable number of struct aws_byte_buf * into destination.\n Number of args must be greater than 1. If dest is too small,\n AWS_ERROR_DEST_COPY_TOO_SMALL will be returned. dest->len will contain the\n amount of data actually copied to dest."]
    pub fn aws_byte_buf_cat(
        dest: *mut aws_byte_buf,
        number_of_args: usize,
        ...
    ) -> ::core::ffi::c_int;
    #[doc = " Compare two aws_byte_cursor structures.\n Return whether their contents are equivalent."]
    pub fn aws_byte_cursor_eq(a: *const aws_byte_cursor, b: *const aws_byte_cursor) -> bool;
    #[doc = " Perform a case-insensitive string comparison of two aws_byte_cursor structures.\n Return whether their contents are equivalent.\n The \"C\" locale is used for comparing upper and lowercase letters.\n Data is assumed to be ASCII text, UTF-8 will work fine too."]
    pub fn aws_byte_cursor_eq_ignore_case(
        a: *const aws_byte_cursor,
        b: *const aws_byte_cursor,
    ) -> bool;
    #[doc = " Compare an aws_byte_cursor and an aws_byte_buf.\n Return whether their contents are equivalent."]
    pub fn aws_byte_cursor_eq_byte_buf(a: *const aws_byte_cursor, b: *const aws_byte_buf) -> bool;
    #[doc = " Perform a case-insensitive string comparison of an aws_byte_cursor and an aws_byte_buf.\n Return whether their contents are equivalent.\n The \"C\" locale is used for comparing upper and lowercase letters.\n Data is assumed to be ASCII text, UTF-8 will work fine too."]
    pub fn aws_byte_cursor_eq_byte_buf_ignore_case(
        a: *const aws_byte_cursor,
        b: *const aws_byte_buf,
    ) -> bool;
    #[doc = " Compare an aws_byte_cursor and a null-terminated string.\n Returns true if their contents are equivalent.\n The cursor should NOT contain a null-terminator, or the comparison will always return false."]
    pub fn aws_byte_cursor_eq_c_str(
        cursor: *const aws_byte_cursor,
        c_str: *const ::core::ffi::c_char,
    ) -> bool;
    #[doc = " Perform a case-insensitive string comparison of an aws_byte_cursor and a null-terminated string.\n Return whether their contents are equivalent.\n The cursor should NOT contain a null-terminator, or the comparison will always return false.\n The \"C\" locale is used for comparing upper and lowercase letters.\n Data is assumed to be ASCII text, UTF-8 will work fine too."]
    pub fn aws_byte_cursor_eq_c_str_ignore_case(
        cursor: *const aws_byte_cursor,
        c_str: *const ::core::ffi::c_char,
    ) -> bool;
    #[doc = " Return true if the input starts with the prefix (exact byte comparison)."]
    pub fn aws_byte_cursor_starts_with(
        input: *const aws_byte_cursor,
        prefix: *const aws_byte_cursor,
    ) -> bool;
    #[doc = " Return true if the input starts with the prefix (case-insensitive).\n The \"C\" locale is used for comparing upper and lowercase letters.\n Data is assumed to be ASCII text, UTF-8 will work fine too."]
    pub fn aws_byte_cursor_starts_with_ignore_case(
        input: *const aws_byte_cursor,
        prefix: *const aws_byte_cursor,
    ) -> bool;
    #[doc = " Case-insensitive hash function for array containing ASCII or UTF-8 text."]
    pub fn aws_hash_array_ignore_case(array: *const ::core::ffi::c_void, len: usize) -> u64;
    #[doc = " Case-insensitive hash function for aws_byte_cursors stored in an aws_hash_table.\n For case-sensitive hashing, use aws_hash_byte_cursor_ptr()."]
    pub fn aws_hash_byte_cursor_ptr_ignore_case(item: *const ::core::ffi::c_void) -> u64;
    #[doc = " Returns a lookup table for bytes that is the identity transformation with the exception\n of uppercase ascii characters getting replaced with lowercase characters.  Used in\n caseless comparisons."]
    pub fn aws_lookup_table_to_lower_get() -> *const u8;
    #[doc = " Returns lookup table to go from ASCII/UTF-8 hex character to a number (0-15).\n Non-hex characters map to 255.\n Valid examples:\n '0' -> 0\n 'F' -> 15\n 'f' -> 15\n Invalid examples:\n ' ' -> 255\n 'Z' -> 255\n '\\0' -> 255"]
    pub fn aws_lookup_table_hex_to_num_get() -> *const u8;
    #[doc = " Lexical (byte value) comparison of two byte cursors"]
    pub fn aws_byte_cursor_compare_lexical(
        lhs: *const aws_byte_cursor,
        rhs: *const aws_byte_cursor,
    ) -> ::core::ffi::c_int;
    #[doc = " Lexical (byte value) comparison of two byte cursors where the raw values are sent through a lookup table first"]
    pub fn aws_byte_cursor_compare_lookup(
        lhs: *const aws_byte_cursor,
        rhs: *const aws_byte_cursor,
        lookup_table: *const u8,
    ) -> ::core::ffi::c_int;
    #[doc = " For creating a byte buffer from a null-terminated string literal."]
    pub fn aws_byte_buf_from_c_str(c_str: *const ::core::ffi::c_char) -> aws_byte_buf;
    pub fn aws_byte_buf_from_array(bytes: *const ::core::ffi::c_void, len: usize) -> aws_byte_buf;
    pub fn aws_byte_buf_from_empty_array(
        bytes: *const ::core::ffi::c_void,
        capacity: usize,
    ) -> aws_byte_buf;
    pub fn aws_byte_cursor_from_buf(buf: *const aws_byte_buf) -> aws_byte_cursor;
    pub fn aws_byte_cursor_from_c_str(c_str: *const ::core::ffi::c_char) -> aws_byte_cursor;
    pub fn aws_byte_cursor_from_array(
        bytes: *const ::core::ffi::c_void,
        len: usize,
    ) -> aws_byte_cursor;
    #[doc = " Tests if the given aws_byte_cursor has at least len bytes remaining. If so,\n *buf is advanced by len bytes (incrementing ->ptr and decrementing ->len),\n and an aws_byte_cursor referring to the first len bytes of the original *buf\n is returned. Otherwise, an aws_byte_cursor with ->ptr = NULL, ->len = 0 is\n returned.\n\n Note that if len is above (SIZE_MAX / 2), this function will also treat it as\n a buffer overflow, and return NULL without changing *buf."]
    pub fn aws_byte_cursor_advance(cursor: *mut aws_byte_cursor, len: usize) -> aws_byte_cursor;
    #[doc = " Behaves identically to aws_byte_cursor_advance, but avoids speculative\n execution potentially reading out-of-bounds pointers (by returning an\n empty ptr in such speculated paths).\n\n This should generally be done when using an untrusted or\n data-dependent value for 'len', to avoid speculating into a path where\n cursor->ptr points outside the true ptr length."]
    pub fn aws_byte_cursor_advance_nospec(
        cursor: *mut aws_byte_cursor,
        len: usize,
    ) -> aws_byte_cursor;
    #[doc = " Reads specified length of data from byte cursor and copies it to the\n destination array.\n\n On success, returns true and updates the cursor pointer/length accordingly.\n If there is insufficient space in the cursor, returns false, leaving the\n cursor unchanged."]
    pub fn aws_byte_cursor_read(
        cur: *mut aws_byte_cursor,
        dest: *mut ::core::ffi::c_void,
        len: usize,
    ) -> bool;
    #[doc = " Reads as many bytes from cursor as size of buffer, and copies them to buffer.\n\n On success, returns true and updates the cursor pointer/length accordingly.\n If there is insufficient space in the cursor, returns false, leaving the\n cursor unchanged."]
    pub fn aws_byte_cursor_read_and_fill_buffer(
        cur: *mut aws_byte_cursor,
        dest: *mut aws_byte_buf,
    ) -> bool;
    #[doc = " Reads a single byte from cursor, placing it in *var.\n\n On success, returns true and updates the cursor pointer/length accordingly.\n If there is insufficient space in the cursor, returns false, leaving the\n cursor unchanged."]
    pub fn aws_byte_cursor_read_u8(cur: *mut aws_byte_cursor, var: *mut u8) -> bool;
    #[doc = " Reads a 16-bit value in network byte order from cur, and places it in host\n byte order into var.\n\n On success, returns true and updates the cursor pointer/length accordingly.\n If there is insufficient space in the cursor, returns false, leaving the\n cursor unchanged."]
    pub fn aws_byte_cursor_read_be16(cur: *mut aws_byte_cursor, var: *mut u16) -> bool;
    #[doc = " Reads an unsigned 24-bit value (3 bytes) in network byte order from cur,\n and places it in host byte order into 32-bit var.\n Ex: if cur's next 3 bytes are {0xAA, 0xBB, 0xCC}, then var becomes 0x00AABBCC.\n\n On success, returns true and updates the cursor pointer/length accordingly.\n If there is insufficient space in the cursor, returns false, leaving the\n cursor unchanged."]
    pub fn aws_byte_cursor_read_be24(cur: *mut aws_byte_cursor, var: *mut u32) -> bool;
    #[doc = " Reads a 32-bit value in network byte order from cur, and places it in host\n byte order into var.\n\n On success, returns true and updates the cursor pointer/length accordingly.\n If there is insufficient space in the cursor, returns false, leaving the\n cursor unchanged."]
    pub fn aws_byte_cursor_read_be32(cur: *mut aws_byte_cursor, var: *mut u32) -> bool;
    #[doc = " Reads a 64-bit value in network byte order from cur, and places it in host\n byte order into var.\n\n On success, returns true and updates the cursor pointer/length accordingly.\n If there is insufficient space in the cursor, returns false, leaving the\n cursor unchanged."]
    pub fn aws_byte_cursor_read_be64(cur: *mut aws_byte_cursor, var: *mut u64) -> bool;
    #[doc = " Reads a 32-bit value in network byte order from cur, and places it in host\n byte order into var.\n\n On success, returns true and updates the cursor pointer/length accordingly.\n If there is insufficient space in the cursor, returns false, leaving the\n cursor unchanged."]
    pub fn aws_byte_cursor_read_float_be32(cur: *mut aws_byte_cursor, var: *mut f32) -> bool;
    #[doc = " Reads a 64-bit value in network byte order from cur, and places it in host\n byte order into var.\n\n On success, returns true and updates the cursor pointer/length accordingly.\n If there is insufficient space in the cursor, returns false, leaving the\n cursor unchanged."]
    pub fn aws_byte_cursor_read_float_be64(cur: *mut aws_byte_cursor, var: *mut f64) -> bool;
    #[doc = " Reads 2 hex characters from ASCII/UTF-8 text to produce an 8-bit number.\n Accepts both lowercase 'a'-'f' and uppercase 'A'-'F'.\n For example: \"0F\" produces 15.\n\n On success, returns true and advances the cursor by 2.\n If there is insufficient space in the cursor or an invalid character\n is encountered, returns false, leaving the cursor unchanged."]
    pub fn aws_byte_cursor_read_hex_u8(cur: *mut aws_byte_cursor, var: *mut u8) -> bool;
    #[doc = " Appends a sub-buffer to the specified buffer.\n\n If the buffer has at least `len' bytes remaining (buffer->capacity - buffer->len >= len),\n then buffer->len is incremented by len, and an aws_byte_buf is assigned to *output corresponding\n to the last len bytes of the input buffer. The aws_byte_buf at *output will have a null\n allocator, a zero initial length, and a capacity of 'len'. The function then returns true.\n\n If there is insufficient space, then this function nulls all fields in *output and returns\n false."]
    pub fn aws_byte_buf_advance(
        buffer: *mut aws_byte_buf,
        output: *mut aws_byte_buf,
        len: usize,
    ) -> bool;
    #[doc = " Write specified number of bytes from array to byte buffer.\n\n On success, returns true and updates the buffer length accordingly.\n If there is insufficient space in the buffer, returns false, leaving the\n buffer unchanged."]
    pub fn aws_byte_buf_write(buf: *mut aws_byte_buf, src: *const u8, len: usize) -> bool;
    #[doc = " Copies all bytes from buffer to buffer.\n\n On success, returns true and updates the buffer /length accordingly.\n If there is insufficient space in the buffer, returns false, leaving the\n buffer unchanged."]
    pub fn aws_byte_buf_write_from_whole_buffer(buf: *mut aws_byte_buf, src: aws_byte_buf) -> bool;
    #[doc = " Copies all bytes from buffer to buffer.\n\n On success, returns true and updates the buffer /length accordingly.\n If there is insufficient space in the buffer, returns false, leaving the\n buffer unchanged."]
    pub fn aws_byte_buf_write_from_whole_cursor(
        buf: *mut aws_byte_buf,
        src: aws_byte_cursor,
    ) -> bool;
    #[doc = " Without increasing buf's capacity, write as much as possible from advancing_cursor into buf.\n\n buf's len is updated accordingly.\n advancing_cursor is advanced so it contains the remaining unwritten parts.\n Returns the section of advancing_cursor which was written.\n\n This function cannot fail. If buf is full (len == capacity) or advancing_len has 0 length,\n then buf and advancing_cursor are not altered and a cursor with 0 length is returned.\n\n Example: Given a buf with 2 bytes of space available and advancing_cursor with contents \"abc\".\n \"ab\" will be written to buf and buf->len will increase 2 and become equal to buf->capacity.\n advancing_cursor will advance so its contents become the unwritten \"c\".\n The returned cursor's contents will be the \"ab\" from the original advancing_cursor."]
    pub fn aws_byte_buf_write_to_capacity(
        buf: *mut aws_byte_buf,
        advancing_cursor: *mut aws_byte_cursor,
    ) -> aws_byte_cursor;
    #[doc = " Copies one byte to buffer.\n\n On success, returns true and updates the cursor /length\naccordingly.\n\n If there is insufficient space in the buffer, returns false, leaving the\n buffer unchanged."]
    pub fn aws_byte_buf_write_u8(buf: *mut aws_byte_buf, c: u8) -> bool;
    #[doc = " Writes one byte repeatedly to buffer (like memset)\n\n If there is insufficient space in the buffer, returns false, leaving the\n buffer unchanged."]
    pub fn aws_byte_buf_write_u8_n(buf: *mut aws_byte_buf, c: u8, count: usize) -> bool;
    #[doc = " Writes a 16-bit integer in network byte order (big endian) to buffer.\n\n On success, returns true and updates the buffer /length accordingly.\n If there is insufficient space in the buffer, returns false, leaving the\n buffer unchanged."]
    pub fn aws_byte_buf_write_be16(buf: *mut aws_byte_buf, x: u16) -> bool;
    #[doc = " Writes low 24-bits (3 bytes) of an unsigned integer in network byte order (big endian) to buffer.\n Ex: If x is 0x00AABBCC then {0xAA, 0xBB, 0xCC} is written to buffer.\n\n On success, returns true and updates the buffer /length accordingly.\n If there is insufficient space in the buffer, or x's value cannot fit in 3 bytes,\n returns false, leaving the buffer unchanged."]
    pub fn aws_byte_buf_write_be24(buf: *mut aws_byte_buf, x: u32) -> bool;
    #[doc = " Writes a 32-bit integer in network byte order (big endian) to buffer.\n\n On success, returns true and updates the buffer /length accordingly.\n If there is insufficient space in the buffer, returns false, leaving the\n buffer unchanged."]
    pub fn aws_byte_buf_write_be32(buf: *mut aws_byte_buf, x: u32) -> bool;
    #[doc = " Writes a 32-bit float in network byte order (big endian) to buffer.\n\n On success, returns true and updates the buffer /length accordingly.\n If there is insufficient space in the buffer, returns false, leaving the\n buffer unchanged."]
    pub fn aws_byte_buf_write_float_be32(buf: *mut aws_byte_buf, x: f32) -> bool;
    #[doc = " Writes a 64-bit integer in network byte order (big endian) to buffer.\n\n On success, returns true and updates the buffer /length accordingly.\n If there is insufficient space in the buffer, returns false, leaving the\n buffer unchanged."]
    pub fn aws_byte_buf_write_be64(buf: *mut aws_byte_buf, x: u64) -> bool;
    #[doc = " Writes a 64-bit float in network byte order (big endian) to buffer.\n\n On success, returns true and updates the buffer /length accordingly.\n If there is insufficient space in the buffer, returns false, leaving the\n buffer unchanged."]
    pub fn aws_byte_buf_write_float_be64(buf: *mut aws_byte_buf, x: f64) -> bool;
    #[doc = " Like isalnum(), but ignores C locale.\n Returns true if ch has the value of ASCII/UTF-8: 'a'-'z', 'A'-'Z', or '0'-'9'."]
    pub fn aws_isalnum(ch: u8) -> bool;
    #[doc = " Like isalpha(), but ignores C locale.\n Returns true if ch has the value of ASCII/UTF-8: 'a'-'z' or 'A'-'Z'."]
    pub fn aws_isalpha(ch: u8) -> bool;
    #[doc = " Like isdigit().\n Returns true if ch has the value of ASCII/UTF-8: '0'-'9'.\n\n Note: C's built-in isdigit() is also supposed to ignore the C locale,\n but cppreference.com claims \"some implementations (e.g. Microsoft in 1252 codepage)\n may classify additional single-byte characters as digits\""]
    pub fn aws_isdigit(ch: u8) -> bool;
    #[doc = " Like isxdigit().\n Returns true if ch has the value of ASCII/UTF-8: '0'-'9', 'a'-'f', or 'A'-'F'.\n\n Note: C's built-in isxdigit() is also supposed to ignore the C locale,\n but cppreference.com claims \"some implementations (e.g. Microsoft in 1252 codepage)\n may classify additional single-byte characters as digits\""]
    pub fn aws_isxdigit(ch: u8) -> bool;
    #[doc = " Like isspace(), but ignores C locale.\n Return true if ch has the value of ASCII/UTF-8: space (0x20), form feed (0x0C),\n line feed (0x0A), carriage return (0x0D), horizontal tab (0x09), or vertical tab (0x0B)."]
    pub fn aws_isspace(ch: u8) -> bool;
    #[doc = " Read entire cursor as ASCII/UTF-8 unsigned base-10 number.\n Stricter than strtoull(), which allows whitespace and inputs that start with \"0x\"\n\n Examples:\n \"0\" -> 0\n \"123\" -> 123\n \"00004\" -> 4 // leading zeros ok\n\n Rejects things like:\n \"-1\" // negative numbers not allowed\n \"1,000\" // only characters 0-9 allowed\n \"\" // blank string not allowed\n \" 0 \" // whitespace not allowed\n \"0x0\" // hex not allowed\n \"FF\" // hex not allowed\n \"999999999999999999999999999999999999999999\" // larger than max u64"]
    pub fn aws_byte_cursor_utf8_parse_u64(
        cursor: aws_byte_cursor,
        dst: *mut u64,
    ) -> ::core::ffi::c_int;
    #[doc = " Read entire cursor as ASCII/UTF-8 unsigned base-16 number with NO \"0x\" prefix.\n\n Examples:\n \"F\" -> 15\n \"000000ff\" -> 255 // leading zeros ok\n \"Ff\" -> 255 // mixed case ok\n \"123\" -> 291\n \"FFFFFFFFFFFFFFFF\" -> 18446744073709551616 // max u64\n\n Rejects things like:\n \"0x0\" // 0x prefix not allowed\n \"\" // blank string not allowed\n \" F \" // whitespace not allowed\n \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" // larger than max u64"]
    pub fn aws_byte_cursor_utf8_parse_u64_hex(
        cursor: aws_byte_cursor,
        dst: *mut u64,
    ) -> ::core::ffi::c_int;
    #[doc = " Initializes a hash map with initial capacity for 'size' elements\n without resizing. Uses hash_fn to compute the hash of each element.\n equals_fn to compute equality of two keys.  Whenever an element is\n removed without being returned, destroy_key_fn is run on the pointer\n to the key and destroy_value_fn is run on the pointer to the value.\n Either or both may be NULL if a callback is not desired in this case."]
    pub fn aws_hash_table_init(
        map: *mut aws_hash_table,
        alloc: *mut aws_allocator,
        size: usize,
        hash_fn: aws_hash_fn,
        equals_fn: aws_hash_callback_eq_fn,
        destroy_key_fn: aws_hash_callback_destroy_fn,
        destroy_value_fn: aws_hash_callback_destroy_fn,
    ) -> ::core::ffi::c_int;
    #[doc = " Deletes every element from map and frees all associated memory.\n destroy_fn will be called for each element.  aws_hash_table_init\n must be called before reusing the hash table.\n\n This method is idempotent."]
    pub fn aws_hash_table_clean_up(map: *mut aws_hash_table);
    #[doc = " Safely swaps two hash tables. Note that we swap the entirety of the hash\n table, including which allocator is associated.\n\n Neither hash table is required to be initialized; if one or both is\n uninitialized, then the uninitialized state is also swapped."]
    pub fn aws_hash_table_swap(a: *mut aws_hash_table, b: *mut aws_hash_table);
    #[doc = " Moves the hash table in 'from' to 'to'. After this move, 'from' will\n be identical to the state of the original 'to' hash table, and 'to'\n will be in the same state as if it had been passed to aws_hash_table_clean_up\n (that is, it will have no memory allocated, and it will be safe to\n either discard it or call aws_hash_table_clean_up again).\n\n Note that 'to' will not be cleaned up. You should make sure that 'to'\n is either uninitialized or cleaned up before moving a hashtable into\n it."]
    pub fn aws_hash_table_move(to: *mut aws_hash_table, from: *mut aws_hash_table);
    #[doc = " Returns the current number of entries in the table."]
    pub fn aws_hash_table_get_entry_count(map: *const aws_hash_table) -> usize;
    #[doc = " Returns an iterator to be used for iterating through a hash table.\n Iterator will already point to the first element of the table it finds,\n which can be accessed as iter.element.\n\n This function cannot fail, but if there are no elements in the table,\n the returned iterator will return true for aws_hash_iter_done(&iter)."]
    pub fn aws_hash_iter_begin(map: *const aws_hash_table) -> aws_hash_iter;
    #[doc = " Returns true if iterator is done iterating through table, false otherwise.\n If this is true, the iterator will not include an element of the table."]
    pub fn aws_hash_iter_done(iter: *const aws_hash_iter) -> bool;
    #[doc = " Updates iterator so that it points to next element of hash table.\n\n This and the two previous functions are designed to be used together with\n the following idiom:\n\n for (struct aws_hash_iter iter = aws_hash_iter_begin(&map);\n      !aws_hash_iter_done(&iter); aws_hash_iter_next(&iter)) {\n     const key_type key = *(const key_type *)iter.element.key;\n     value_type value = *(value_type *)iter.element.value;\n     // etc.\n }\n\n Note that calling this on an iter which is \"done\" is idempotent:\n i.e. it will return another iter which is \"done\"."]
    pub fn aws_hash_iter_next(iter: *mut aws_hash_iter);
    #[doc = " Deletes the element currently pointed-to by the hash iterator.\n After calling this method, the element member of the iterator\n should not be accessed until the next call to aws_hash_iter_next.\n\n @param destroy_contents If true, the destructors for the key and value\n  will be called."]
    pub fn aws_hash_iter_delete(iter: *mut aws_hash_iter, destroy_contents: bool);
    #[doc = " Attempts to locate an element at key.  If the element is found, a\n pointer to the value is placed in *p_elem; if it is not found,\n *pElem is set to NULL. Either way, AWS_OP_SUCCESS is returned.\n\n This method does not change the state of the hash table. Therefore, it\n is safe to call _find from multiple threads on the same hash table,\n provided no mutating operations happen in parallel.\n\n Calling code may update the value in the hash table by modifying **pElem\n after a successful find. However, this pointer is not guaranteed to\n remain usable after a subsequent call to _put, _delete, _clear, or\n _clean_up."]
    pub fn aws_hash_table_find(
        map: *const aws_hash_table,
        key: *const ::core::ffi::c_void,
        p_elem: *mut *mut aws_hash_element,
    ) -> ::core::ffi::c_int;
    #[doc = " Attempts to locate an element at key. If no such element was found,\n creates a new element, with value initialized to NULL. In either case, a\n pointer to the element is placed in *p_elem.\n\n If was_created is non-NULL, *was_created is set to 0 if an existing\n element was found, or 1 is a new element was created.\n\n Returns AWS_OP_SUCCESS if an item was found or created.\n Raises AWS_ERROR_OOM if hash table expansion was required and memory\n allocation failed."]
    pub fn aws_hash_table_create(
        map: *mut aws_hash_table,
        key: *const ::core::ffi::c_void,
        p_elem: *mut *mut aws_hash_element,
        was_created: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    #[doc = " Inserts a new element at key, with the given value. If another element\n exists at that key, the old element will be overwritten; both old key and\n value objects will be destroyed.\n\n If was_created is non-NULL, *was_created is set to 0 if an existing\n element was found, or 1 is a new element was created.\n\n Returns AWS_OP_SUCCESS if an item was found or created.\n Raises AWS_ERROR_OOM if hash table expansion was required and memory\n allocation failed."]
    pub fn aws_hash_table_put(
        map: *mut aws_hash_table,
        key: *const ::core::ffi::c_void,
        value: *mut ::core::ffi::c_void,
        was_created: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    #[doc = " Removes element at key. Always returns AWS_OP_SUCCESS.\n\n If pValue is non-NULL, the existing value (if any) is moved into\n (*value) before removing from the table, and destroy_fn is _not_\n invoked. If pValue is NULL, then (if the element existed) destroy_fn\n will be invoked on the element being removed.\n\n If was_present is non-NULL, it is set to 0 if the element was\n not present, or 1 if it was present (and is now removed)."]
    pub fn aws_hash_table_remove(
        map: *mut aws_hash_table,
        key: *const ::core::ffi::c_void,
        p_value: *mut aws_hash_element,
        was_present: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    #[doc = " Removes element already known (typically by find()).\n\n p_value should point to a valid element returned by create() or find().\n\n NOTE: DO NOT call this method from inside of a aws_hash_table_foreach callback, return\n AWS_COMMON_HASH_TABLE_ITER_DELETE instead."]
    pub fn aws_hash_table_remove_element(
        map: *mut aws_hash_table,
        p_value: *mut aws_hash_element,
    ) -> ::core::ffi::c_int;
    #[doc = " Iterates through every element in the map and invokes the callback on\n that item. Iteration is performed in an arbitrary, implementation-defined\n order, and is not guaranteed to be consistent across invocations.\n\n The callback may change the value associated with the key by overwriting\n the value pointed-to by value. In this case, the on_element_removed\n callback will not be invoked, unless the callback invokes\n AWS_COMMON_HASH_TABLE_ITER_DELETE (in which case the on_element_removed\n is given the updated value).\n\n The callback must return a bitmask of zero or more of the following values\n ORed together:\n\n # AWS_COMMON_HASH_TABLE_ITER_CONTINUE - Continues iteration to the next\n     element (if not set, iteration stops)\n # AWS_COMMON_HASH_TABLE_ITER_DELETE   - Deletes the current value and\n     continues iteration.  destroy_fn will NOT be invoked.\n # AWS_COMMON_HASH_TABLE_ITER_ERROR   - Stop iteration with error.\n     No action will be taken for the current value and the value before this.\n     No rolling back. The deleted value before will NOT be back.\n     aws_hash_table_foreach returns AWS_OP_ERR after stropping the iteration.\n\n Invoking any method which may change the contents of the hashtable\n during iteration results in undefined behavior. However, you may safely\n invoke non-mutating operations during an iteration.\n\n This operation is mutating only if AWS_COMMON_HASH_TABLE_ITER_DELETE\n is returned at some point during iteration. Otherwise, it is non-mutating\n and is safe to invoke in parallel with other non-mutating operations."]
    pub fn aws_hash_table_foreach(
        map: *mut aws_hash_table,
        callback: ::core::option::Option<
            unsafe extern "C" fn(
                context: *mut ::core::ffi::c_void,
                p_element: *mut aws_hash_element,
            ) -> ::core::ffi::c_int,
        >,
        context: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    #[doc = " Compares two hash tables for equality. Both hash tables must have equivalent\n key comparators; values will be compared using the comparator passed into this\n function. The key hash function does not need to be equivalent between the\n two hash tables."]
    pub fn aws_hash_table_eq(
        a: *const aws_hash_table,
        b: *const aws_hash_table,
        value_eq: aws_hash_callback_eq_fn,
    ) -> bool;
    #[doc = " Removes every element from the hash map. destroy_fn will be called for\n each element."]
    pub fn aws_hash_table_clear(map: *mut aws_hash_table);
    #[doc = " Convenience hash function for NULL-terminated C-strings"]
    pub fn aws_hash_c_string(item: *const ::core::ffi::c_void) -> u64;
    #[doc = " Convenience hash function for struct aws_strings.\n Hash is same as used on the string bytes by aws_hash_c_string."]
    pub fn aws_hash_string(item: *const ::core::ffi::c_void) -> u64;
    #[doc = " Convenience hash function for struct aws_byte_cursor.\n Hash is same as used on the string bytes by aws_hash_c_string."]
    pub fn aws_hash_byte_cursor_ptr(item: *const ::core::ffi::c_void) -> u64;
    #[doc = " Convenience hash function which hashes the pointer value directly,\n without dereferencing.  This can be used in cases where pointer identity\n is desired, or where a uintptr_t is encoded into a const void *."]
    pub fn aws_hash_ptr(item: *const ::core::ffi::c_void) -> u64;
    pub fn aws_hash_combine(item1: u64, item2: u64) -> u64;
    #[doc = " Convenience eq callback for NULL-terminated C-strings"]
    pub fn aws_hash_callback_c_str_eq(
        a: *const ::core::ffi::c_void,
        b: *const ::core::ffi::c_void,
    ) -> bool;
    #[doc = " Convenience eq callback for AWS strings"]
    pub fn aws_hash_callback_string_eq(
        a: *const ::core::ffi::c_void,
        b: *const ::core::ffi::c_void,
    ) -> bool;
    #[doc = " Convenience destroy callback for AWS strings"]
    pub fn aws_hash_callback_string_destroy(a: *mut ::core::ffi::c_void);
    #[doc = " Equality function which compares pointer equality."]
    pub fn aws_ptr_eq(a: *const ::core::ffi::c_void, b: *const ::core::ffi::c_void) -> bool;
    #[doc = " Best-effort check of hash_table_state data-structure invariants"]
    pub fn aws_hash_table_is_valid(map: *const aws_hash_table) -> bool;
    #[doc = " Given a pointer to a hash_iter, checks that it is well-formed, with all data-structure invariants."]
    pub fn aws_hash_iter_is_valid(iter: *const aws_hash_iter) -> bool;
    #[doc = " Initializes the table. Sets up the underlying hash table and linked list.\n For the other parameters, see aws/common/hash_table.h. Hash table\n semantics of these arguments are preserved."]
    pub fn aws_linked_hash_table_init(
        table: *mut aws_linked_hash_table,
        allocator: *mut aws_allocator,
        hash_fn: aws_hash_fn,
        equals_fn: aws_hash_callback_eq_fn,
        destroy_key_fn: aws_hash_callback_destroy_fn,
        destroy_value_fn: aws_hash_callback_destroy_fn,
        initial_item_count: usize,
    ) -> ::core::ffi::c_int;
    #[doc = " Cleans up the table. Elements in the table will be evicted and cleanup\n callbacks will be invoked."]
    pub fn aws_linked_hash_table_clean_up(table: *mut aws_linked_hash_table);
    #[doc = " Finds element in the table by key. If found, AWS_OP_SUCCESS will be\n returned. If not found, AWS_OP_SUCCESS will be returned and *p_value will be\n NULL.\n\n If any errors occur AWS_OP_ERR will be returned."]
    pub fn aws_linked_hash_table_find(
        table: *mut aws_linked_hash_table,
        key: *const ::core::ffi::c_void,
        p_value: *mut *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    #[doc = " Finds element in the table by key. If found, AWS_OP_SUCCESS will be returned and the item will be moved to the back\n of the list.\n If not found, AWS_OP_SUCCESS will be returned and *p_value will be NULL.\n\n Note: this will change the order of elements"]
    pub fn aws_linked_hash_table_find_and_move_to_back(
        table: *mut aws_linked_hash_table,
        key: *const ::core::ffi::c_void,
        p_value: *mut *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    #[doc = " Puts `p_value` at `key`. If an element is already stored at `key` it will be replaced."]
    pub fn aws_linked_hash_table_put(
        table: *mut aws_linked_hash_table,
        key: *const ::core::ffi::c_void,
        p_value: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    #[doc = " Removes item at `key` from the table."]
    pub fn aws_linked_hash_table_remove(
        table: *mut aws_linked_hash_table,
        key: *const ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    #[doc = " Clears all items from the table."]
    pub fn aws_linked_hash_table_clear(table: *mut aws_linked_hash_table);
    #[doc = " returns number of elements in the table."]
    pub fn aws_linked_hash_table_get_element_count(table: *const aws_linked_hash_table) -> usize;
    #[doc = " Move the aws_linked_hash_table_node to the end of the list.\n\n Note: this will change the order of elements"]
    pub fn aws_linked_hash_table_move_node_to_end_of_list(
        table: *mut aws_linked_hash_table,
        node: *mut aws_linked_hash_table_node,
    );
    #[doc = " returns the underlying linked list for iteration.\n\n The returned list has nodes of the type: aws_linked_hash_table_node. Use AWS_CONTAINER_OF for access to the element."]
    pub fn aws_linked_hash_table_get_iteration_list(
        table: *const aws_linked_hash_table,
    ) -> *const aws_linked_list;
    pub fn aws_cache_base_default_destroy(cache: *mut aws_cache);
    pub fn aws_cache_base_default_find(
        cache: *mut aws_cache,
        key: *const ::core::ffi::c_void,
        p_value: *mut *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    pub fn aws_cache_base_default_remove(
        cache: *mut aws_cache,
        key: *const ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    pub fn aws_cache_base_default_clear(cache: *mut aws_cache);
    pub fn aws_cache_base_default_get_element_count(cache: *const aws_cache) -> usize;
    #[doc = " Cleans up the cache. Elements in the cache will be evicted and cleanup\n callbacks will be invoked."]
    pub fn aws_cache_destroy(cache: *mut aws_cache);
    #[doc = " Finds element in the cache by key. If found, *p_value will hold the stored value, and AWS_OP_SUCCESS will be\n returned. If not found, AWS_OP_SUCCESS will be returned and *p_value will be NULL.\n\n If any errors occur AWS_OP_ERR will be returned."]
    pub fn aws_cache_find(
        cache: *mut aws_cache,
        key: *const ::core::ffi::c_void,
        p_value: *mut *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    #[doc = " Puts `p_value` at `key`. If an element is already stored at `key` it will be replaced. If the cache is already full,\n an item will be removed based on the cache policy."]
    pub fn aws_cache_put(
        cache: *mut aws_cache,
        key: *const ::core::ffi::c_void,
        p_value: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    #[doc = " Removes item at `key` from the cache."]
    pub fn aws_cache_remove(
        cache: *mut aws_cache,
        key: *const ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    #[doc = " Clears all items from the cache."]
    pub fn aws_cache_clear(cache: *mut aws_cache);
    #[doc = " Returns the number of elements in the cache."]
    pub fn aws_cache_get_element_count(cache: *const aws_cache) -> usize;
    #[doc = " Get ticks in nanoseconds (usually 100 nanosecond precision) on the high resolution clock (most-likely TSC). This\n clock has no bearing on the actual system time. On success, timestamp will be set."]
    pub fn aws_high_res_clock_get_ticks(timestamp: *mut u64) -> ::core::ffi::c_int;
    #[doc = " Get ticks in nanoseconds (usually 100 nanosecond precision) on the system clock. Reflects actual system time via\n nanoseconds since unix epoch. Use with care since an inaccurately set clock will probably cause bugs. On success,\n timestamp will be set."]
    pub fn aws_sys_clock_get_ticks(timestamp: *mut u64) -> ::core::ffi::c_int;
    #[doc = " Initialized to 1 (for where the first argument would be). As arguments are parsed, this number is the index\n of the next argument to parse. Reset this to 1 to parse another set of arguments, or to rerun the parser."]
    pub static mut aws_cli_optind: ::core::ffi::c_int;
    #[doc = " If an option has an argument, when the option is encountered, this will be set to the argument portion."]
    pub static mut aws_cli_optarg: *const ::core::ffi::c_char;
    #[doc = " If 0x02 was returned by aws_cli_getopt_long(), this value will be set to the argument encountered."]
    pub static mut aws_cli_positional_arg: *const ::core::ffi::c_char;
    #[doc = " A mostly compliant implementation of posix getopt_long(). Parses command-line arguments. argc is the number of\n command line arguments passed in argv. optstring contains the legitimate option characters. The option characters\n correspond to aws_cli_option::val. If the character is followed by a :, the option requires an argument. If it is\n followed by '::', the argument is optional (not implemented yet).\n\n  longopts, is an array of struct aws_cli_option. These are the allowed options for the program.\n  The last member of the array must be zero initialized.\n\n  If longindex is non-null, it will be set to the index in longopts, for the found option.\n\n  Returns option val if it was found, '?' if an option was encountered that was not specified in the option string,\n 0x02 (START_OF_TEXT) will be returned if a positional argument was encountered. returns -1 when all arguments that\n can be parsed have been parsed."]
    pub fn aws_cli_getopt_long(
        argc: ::core::ffi::c_int,
        argv: *const [*mut ::core::ffi::c_char; 0usize],
        optstring: *const ::core::ffi::c_char,
        longopts: *const aws_cli_option,
        longindex: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    #[doc = " Resets global parser state for use in another parser run for the application."]
    pub fn aws_cli_reset_state();
    #[doc = " Dispatches the current command line arguments with a subcommand from the second input argument in argv[], if\n dispatch table contains a command that matches the argument. When the command is dispatched, argc and argv will be\n updated to reflect the new argument count. The cli options are required to come after the subcommand. If either, no\n dispatch was found or there was no argument passed to the program, this function will return AWS_OP_ERR. Check\n aws_last_error() for details on the error.\n @param argc number of arguments passed to int main()\n @param argv the arguments passed to int main()\n @param parse_cb, optional, specify NULL if you don't want to handle this. This argument is for parsing \"meta\"\n commands from the command line options prior to dispatch occurring.\n @param dispatch_table table containing functions and command name to dispatch on.\n @param table_length number of entries in dispatch_table.\n @return AWS_OP_SUCCESS(0) on success, AWS_OP_ERR(-1) on failure"]
    pub fn aws_cli_dispatch_on_subcommand(
        argc: ::core::ffi::c_int,
        argv: *const [*mut ::core::ffi::c_char; 0usize],
        dispatch_table: *mut aws_cli_subcommand_dispatch,
        table_length: ::core::ffi::c_int,
        user_data: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    #[doc = " Initializes a condition variable."]
    pub fn aws_condition_variable_init(
        condition_variable: *mut aws_condition_variable,
    ) -> ::core::ffi::c_int;
    #[doc = " Cleans up a condition variable."]
    pub fn aws_condition_variable_clean_up(condition_variable: *mut aws_condition_variable);
    #[doc = " Notifies/Wakes one waiting thread"]
    pub fn aws_condition_variable_notify_one(
        condition_variable: *mut aws_condition_variable,
    ) -> ::core::ffi::c_int;
    #[doc = " Notifies/Wakes all waiting threads."]
    pub fn aws_condition_variable_notify_all(
        condition_variable: *mut aws_condition_variable,
    ) -> ::core::ffi::c_int;
    #[doc = " Waits the calling thread on a notification from another thread."]
    pub fn aws_condition_variable_wait(
        condition_variable: *mut aws_condition_variable,
        mutex: *mut aws_mutex,
    ) -> ::core::ffi::c_int;
    #[doc = " Waits the calling thread on a notification from another thread. If predicate returns false, the wait is reentered,\n otherwise control returns to the caller."]
    pub fn aws_condition_variable_wait_pred(
        condition_variable: *mut aws_condition_variable,
        mutex: *mut aws_mutex,
        pred: aws_condition_predicate_fn,
        pred_ctx: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    #[doc = " Waits the calling thread on a notification from another thread. Times out after time_to_wait. time_to_wait is in\n nanoseconds."]
    pub fn aws_condition_variable_wait_for(
        condition_variable: *mut aws_condition_variable,
        mutex: *mut aws_mutex,
        time_to_wait: i64,
    ) -> ::core::ffi::c_int;
    #[doc = " Waits the calling thread on a notification from another thread. Times out after time_to_wait. time_to_wait is in\n nanoseconds. If predicate returns false, the wait is reentered, otherwise control returns to the caller."]
    pub fn aws_condition_variable_wait_for_pred(
        condition_variable: *mut aws_condition_variable,
        mutex: *mut aws_mutex,
        time_to_wait: i64,
        pred: aws_condition_predicate_fn,
        pred_ctx: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    #[doc = " Returns true if a cpu feature is supported, false otherwise."]
    pub fn aws_cpu_has_feature(feature_name: aws_cpu_feature_name) -> bool;
    #[doc = " Attempts to acquire a system-wide (not per process or per user) lock scoped by instance_nonce.\n For any given unique nonce, a lock will be returned by the first caller. Subsequent calls will\n return NULL and raise AWS_ERROR_MUTEX_CALLER_NOT_OWNER\n until the either the process owning the lock exits or the program owning the lock\n calls aws_cross_process_lock_release() explicitly.\n\n If the process exits before the lock is released, the kernel will unlock it for the next consumer."]
    pub fn aws_cross_process_lock_try_acquire(
        allocator: *mut aws_allocator,
        instance_nonce: aws_byte_cursor,
    ) -> *mut aws_cross_process_lock;
    #[doc = " Releases the lock so the next caller (may be another process) can get an instance of the lock."]
    pub fn aws_cross_process_lock_release(instance_lock: *mut aws_cross_process_lock);
    #[doc = " Initializes dt to be the current system time."]
    pub fn aws_date_time_init_now(dt: *mut aws_date_time);
    #[doc = " Initializes dt to be the time represented in milliseconds since unix epoch."]
    pub fn aws_date_time_init_epoch_millis(dt: *mut aws_date_time, ms_since_epoch: u64);
    #[doc = " Initializes dt to be the time represented in seconds.millis since unix epoch."]
    pub fn aws_date_time_init_epoch_secs(dt: *mut aws_date_time, sec_ms: f64);
    #[doc = " Initializes dt to be the time represented by date_str in format 'fmt'. Returns AWS_OP_SUCCESS if the\n string was successfully parsed, returns  AWS_OP_ERR if parsing failed.\n\n Notes for AWS_DATE_FORMAT_RFC822:\n If no time zone information is provided, it is assumed to be local time (please don't do this).\n\n If the time zone is something other than something indicating Universal Time (e.g. Z, UT, UTC, or GMT) or an offset\n from UTC (e.g. +0100, -0700), parsing will fail.\n\n Really, it's just better if you always use Universal Time."]
    pub fn aws_date_time_init_from_str(
        dt: *mut aws_date_time,
        date_str: *const aws_byte_buf,
        fmt: aws_date_format,
    ) -> ::core::ffi::c_int;
    #[doc = " aws_date_time_init variant that takes a byte_cursor rather than a byte_buf"]
    pub fn aws_date_time_init_from_str_cursor(
        dt: *mut aws_date_time,
        date_str_cursor: *const aws_byte_cursor,
        fmt: aws_date_format,
    ) -> ::core::ffi::c_int;
    #[doc = " Copies the current time as a formatted date string in local time into output_buf. If buffer is too small, it will\n return AWS_OP_ERR. A good size suggestion is AWS_DATE_TIME_STR_MAX_LEN bytes. AWS_DATE_FORMAT_AUTO_DETECT is not\n allowed."]
    pub fn aws_date_time_to_local_time_str(
        dt: *const aws_date_time,
        fmt: aws_date_format,
        output_buf: *mut aws_byte_buf,
    ) -> ::core::ffi::c_int;
    #[doc = " Copies the current time as a formatted date string in utc time into output_buf. If buffer is too small, it will\n return AWS_OP_ERR. A good size suggestion is AWS_DATE_TIME_STR_MAX_LEN bytes. AWS_DATE_FORMAT_AUTO_DETECT is not\n allowed."]
    pub fn aws_date_time_to_utc_time_str(
        dt: *const aws_date_time,
        fmt: aws_date_format,
        output_buf: *mut aws_byte_buf,
    ) -> ::core::ffi::c_int;
    #[doc = " Copies the current time as a formatted short date string in local time into output_buf. If buffer is too small, it\n will return AWS_OP_ERR. A good size suggestion is AWS_DATE_TIME_STR_MAX_LEN bytes. AWS_DATE_FORMAT_AUTO_DETECT is not\n allowed."]
    pub fn aws_date_time_to_local_time_short_str(
        dt: *const aws_date_time,
        fmt: aws_date_format,
        output_buf: *mut aws_byte_buf,
    ) -> ::core::ffi::c_int;
    #[doc = " Copies the current time as a formatted short date string in utc time into output_buf. If buffer is too small, it will\n return AWS_OP_ERR. A good size suggestion is AWS_DATE_TIME_STR_MAX_LEN bytes. AWS_DATE_FORMAT_AUTO_DETECT is not\n allowed."]
    pub fn aws_date_time_to_utc_time_short_str(
        dt: *const aws_date_time,
        fmt: aws_date_format,
        output_buf: *mut aws_byte_buf,
    ) -> ::core::ffi::c_int;
    pub fn aws_date_time_as_epoch_secs(dt: *const aws_date_time) -> f64;
    pub fn aws_date_time_as_nanos(dt: *const aws_date_time) -> u64;
    pub fn aws_date_time_as_millis(dt: *const aws_date_time) -> u64;
    pub fn aws_date_time_year(dt: *const aws_date_time, local_time: bool) -> u16;
    pub fn aws_date_time_month(dt: *const aws_date_time, local_time: bool) -> aws_date_month;
    pub fn aws_date_time_month_day(dt: *const aws_date_time, local_time: bool) -> u8;
    pub fn aws_date_time_day_of_week(
        dt: *const aws_date_time,
        local_time: bool,
    ) -> aws_date_day_of_week;
    pub fn aws_date_time_hour(dt: *const aws_date_time, local_time: bool) -> u8;
    pub fn aws_date_time_minute(dt: *const aws_date_time, local_time: bool) -> u8;
    pub fn aws_date_time_second(dt: *const aws_date_time, local_time: bool) -> u8;
    pub fn aws_date_time_dst(dt: *const aws_date_time, local_time: bool) -> bool;
    #[doc = " returns the difference of a and b (a - b) in seconds."]
    pub fn aws_date_time_diff(a: *const aws_date_time, b: *const aws_date_time) -> time_t;
    #[doc = " Get an unpredictably random 64bit number, suitable for cryptographic use."]
    pub fn aws_device_random_u64(output: *mut u64) -> ::core::ffi::c_int;
    #[doc = " Get an unpredictably random 32bit number, suitable for cryptographic use."]
    pub fn aws_device_random_u32(output: *mut u32) -> ::core::ffi::c_int;
    #[doc = " Get an unpredictably random 16bit number, suitable for cryptographic use."]
    pub fn aws_device_random_u16(output: *mut u16) -> ::core::ffi::c_int;
    #[doc = " Get an unpredictably random 8bit number, suitable for cryptographic use."]
    pub fn aws_device_random_u8(output: *mut u8) -> ::core::ffi::c_int;
    #[doc = " Fill the rest of a buffer with unpredictably random bytes, suitable for cryptographic use."]
    pub fn aws_device_random_buffer(output: *mut aws_byte_buf) -> ::core::ffi::c_int;
    #[doc = " Write N unpredictably random bytes to a buffer, suitable for cryptographic use.\n If there is insufficient space in the buffer, AWS_ERROR_SHORT_BUFFER is raised\n and the buffer will be unchanged."]
    pub fn aws_device_random_buffer_append(
        output: *mut aws_byte_buf,
        n: usize,
    ) -> ::core::ffi::c_int;
    pub fn aws_hex_compute_encoded_len(
        to_encode_len: usize,
        encoded_length: *mut usize,
    ) -> ::core::ffi::c_int;
    pub fn aws_hex_encode(
        to_encode: *const aws_byte_cursor,
        output: *mut aws_byte_buf,
    ) -> ::core::ffi::c_int;
    pub fn aws_hex_encode_append_dynamic(
        to_encode: *const aws_byte_cursor,
        output: *mut aws_byte_buf,
    ) -> ::core::ffi::c_int;
    pub fn aws_hex_compute_decoded_len(
        to_decode_len: usize,
        decoded_len: *mut usize,
    ) -> ::core::ffi::c_int;
    pub fn aws_hex_decode(
        to_decode: *const aws_byte_cursor,
        output: *mut aws_byte_buf,
    ) -> ::core::ffi::c_int;
    pub fn aws_base64_compute_encoded_len(
        to_encode_len: usize,
        encoded_len: *mut usize,
    ) -> ::core::ffi::c_int;
    pub fn aws_base64_encode(
        to_encode: *const aws_byte_cursor,
        output: *mut aws_byte_buf,
    ) -> ::core::ffi::c_int;
    pub fn aws_base64_compute_decoded_len(
        to_decode: *const aws_byte_cursor,
        decoded_len: *mut usize,
    ) -> ::core::ffi::c_int;
    pub fn aws_base64_decode(
        to_decode: *const aws_byte_cursor,
        output: *mut aws_byte_buf,
    ) -> ::core::ffi::c_int;
    #[doc = " Decode a complete string of UTF8/ASCII text.\n Text is always validated according to RFC-3629 (you may perform additional\n validation in the on_codepoint callback).\n The text does not need to begin with a UTF8 BOM.\n If you need to decode text incrementally as you receive it, use aws_utf8_decoder_new() instead.\n\n @param bytes Text to decode.\n @param options Options for decoding. If NULL is passed, the text is simply validated.\n\n @return AWS_OP_SUCCESS if successful.\n An error is raised if the text is not valid, or the on_codepoint callback raises an error."]
    pub fn aws_decode_utf8(
        bytes: aws_byte_cursor,
        options: *const aws_utf8_decoder_options,
    ) -> ::core::ffi::c_int;
    #[doc = " Create a UTF8/ASCII decoder, which can process text incrementally as you receive it.\n Text is always validated according to RFC-3629 (you may perform additional\n validation in the on_codepoint callback).\n The text does not need to begin with a UTF8 BOM.\n To decode text all at once, simply use aws_decode_utf8().\n\n Feed bytes into the decoder with aws_utf8_decoder_update(),\n and call aws_utf8_decoder_finalize() when the text is complete.\n\n @param allocator Allocator\n @param options Options for decoder. If NULL is passed, the text is simply validated."]
    pub fn aws_utf8_decoder_new(
        allocator: *mut aws_allocator,
        options: *const aws_utf8_decoder_options,
    ) -> *mut aws_utf8_decoder;
    pub fn aws_utf8_decoder_destroy(decoder: *mut aws_utf8_decoder);
    pub fn aws_utf8_decoder_reset(decoder: *mut aws_utf8_decoder);
    #[doc = " Update the decoder with more bytes of text.\n The on_codepoint callback will be invoked for each codepoint encountered.\n Raises an error if invalid UTF8 is encountered or the on_codepoint callback reports an error.\n\n Note: You must call aws_utf8_decoder_finalize() when the text is 100% complete,\n to ensure the input was completely valid."]
    pub fn aws_utf8_decoder_update(
        decoder: *mut aws_utf8_decoder,
        bytes: aws_byte_cursor,
    ) -> ::core::ffi::c_int;
    #[doc = " Tell the decoder that you've reached the end of your text.\n Raises AWS_ERROR_INVALID_UTF8 if the text did not end with a complete UTF8 codepoint.\n This also resets the decoder."]
    pub fn aws_utf8_decoder_finalize(decoder: *mut aws_utf8_decoder) -> ::core::ffi::c_int;
    pub fn aws_get_environment_value(
        allocator: *mut aws_allocator,
        variable_name: *const aws_string,
        value_out: *mut *mut aws_string,
    ) -> ::core::ffi::c_int;
    pub fn aws_set_environment_value(
        variable_name: *const aws_string,
        value: *const aws_string,
    ) -> ::core::ffi::c_int;
    pub fn aws_unset_environment_value(variable_name: *const aws_string) -> ::core::ffi::c_int;
    #[doc = " Initializes the first-in-first-out cache. Sets up the underlying linked hash table.\n Once `max_items` elements have been added, the oldest(first-in) item will\n be removed. For the other parameters, see aws/common/hash_table.h. Hash table\n semantics of these arguments are preserved."]
    pub fn aws_cache_new_fifo(
        allocator: *mut aws_allocator,
        hash_fn: aws_hash_fn,
        equals_fn: aws_hash_callback_eq_fn,
        destroy_key_fn: aws_hash_callback_destroy_fn,
        destroy_value_fn: aws_hash_callback_destroy_fn,
        max_items: usize,
    ) -> *mut aws_cache;
    #[doc = " Deprecated - Use aws_fopen_safe() instead, avoid const char * in public APIs.\n Opens file at file_path using mode. Returns the FILE pointer if successful.\n Otherwise, aws_last_error() will contain the error that occurred"]
    pub fn aws_fopen(
        file_path: *const ::core::ffi::c_char,
        mode: *const ::core::ffi::c_char,
    ) -> *mut FILE;
    #[doc = " Opens file at file_path using mode. Returns the FILE pointer if successful.\n Otherwise, aws_last_error() will contain the error that occurred"]
    pub fn aws_fopen_safe(file_path: *const aws_string, mode: *const aws_string) -> *mut FILE;
    #[doc = " Creates a directory if it doesn't currently exist. If the directory already exists, it's ignored and assumed\n successful.\n\n Returns AWS_OP_SUCCESS on success. Otherwise, check aws_last_error()."]
    pub fn aws_directory_create(dir_path: *const aws_string) -> ::core::ffi::c_int;
    #[doc = " Returns true if the directory currently exists. Otherwise, it returns false."]
    pub fn aws_directory_exists(dir_path: *const aws_string) -> bool;
    #[doc = " Deletes a directory. If the directory is not empty, this will fail unless the recursive parameter is set to true.\n If recursive is true then the entire directory and all of its contents will be deleted. If it is set to false,\n the directory will be deleted only if it is empty. Returns AWS_OP_SUCCESS if the operation was successful. Otherwise,\n aws_last_error() will contain the error that occurred. If the directory doesn't exist, AWS_OP_SUCCESS is still\n returned."]
    pub fn aws_directory_delete(dir_path: *const aws_string, recursive: bool)
        -> ::core::ffi::c_int;
    #[doc = " Deletes a file. Returns AWS_OP_SUCCESS if the operation was successful. Otherwise,\n aws_last_error() will contain the error that occurred. If the file doesn't exist, AWS_OP_SUCCESS is still returned."]
    pub fn aws_file_delete(file_path: *const aws_string) -> ::core::ffi::c_int;
    #[doc = " Moves directory at from to to.\n Returns AWS_OP_SUCCESS if the operation was successful. Otherwise,\n aws_last_error() will contain the error that occurred."]
    pub fn aws_directory_or_file_move(
        from: *const aws_string,
        to: *const aws_string,
    ) -> ::core::ffi::c_int;
    #[doc = " Traverse a directory starting at path.\n\n If you want the traversal to recurse the entire directory, pass recursive as true. Passing false for this parameter\n will only iterate the contents of the directory, but will not descend into any directories it encounters.\n\n If recursive is set to true, the traversal is performed post-order, depth-first\n (for practical reasons such as deleting a directory that contains subdirectories or files).\n\n returns AWS_OP_SUCCESS(0) on success."]
    pub fn aws_directory_traverse(
        allocator: *mut aws_allocator,
        path: *const aws_string,
        recursive: bool,
        on_entry: aws_on_directory_entry,
        user_data: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    #[doc = " Creates a read-only iterator of a directory starting at path. If path is invalid or there's any other error\n condition, NULL will be returned. Call aws_last_error() for the exact error in that case."]
    pub fn aws_directory_entry_iterator_new(
        allocator: *mut aws_allocator,
        path: *const aws_string,
    ) -> *mut aws_directory_iterator;
    #[doc = " Moves the iterator to the next entry. Returns AWS_OP_SUCCESS if another entry is available, or AWS_OP_ERR with\n AWS_ERROR_LIST_EMPTY as the value for aws_last_error() if no more entries are available."]
    pub fn aws_directory_entry_iterator_next(
        iterator: *mut aws_directory_iterator,
    ) -> ::core::ffi::c_int;
    #[doc = " Moves the iterator to the previous entry. Returns AWS_OP_SUCCESS if another entry is available, or AWS_OP_ERR with\n AWS_ERROR_LIST_EMPTY as the value for aws_last_error() if no more entries are available."]
    pub fn aws_directory_entry_iterator_previous(
        iterator: *mut aws_directory_iterator,
    ) -> ::core::ffi::c_int;
    #[doc = " Cleanup and deallocate iterator"]
    pub fn aws_directory_entry_iterator_destroy(iterator: *mut aws_directory_iterator);
    #[doc = " Gets the aws_directory_entry value for iterator at the current position. Returns NULL if the iterator contains no\n entries."]
    pub fn aws_directory_entry_iterator_get_value(
        iterator: *const aws_directory_iterator,
    ) -> *const aws_directory_entry;
    #[doc = " Returns true iff the character is a directory separator on ANY supported platform."]
    pub fn aws_is_any_directory_separator(value: ::core::ffi::c_char) -> bool;
    #[doc = " Returns the directory separator used by the local platform"]
    pub fn aws_get_platform_directory_separator() -> ::core::ffi::c_char;
    #[doc = " Normalizes the path by replacing any directory separator with the local platform's directory separator.\n @param path path to normalize. Must be writeable."]
    pub fn aws_normalize_directory_separator(path: *mut aws_byte_buf);
    #[doc = " Returns the current user's home directory."]
    pub fn aws_get_home_directory(allocator: *mut aws_allocator) -> *mut aws_string;
    #[doc = " Returns true if a file or path exists, otherwise, false."]
    pub fn aws_path_exists(path: *const aws_string) -> bool;
    pub fn aws_fseek(
        file: *mut FILE,
        offset: i64,
        whence: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn aws_file_get_length(file: *mut FILE, length: *mut i64) -> ::core::ffi::c_int;
    #[doc = " Creates a new string aws_json_value with the given string and returns a pointer to it.\n\n Note: You will need to free the memory for the aws_json_value using aws_json_destroy on the aws_json_value or\n on the object/array containing the aws_json_value.\n @param string A byte pointer to the string you want to store in the aws_json_value\n @param allocator The allocator to use when creating the value\n @return A new string aws_json_value"]
    pub fn aws_json_value_new_string(
        allocator: *mut aws_allocator,
        string: aws_byte_cursor,
    ) -> *mut aws_json_value;
    #[doc = " Creates a new number aws_json_value with the given number and returns a pointer to it.\n\n Note: You will need to free the memory for the aws_json_value using aws_json_destroy on the aws_json_value or\n on the object/array containing the aws_json_value.\n @param number The number you want to store in the aws_json_value\n @param allocator The allocator to use when creating the value\n @return A new number aws_json_value"]
    pub fn aws_json_value_new_number(
        allocator: *mut aws_allocator,
        number: f64,
    ) -> *mut aws_json_value;
    #[doc = " Creates a new array aws_json_value and returns a pointer to it.\n\n Note: You will need to free the memory for the aws_json_value using aws_json_destroy on the aws_json_value or\n on the object/array containing the aws_json_value.\n Deleting this array will also destroy any aws_json_values it contains.\n @param allocator The allocator to use when creating the value\n @return A new array aws_json_value"]
    pub fn aws_json_value_new_array(allocator: *mut aws_allocator) -> *mut aws_json_value;
    #[doc = " Creates a new boolean aws_json_value with the given boolean and returns a pointer to it.\n\n Note: You will need to free the memory for the aws_json_value using aws_json_destroy on the aws_json_value or\n on the object/array containing the aws_json_value.\n @param boolean The boolean you want to store in the aws_json_value\n @param allocator The allocator to use when creating the value\n @return A new boolean aws_json_value"]
    pub fn aws_json_value_new_boolean(
        allocator: *mut aws_allocator,
        boolean: bool,
    ) -> *mut aws_json_value;
    #[doc = " Creates a new null aws_json_value and returns a pointer to it.\n\n Note: You will need to free the memory for the aws_json_value using aws_json_destroy on the aws_json_value or\n on the object/array containing the aws_json_value.\n @param allocator The allocator to use when creating the value\n @return A new null aws_json_value"]
    pub fn aws_json_value_new_null(allocator: *mut aws_allocator) -> *mut aws_json_value;
    #[doc = " Creates a new object aws_json_value and returns a pointer to it.\n\n Note: You will need to free the memory for the aws_json_value using aws_json_destroy on the aws_json_value or\n on the object/array containing the aws_json_value.\n Deleting this object will also destroy any aws_json_values it contains.\n @param allocator The allocator to use when creating the value\n @return A new object aws_json_value"]
    pub fn aws_json_value_new_object(allocator: *mut aws_allocator) -> *mut aws_json_value;
    #[doc = " Gets the string of a string aws_json_value.\n @param value The string aws_json_value.\n @param output The string\n @return AWS_OP_SUCCESS if the value is a string, otherwise AWS_OP_ERR."]
    pub fn aws_json_value_get_string(
        value: *const aws_json_value,
        output: *mut aws_byte_cursor,
    ) -> ::core::ffi::c_int;
    #[doc = " Gets the number of a number aws_json_value.\n @param value The number aws_json_value.\n @param output The number\n @return AWS_OP_SUCCESS if the value is a number, otherwise AWS_OP_ERR."]
    pub fn aws_json_value_get_number(
        value: *const aws_json_value,
        output: *mut f64,
    ) -> ::core::ffi::c_int;
    #[doc = " Gets the boolean of a boolean aws_json_value.\n @param value The boolean aws_json_value.\n @param output The boolean\n @return AWS_OP_SUCCESS if the value is a boolean, otherwise AWS_OP_ERR."]
    pub fn aws_json_value_get_boolean(
        value: *const aws_json_value,
        output: *mut bool,
    ) -> ::core::ffi::c_int;
    #[doc = " Adds a aws_json_value to a object aws_json_value.\n\n Note that the aws_json_value will be destroyed when the aws_json_value object is destroyed\n by calling \"aws_json_destroy()\"\n @param object The object aws_json_value you want to add a value to.\n @param key The key to add the aws_json_value at.\n @param value The aws_json_value you want to add.\n @return AWS_OP_SUCCESS if adding was successful.\n          Will return AWS_OP_ERROR if the object passed is invalid or if the passed key\n          is already in use in the object."]
    pub fn aws_json_value_add_to_object(
        object: *mut aws_json_value,
        key: aws_byte_cursor,
        value: *mut aws_json_value,
    ) -> ::core::ffi::c_int;
    #[doc = " Returns the aws_json_value at the given key.\n @param object The object aws_json_value you want to get the value from.\n @param key The key that the aws_json_value is at. Is case sensitive.\n @return The aws_json_value at the given key, otherwise NULL."]
    pub fn aws_json_value_get_from_object(
        object: *const aws_json_value,
        key: aws_byte_cursor,
    ) -> *mut aws_json_value;
    #[doc = " Checks if there is a aws_json_value at the given key.\n @param object The value aws_json_value you want to check a key in.\n @param key The key that you want to check. Is case sensitive.\n @return True if a aws_json_value is found."]
    pub fn aws_json_value_has_key(object: *const aws_json_value, key: aws_byte_cursor) -> bool;
    #[doc = " Removes the aws_json_value at the given key.\n @param object The object aws_json_value you want to remove a aws_json_value in.\n @param key The key that the aws_json_value is at. Is case sensitive.\n @return AWS_OP_SUCCESS if the aws_json_value was removed.\n          Will return AWS_OP_ERR if the object passed is invalid or if the value\n          at the key cannot be found."]
    pub fn aws_json_value_remove_from_object(
        object: *mut aws_json_value,
        key: aws_byte_cursor,
    ) -> ::core::ffi::c_int;
    #[doc = " @brief iterates through members of the object.\n iteration is sequential in order fields were initially parsed.\n @param object object to iterate over.\n @param on_member callback for when member is encountered.\n @param user_data user data to pass back in callback.\n @return AWS_OP_SUCCESS when iteration finishes completely or exits early,\n AWS_OP_ERR if value is not an object."]
    pub fn aws_json_const_iterate_object(
        object: *const aws_json_value,
        on_member: aws_json_on_member_encountered_const_fn,
        user_data: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    #[doc = " Adds a aws_json_value to the given array aws_json_value.\n\n Note that the aws_json_value will be destroyed when the aws_json_value array is destroyed\n by calling \"aws_json_destroy()\"\n @param array The array aws_json_value you want to add an aws_json_value to.\n @param value The aws_json_value you want to add.\n @return AWS_OP_SUCCESS if adding the aws_json_value was successful.\n          Will return AWS_OP_ERR if the array passed is invalid."]
    pub fn aws_json_value_add_array_element(
        array: *mut aws_json_value,
        value: *const aws_json_value,
    ) -> ::core::ffi::c_int;
    #[doc = " Returns the aws_json_value at the given index in the array aws_json_value.\n @param array The array aws_json_value.\n @param index The index of the aws_json_value you want to access.\n @return A pointer to the aws_json_value at the given index in the array, otherwise NULL."]
    pub fn aws_json_get_array_element(
        array: *const aws_json_value,
        index: usize,
    ) -> *mut aws_json_value;
    #[doc = " Returns the number of items in the array aws_json_value.\n @param array The array aws_json_value.\n @return The number of items in the array_json_value."]
    pub fn aws_json_get_array_size(array: *const aws_json_value) -> usize;
    #[doc = " Removes the aws_json_value at the given index in the array aws_json_value.\n @param array The array aws_json_value.\n @param index The index containing the aws_json_value you want to remove.\n @return AWS_OP_SUCCESS if the aws_json_value at the index was removed.\n          Will return AWS_OP_ERR if the array passed is invalid or if the index\n          passed is out of range."]
    pub fn aws_json_value_remove_array_element(
        array: *mut aws_json_value,
        index: usize,
    ) -> ::core::ffi::c_int;
    #[doc = " @brief iterates through values of an array.\n iteration is sequential starting with 0th element.\n @param array array to iterate over.\n @param on_value callback for when value is encountered.\n @param user_data user data to pass back in callback.\n @return AWS_OP_SUCCESS when iteration finishes completely or exits early,\n AWS_OP_ERR if value is not an array."]
    pub fn aws_json_const_iterate_array(
        array: *const aws_json_value,
        on_value: aws_json_on_value_encountered_const_fn,
        user_data: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    #[doc = " Checks whether two json values are equivalent.\n @param a first value to compare.\n @param b second value to compare.\n @param is_case_sensitive case sensitive compare or not.\n @return True is values are equal, false otherwise"]
    pub fn aws_json_value_compare(
        a: *const aws_json_value,
        b: *const aws_json_value,
        is_case_sensitive: bool,
    ) -> bool;
    #[doc = " Duplicates json value.\n @param value first value to compare.\n @return duplicated value. NULL and last error set if value cannot be duplicated."]
    pub fn aws_json_value_duplicate(value: *const aws_json_value) -> *mut aws_json_value;
    #[doc = " Checks if the aws_json_value is a string.\n @param value The aws_json_value to check.\n @return True if the aws_json_value is a string aws_json_value, otherwise false."]
    pub fn aws_json_value_is_string(value: *const aws_json_value) -> bool;
    #[doc = " Checks if the aws_json_value is a number.\n @param value The aws_json_value to check.\n @return True if the aws_json_value is a number aws_json_value, otherwise false."]
    pub fn aws_json_value_is_number(value: *const aws_json_value) -> bool;
    #[doc = " Checks if the aws_json_value is a array.\n @param value The aws_json_value to check.\n @return True if the aws_json_value is a array aws_json_value, otherwise false."]
    pub fn aws_json_value_is_array(value: *const aws_json_value) -> bool;
    #[doc = " Checks if the aws_json_value is a boolean.\n @param value The aws_json_value to check.\n @return True if the aws_json_value is a boolean aws_json_value, otherwise false."]
    pub fn aws_json_value_is_boolean(value: *const aws_json_value) -> bool;
    #[doc = " Checks if the aws_json_value is a null aws_json_value.\n @param value The aws_json_value to check.\n @return True if the aws_json_value is a null aws_json_value, otherwise false."]
    pub fn aws_json_value_is_null(value: *const aws_json_value) -> bool;
    #[doc = " Checks if the aws_json_value is a object aws_json_value.\n @param value The aws_json_value to check.\n @return True if the aws_json_value is a object aws_json_value, otherwise false."]
    pub fn aws_json_value_is_object(value: *const aws_json_value) -> bool;
    #[doc = " Removes the aws_json_value from memory. If the aws_json_value is a object or array, it will also destroy\n attached aws_json_values as well.\n\n For example, if you called \"aws_json_array_add(b, a)\" to add an object \"a\" to an array \"b\", if you call\n \"aws_json_destroy(b)\" then it will also free \"a\" automatically. All children/attached aws_json_values are freed\n when the parent/root aws_json_value is destroyed.\n @param value The aws_json_value to destroy."]
    pub fn aws_json_value_destroy(value: *mut aws_json_value);
    #[doc = " Appends a unformatted JSON string representation of the aws_json_value into the passed byte buffer.\n The byte buffer is expected to be already initialized so the function can append the JSON into it.\n\n Note: The byte buffer will automatically have its size extended if the JSON string is over the byte\n buffer capacity AND the byte buffer has an allocator associated with it. If the byte buffer does not\n have an allocator associated and the JSON string is over capacity, AWS_OP_ERR will be returned.\n\n Note: When you are finished with the aws_byte_buf, you must call \"aws_byte_buf_clean_up_secure\" to free\n the memory used, as it will NOT be called automatically.\n @param value The aws_json_value to format.\n @param output The destination for the JSON string\n @return AWS_OP_SUCCESS if the JSON string was allocated to output without any errors\n      Will return AWS_OP_ERR if the value passed is not an aws_json_value or if there\n      was an error appending the JSON into the byte buffer."]
    pub fn aws_byte_buf_append_json_string(
        value: *const aws_json_value,
        output: *mut aws_byte_buf,
    ) -> ::core::ffi::c_int;
    #[doc = " Appends a formatted JSON string representation of the aws_json_value into the passed byte buffer.\n The byte buffer is expected to already be initialized so the function can append the JSON into it.\n\n Note: The byte buffer will automatically have its size extended if the JSON string is over the byte\n buffer capacity AND the byte buffer has an allocator associated with it. If the byte buffer does not\n have an allocator associated and the JSON string is over capacity, AWS_OP_ERR will be returned.\n\n Note: When you are finished with the aws_byte_buf, you must call \"aws_byte_buf_clean_up_secure\" to free\n the memory used, as it will NOT be called automatically.\n @param value The aws_json_value to format.\n @param output The destination for the JSON string\n @return AWS_OP_SUCCESS if the JSON string was allocated to output without any errors\n      Will return AWS_ERROR_INVALID_ARGUMENT if the value passed is not an aws_json_value or if there\n      aws an error appending the JSON into the byte buffer."]
    pub fn aws_byte_buf_append_json_string_formatted(
        value: *const aws_json_value,
        output: *mut aws_byte_buf,
    ) -> ::core::ffi::c_int;
    #[doc = " Parses the JSON string and returns a aws_json_value containing the root of the JSON.\n @param allocator The allocator used to create the value\n @param string The string containing the JSON.\n @return The root aws_json_value of the JSON."]
    pub fn aws_json_value_new_from_string(
        allocator: *mut aws_allocator,
        string: aws_byte_cursor,
    ) -> *mut aws_json_value;
    #[doc = " Initializes the last-in-first-out cache. Sets up the underlying linked hash table.\n Once `max_items` elements have been added, the latest(last-in) item will\n be removed. For the other parameters, see aws/common/hash_table.h. Hash table\n semantics of these arguments are preserved."]
    pub fn aws_cache_new_lifo(
        allocator: *mut aws_allocator,
        hash_fn: aws_hash_fn,
        equals_fn: aws_hash_callback_eq_fn,
        destroy_key_fn: aws_hash_callback_destroy_fn,
        destroy_value_fn: aws_hash_callback_destroy_fn,
        max_items: usize,
    ) -> *mut aws_cache;
    #[doc = " Returns true if bytes of string are the same, false otherwise."]
    pub fn aws_string_eq(a: *const aws_string, b: *const aws_string) -> bool;
    #[doc = " Returns true if bytes of string are equivalent, using a case-insensitive comparison."]
    pub fn aws_string_eq_ignore_case(a: *const aws_string, b: *const aws_string) -> bool;
    #[doc = " Returns true if bytes of string and cursor are the same, false otherwise."]
    pub fn aws_string_eq_byte_cursor(str_: *const aws_string, cur: *const aws_byte_cursor) -> bool;
    #[doc = " Returns true if bytes of string and cursor are equivalent, using a case-insensitive comparison."]
    pub fn aws_string_eq_byte_cursor_ignore_case(
        str_: *const aws_string,
        cur: *const aws_byte_cursor,
    ) -> bool;
    #[doc = " Returns true if bytes of string and buffer are the same, false otherwise."]
    pub fn aws_string_eq_byte_buf(str_: *const aws_string, buf: *const aws_byte_buf) -> bool;
    #[doc = " Returns true if bytes of string and buffer are equivalent, using a case-insensitive comparison."]
    pub fn aws_string_eq_byte_buf_ignore_case(
        str_: *const aws_string,
        buf: *const aws_byte_buf,
    ) -> bool;
    pub fn aws_string_eq_c_str(str_: *const aws_string, c_str: *const ::core::ffi::c_char) -> bool;
    #[doc = " Returns true if bytes of strings are equivalent, using a case-insensitive comparison."]
    pub fn aws_string_eq_c_str_ignore_case(
        str_: *const aws_string,
        c_str: *const ::core::ffi::c_char,
    ) -> bool;
    #[doc = " Constructor functions which copy data from null-terminated C-string or array of bytes."]
    pub fn aws_string_new_from_c_str(
        allocator: *mut aws_allocator,
        c_str: *const ::core::ffi::c_char,
    ) -> *mut aws_string;
    #[doc = " Allocate a new string with the same contents as array."]
    pub fn aws_string_new_from_array(
        allocator: *mut aws_allocator,
        bytes: *const u8,
        len: usize,
    ) -> *mut aws_string;
    #[doc = " Allocate a new string with the same contents as another string."]
    pub fn aws_string_new_from_string(
        allocator: *mut aws_allocator,
        str_: *const aws_string,
    ) -> *mut aws_string;
    #[doc = " Allocate a new string with the same contents as cursor."]
    pub fn aws_string_new_from_cursor(
        allocator: *mut aws_allocator,
        cursor: *const aws_byte_cursor,
    ) -> *mut aws_string;
    #[doc = " Allocate a new string with the same contents as buf."]
    pub fn aws_string_new_from_buf(
        allocator: *mut aws_allocator,
        buf: *const aws_byte_buf,
    ) -> *mut aws_string;
    #[doc = " Deallocate string."]
    pub fn aws_string_destroy(str_: *mut aws_string);
    #[doc = " Zeroes out the data bytes of string and then deallocates the memory.\n Not safe to run on a string created with AWS_STATIC_STRING_FROM_LITERAL."]
    pub fn aws_string_destroy_secure(str_: *mut aws_string);
    #[doc = " Compares lexicographical ordering of two strings. This is a binary\n byte-by-byte comparison, treating bytes as unsigned integers. It is suitable\n for either textual or binary data and is unaware of unicode or any other byte\n encoding. If both strings are identical in the bytes of the shorter string,\n then the longer string is lexicographically after the shorter.\n\n Returns a positive number if string a > string b. (i.e., string a is\n lexicographically after string b.) Returns zero if string a = string b.\n Returns negative number if string a < string b."]
    pub fn aws_string_compare(a: *const aws_string, b: *const aws_string) -> ::core::ffi::c_int;
    #[doc = " A convenience function for sorting lists of (const struct aws_string *) elements. This can be used as a\n comparator for aws_array_list_sort. It is just a simple wrapper around aws_string_compare."]
    pub fn aws_array_list_comparator_string(
        a: *const ::core::ffi::c_void,
        b: *const ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    #[doc = " Copies all bytes from string to buf.\n\n On success, returns true and updates the buf pointer/length\n accordingly. If there is insufficient space in the buf, returns\n false, leaving the buf unchanged."]
    pub fn aws_byte_buf_write_from_whole_string(
        buf: *mut aws_byte_buf,
        src: *const aws_string,
    ) -> bool;
    #[doc = " Creates an aws_byte_cursor from an existing string."]
    pub fn aws_byte_cursor_from_string(src: *const aws_string) -> aws_byte_cursor;
    #[doc = " If the string was dynamically allocated, clones it. If the string was statically allocated (i.e. has no allocator),\n returns the original string."]
    pub fn aws_string_clone_or_reuse(
        allocator: *mut aws_allocator,
        str_: *const aws_string,
    ) -> *mut aws_string;
    #[doc = " Computes the length of a c string in bytes assuming the character set is either ASCII or UTF-8. If no NULL character\n is found within max_read_len of str, AWS_ERROR_C_STRING_BUFFER_NOT_NULL_TERMINATED is raised. Otherwise, str_len\n will contain the string length minus the NULL character, and AWS_OP_SUCCESS will be returned."]
    pub fn aws_secure_strlen(
        str_: *const ::core::ffi::c_char,
        max_read_len: usize,
        str_len: *mut usize,
    ) -> ::core::ffi::c_int;
    #[doc = " Returns an instance of system default thread options."]
    pub fn aws_default_thread_options() -> *const aws_thread_options;
    pub fn aws_thread_call_once(
        flag: *mut aws_thread_once,
        call_once: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>,
        user_data: *mut ::core::ffi::c_void,
    );
    #[doc = " Initializes a new platform specific thread object struct (not the os-level\n thread itself)."]
    pub fn aws_thread_init(
        thread: *mut aws_thread,
        allocator: *mut aws_allocator,
    ) -> ::core::ffi::c_int;
    #[doc = " Creates an OS level thread and associates it with func. context will be passed to func when it is executed.\n options will be applied to the thread if they are applicable for the platform.\n\n After launch, you may join on the thread.  A successfully launched thread must have clean_up called on it in order\n to avoid a handle leak.  If you do not join before calling clean_up, the thread will become detached.\n\n Managed threads must not have join or clean_up called on them by external code."]
    pub fn aws_thread_launch(
        thread: *mut aws_thread,
        func: ::core::option::Option<unsafe extern "C" fn(arg: *mut ::core::ffi::c_void)>,
        arg: *mut ::core::ffi::c_void,
        options: *const aws_thread_options,
    ) -> ::core::ffi::c_int;
    #[doc = " Gets the id of thread"]
    pub fn aws_thread_get_id(thread: *mut aws_thread) -> aws_thread_id_t;
    #[doc = " Gets the detach state of the thread. For example, is it safe to call join on\n this thread? Has it been detached()?"]
    pub fn aws_thread_get_detach_state(thread: *mut aws_thread) -> aws_thread_detach_state;
    #[doc = " Joins the calling thread to a thread instance. Returns when thread is\n finished.  Calling this from the associated OS thread will cause a deadlock."]
    pub fn aws_thread_join(thread: *mut aws_thread) -> ::core::ffi::c_int;
    #[doc = " Blocking call that waits for all managed threads to complete their join call.  This can only be called\n from the main thread or a non-managed thread.\n\n This gets called automatically from library cleanup.\n\n By default the wait is unbounded, but that default can be overridden via aws_thread_set_managed_join_timeout_ns()"]
    pub fn aws_thread_join_all_managed() -> ::core::ffi::c_int;
    #[doc = " Overrides how long, in nanoseconds, that aws_thread_join_all_managed will wait for threads to complete.\n A value of zero will result in an unbounded wait."]
    pub fn aws_thread_set_managed_join_timeout_ns(timeout_in_ns: u64);
    #[doc = " Cleans up the thread handle. Don't call this on a managed thread.  If you wish to join the thread, you must join\n before calling this function."]
    pub fn aws_thread_clean_up(thread: *mut aws_thread);
    #[doc = " Returns the thread id of the calling thread."]
    pub fn aws_thread_current_thread_id() -> aws_thread_id_t;
    #[doc = " Compare thread ids."]
    pub fn aws_thread_thread_id_equal(t1: aws_thread_id_t, t2: aws_thread_id_t) -> bool;
    #[doc = " Sleeps the current thread by nanos."]
    pub fn aws_thread_current_sleep(nanos: u64);
    #[doc = " Adds a callback to the chain to be called when the current thread joins.\n Callbacks are called from the current thread, in the reverse order they\n were added, after the thread function returns.\n If not called from within an aws_thread, has no effect."]
    pub fn aws_thread_current_at_exit(
        callback: aws_thread_atexit_fn,
        user_data: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    #[doc = " Increments the count of unjoined threads in the managed thread system.  Used by managed threads and\n event loop threads.  Additional usage requires the user to join corresponding threads themselves and\n correctly increment/decrement even in the face of launch/join errors.\n\n aws_thread_join_all_managed() will not return until this count has gone to zero."]
    pub fn aws_thread_increment_unjoined_count();
    #[doc = " Decrements the count of unjoined threads in the managed thread system.  Used by managed threads and\n event loop threads.  Additional usage requires the user to join corresponding threads themselves and\n correctly increment/decrement even in the face of launch/join errors.\n\n aws_thread_join_all_managed() will not return until this count has gone to zero."]
    pub fn aws_thread_decrement_unjoined_count();
    #[doc = " Gets name of the current thread.\n Caller is responsible for destroying returned string.\n If thread does not have a name, AWS_OP_SUCCESS is returned and out_name is\n set to NULL.\n If underlying OS call fails,  AWS_ERROR_SYS_CALL_FAILURE will be raised\n If OS does not support getting thread name, AWS_ERROR_PLATFORM_NOT_SUPPORTED\n will be raised"]
    pub fn aws_thread_current_name(
        allocator: *mut aws_allocator,
        out_name: *mut *mut aws_string,
    ) -> ::core::ffi::c_int;
    #[doc = " Gets name of the thread.\n Caller is responsible for destroying returned string.\n If thread does not have a name, AWS_OP_SUCCESS is returned and out_name is\n set to NULL.\n If underlying OS call fails,  AWS_ERROR_SYS_CALL_FAILURE will be raised\n If OS does not support getting thread name, AWS_ERROR_PLATFORM_NOT_SUPPORTED\n will be raised"]
    pub fn aws_thread_name(
        allocator: *mut aws_allocator,
        thread_id: aws_thread_id_t,
        out_name: *mut *mut aws_string,
    ) -> ::core::ffi::c_int;
    #[doc = " Sets the aws logger used globally across the process.  Not thread-safe.  Must only be called once."]
    pub fn aws_logger_set(logger: *mut aws_logger);
    #[doc = " Gets the aws logger used globally across the process."]
    pub fn aws_logger_get() -> *mut aws_logger;
    #[doc = " Gets the aws logger used globally across the process if the logging level is at least the inputted level.\n\n @param subject log subject to perform the level check versus, not currently used\n @param level logging level to check against in order to return the logger\n @return the current logger if the current logging level is at or more detailed then the supplied logging level"]
    pub fn aws_logger_get_conditional(
        subject: aws_log_subject_t,
        level: aws_log_level,
    ) -> *mut aws_logger;
    #[doc = " Cleans up all resources used by the logger; simply invokes the clean_up v-function"]
    pub fn aws_logger_clean_up(logger: *mut aws_logger);
    #[doc = " Sets the current logging level for the logger.  Loggers are not require to support this.\n @param logger logger to set the log level for\n @param level new log level for the logger\n @return AWS_OP_SUCCESS if the level was successfully set, AWS_OP_ERR otherwise"]
    pub fn aws_logger_set_log_level(
        logger: *mut aws_logger,
        level: aws_log_level,
    ) -> ::core::ffi::c_int;
    #[doc = " Converts a log level to a c-string constant.  Intended primarily to support building log lines that\n include the level in them, i.e.\n\n [ERROR] 10:34:54.642 01-31-19 - Json parse error...."]
    pub fn aws_log_level_to_string(
        log_level: aws_log_level,
        level_string: *mut *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    #[doc = " Converts a c-string constant to a log level value.  Uses case-insensitive comparison\n and simply iterates all possibilities until a match or nothing remains.  If no match\n is found, AWS_OP_ERR is returned."]
    pub fn aws_string_to_log_level(
        level_string: *const ::core::ffi::c_char,
        log_level: *mut aws_log_level,
    ) -> ::core::ffi::c_int;
    #[doc = " Converts an aws_thread_id_t to a c-string.  For portability, aws_thread_id_t\n must not be printed directly.  Intended primarily to support building log\n lines that include the thread id in them.  The parameter `buffer` must\n point-to a char buffer of length `bufsz == AWS_THREAD_ID_T_REPR_BUFSZ`.  The\n thread id representation is returned in `buffer`."]
    pub fn aws_thread_id_t_to_string(
        thread_id: aws_thread_id_t,
        buffer: *mut ::core::ffi::c_char,
        bufsz: usize,
    ) -> ::core::ffi::c_int;
    #[doc = " Get subject name from log subject."]
    pub fn aws_log_subject_name(subject: aws_log_subject_t) -> *const ::core::ffi::c_char;
    #[doc = " Connects log subject strings with log subject integer values"]
    pub fn aws_register_log_subject_info_list(log_subject_list: *mut aws_log_subject_info_list);
    #[doc = " Disconnects log subject strings with log subject integer values"]
    pub fn aws_unregister_log_subject_info_list(log_subject_list: *mut aws_log_subject_info_list);
    pub fn aws_logger_init_standard(
        logger: *mut aws_logger,
        allocator: *mut aws_allocator,
        options: *mut aws_logger_standard_options,
    ) -> ::core::ffi::c_int;
    pub fn aws_logger_init_from_external(
        logger: *mut aws_logger,
        allocator: *mut aws_allocator,
        formatter: *mut aws_log_formatter,
        channel: *mut aws_log_channel,
        writer: *mut aws_log_writer,
        level: aws_log_level,
    ) -> ::core::ffi::c_int;
    pub fn aws_logger_init_noalloc(
        logger: *mut aws_logger,
        allocator: *mut aws_allocator,
        options: *mut aws_logger_standard_options,
    ) -> ::core::ffi::c_int;
    pub fn aws_log_channel_init_foreground(
        channel: *mut aws_log_channel,
        allocator: *mut aws_allocator,
        writer: *mut aws_log_writer,
    ) -> ::core::ffi::c_int;
    pub fn aws_log_channel_init_background(
        channel: *mut aws_log_channel,
        allocator: *mut aws_allocator,
        writer: *mut aws_log_writer,
    ) -> ::core::ffi::c_int;
    pub fn aws_log_channel_clean_up(channel: *mut aws_log_channel);
    pub fn aws_log_formatter_init_default(
        formatter: *mut aws_log_formatter,
        allocator: *mut aws_allocator,
        options: *mut aws_log_formatter_standard_options,
    ) -> ::core::ffi::c_int;
    pub fn aws_log_formatter_clean_up(formatter: *mut aws_log_formatter);
    pub fn aws_log_writer_init_stdout(
        writer: *mut aws_log_writer,
        allocator: *mut aws_allocator,
    ) -> ::core::ffi::c_int;
    pub fn aws_log_writer_init_stderr(
        writer: *mut aws_log_writer,
        allocator: *mut aws_allocator,
    ) -> ::core::ffi::c_int;
    pub fn aws_log_writer_init_file(
        writer: *mut aws_log_writer,
        allocator: *mut aws_allocator,
        options: *mut aws_log_writer_file_options,
    ) -> ::core::ffi::c_int;
    pub fn aws_log_writer_clean_up(writer: *mut aws_log_writer);
    #[doc = " Initializes the Least-recently-used cache. Sets up the underlying linked hash table.\n Once `max_items` elements have been added, the least recently used item will be removed. For the other parameters,\n see aws/common/hash_table.h. Hash table semantics of these arguments are preserved.(Yes the one that was the answer\n to that interview question that one time)."]
    pub fn aws_cache_new_lru(
        allocator: *mut aws_allocator,
        hash_fn: aws_hash_fn,
        equals_fn: aws_hash_callback_eq_fn,
        destroy_key_fn: aws_hash_callback_destroy_fn,
        destroy_value_fn: aws_hash_callback_destroy_fn,
        max_items: usize,
    ) -> *mut aws_cache;
    #[doc = " Accesses the least-recently-used element, sets it to most-recently-used\n element, and returns the value."]
    pub fn aws_lru_cache_use_lru_element(cache: *mut aws_cache) -> *mut ::core::ffi::c_void;
    #[doc = " Accesses the most-recently-used element and returns its value."]
    pub fn aws_lru_cache_get_mru_element(cache: *const aws_cache) -> *mut ::core::ffi::c_void;
    #[doc = " Initializes a new platform instance of mutex."]
    pub fn aws_mutex_init(mutex: *mut aws_mutex) -> ::core::ffi::c_int;
    #[doc = " Cleans up internal resources."]
    pub fn aws_mutex_clean_up(mutex: *mut aws_mutex);
    #[doc = " Blocks until it acquires the lock. While on some platforms such as Windows,\n this may behave as a reentrant mutex, you should not treat it like one. On\n platforms it is possible for it to be non-reentrant, it will be."]
    pub fn aws_mutex_lock(mutex: *mut aws_mutex) -> ::core::ffi::c_int;
    #[doc = " Attempts to acquire the lock but returns immediately if it can not.\n While on some platforms such as Windows, this may behave as a reentrant mutex,\n you should not treat it like one. On platforms it is possible for it to be non-reentrant, it will be.\n Note: For windows, minimum support server version is Windows Server 2008 R2 [desktop apps | UWP apps]"]
    pub fn aws_mutex_try_lock(mutex: *mut aws_mutex) -> ::core::ffi::c_int;
    #[doc = " Releases the lock."]
    pub fn aws_mutex_unlock(mutex: *mut aws_mutex) -> ::core::ffi::c_int;
    #[doc = " Initializes a priority queue struct for use. This mode will grow memory automatically (exponential model)\n Default size is the inital size of the queue\n item_size is the size of each element in bytes. Mixing items types is not supported by this API.\n pred is the function that will be used to determine priority."]
    pub fn aws_priority_queue_init_dynamic(
        queue: *mut aws_priority_queue,
        alloc: *mut aws_allocator,
        default_size: usize,
        item_size: usize,
        pred: aws_priority_queue_compare_fn,
    ) -> ::core::ffi::c_int;
    #[doc = " Initializes a priority queue struct for use. This mode will not allocate any additional memory. When the heap fills\n new enqueue operations will fail with AWS_ERROR_PRIORITY_QUEUE_FULL.\n\n Heaps initialized using this call do not support the aws_priority_queue_push_ref call with a non-NULL backpointer\n parameter.\n\n heap is the raw memory allocated for this priority_queue\n item_count is the maximum number of elements the raw heap can contain\n item_size is the size of each element in bytes. Mixing items types is not supported by this API.\n pred is the function that will be used to determine priority."]
    pub fn aws_priority_queue_init_static(
        queue: *mut aws_priority_queue,
        heap: *mut ::core::ffi::c_void,
        item_count: usize,
        item_size: usize,
        pred: aws_priority_queue_compare_fn,
    );
    #[doc = " Checks that the backpointer at a specific index of the queue is\n NULL or points to a correctly allocated aws_priority_queue_node."]
    pub fn aws_priority_queue_backpointer_index_valid(
        queue: *const aws_priority_queue,
        index: usize,
    ) -> bool;
    #[doc = " Checks that the backpointers of the priority queue are either NULL\n or correctly allocated to point at aws_priority_queue_nodes. This\n check is O(n), as it accesses every backpointer in a loop, and thus\n shouldn't be used carelessly."]
    pub fn aws_priority_queue_backpointers_valid_deep(queue: *const aws_priority_queue) -> bool;
    #[doc = " Checks that the backpointers of the priority queue satisfy validity\n constraints."]
    pub fn aws_priority_queue_backpointers_valid(queue: *const aws_priority_queue) -> bool;
    #[doc = " Set of properties of a valid aws_priority_queue."]
    pub fn aws_priority_queue_is_valid(queue: *const aws_priority_queue) -> bool;
    #[doc = " Cleans up any internally allocated memory and resets the struct for reuse or deletion."]
    pub fn aws_priority_queue_clean_up(queue: *mut aws_priority_queue);
    #[doc = " Copies item into the queue and places it in the proper priority order. Complexity: O(log(n))."]
    pub fn aws_priority_queue_push(
        queue: *mut aws_priority_queue,
        item: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    #[doc = " Copies item into the queue and places it in the proper priority order. Complexity: O(log(n)).\n\n If the backpointer parameter is non-null, the heap will continually update the pointed-to field\n with information needed to remove the node later on. *backpointer must remain valid until the node\n is removed from the heap, and may be updated on any mutating operation on the priority queue.\n\n If the node is removed, the backpointer will be set to a sentinel value that indicates that the\n node has already been removed. It is safe (and a no-op) to call aws_priority_queue_remove with\n such a sentinel value."]
    pub fn aws_priority_queue_push_ref(
        queue: *mut aws_priority_queue,
        item: *mut ::core::ffi::c_void,
        backpointer: *mut aws_priority_queue_node,
    ) -> ::core::ffi::c_int;
    #[doc = " Copies the element of the highest priority, and removes it from the queue.. Complexity: O(log(n)).\n If queue is empty, AWS_ERROR_PRIORITY_QUEUE_EMPTY will be raised."]
    pub fn aws_priority_queue_pop(
        queue: *mut aws_priority_queue,
        item: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    #[doc = " Removes a specific node from the priority queue. Complexity: O(log(n))\n After removing a node (using either _remove or _pop), the backpointer set at push_ref time is set\n to a sentinel value. If this sentinel value is passed to aws_priority_queue_remove,\n AWS_ERROR_PRIORITY_QUEUE_BAD_NODE will be raised. Note, however, that passing uninitialized\n aws_priority_queue_nodes, or ones from different priority queues, results in undefined behavior."]
    pub fn aws_priority_queue_remove(
        queue: *mut aws_priority_queue,
        item: *mut ::core::ffi::c_void,
        node: *const aws_priority_queue_node,
    ) -> ::core::ffi::c_int;
    #[doc = " Obtains a pointer to the element of the highest priority. Complexity: constant time.\n If queue is empty, AWS_ERROR_PRIORITY_QUEUE_EMPTY will be raised."]
    pub fn aws_priority_queue_top(
        queue: *const aws_priority_queue,
        item: *mut *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    #[doc = " Removes all elements from the queue, but does not free internal memory."]
    pub fn aws_priority_queue_clear(queue: *mut aws_priority_queue);
    #[doc = " Current number of elements in the queue"]
    pub fn aws_priority_queue_size(queue: *const aws_priority_queue) -> usize;
    #[doc = " Current allocated capacity for the queue, in dynamic mode this grows over time, in static mode, this will never\n change."]
    pub fn aws_priority_queue_capacity(queue: *const aws_priority_queue) -> usize;
    #[doc = " Initializes a queue node to a default value that indicates the node is not in the queue.\n\n @param node priority queue node to initialize with a default value"]
    pub fn aws_priority_queue_node_init(node: *mut aws_priority_queue_node);
    #[doc = " Checks if a priority queue node is currently in a priority queue.\n\n @param node priority queue node to check usage for\n\n @return true if the node is in a queue, false otherwise"]
    pub fn aws_priority_queue_node_is_in_queue(node: *const aws_priority_queue_node) -> bool;
    #[doc = " Returns the current process's PID (process id).\n @return PID as int"]
    pub fn aws_get_pid() -> ::core::ffi::c_int;
    #[doc = " Returns the soft limit for max io handles (max fds in unix terminology). This limit is one more than the actual\n limit. The soft limit can be changed up to the hard limit by any process regardless of permissions."]
    pub fn aws_get_soft_limit_io_handles() -> usize;
    #[doc = " Returns the hard limit for max io handles (max fds in unix terminology). This limit is one more than the actual\n limit. This limit cannot be increased without sudo permissions."]
    pub fn aws_get_hard_limit_io_handles() -> usize;
    #[doc = " Sets the new soft limit for io_handles (max fds). This can be up to the hard limit but may not exceed it.\n\n This operation will always fail with AWS_ERROR_UNIMPLEMENTED error code on Windows."]
    pub fn aws_set_soft_limit_io_handles(max_handles: usize) -> ::core::ffi::c_int;
    pub fn aws_run_command_result_init(
        allocator: *mut aws_allocator,
        result: *mut aws_run_command_result,
    ) -> ::core::ffi::c_int;
    pub fn aws_run_command_result_cleanup(result: *mut aws_run_command_result);
    #[doc = " Currently this API is implemented using popen on Posix system and\n _popen on Windows to capture output from running a command. Note\n that popen only captures stdout, and doesn't provide an option to\n capture stderr. We will add more options, such as acquire stderr\n in the future so probably will alter the underlying implementation\n as well."]
    pub fn aws_run_command(
        allocator: *mut aws_allocator,
        options: *mut aws_run_command_options,
        result: *mut aws_run_command_result,
    ) -> ::core::ffi::c_int;
    pub fn aws_promise_new(allocator: *mut aws_allocator) -> *mut aws_promise;
    pub fn aws_promise_acquire(promise: *mut aws_promise) -> *mut aws_promise;
    pub fn aws_promise_release(promise: *mut aws_promise);
    pub fn aws_promise_wait(promise: *mut aws_promise);
    pub fn aws_promise_wait_for(promise: *mut aws_promise, nanoseconds: usize) -> bool;
    pub fn aws_promise_complete(
        promise: *mut aws_promise,
        value: *mut ::core::ffi::c_void,
        dtor: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>,
    );
    pub fn aws_promise_fail(promise: *mut aws_promise, error_code: ::core::ffi::c_int);
    pub fn aws_promise_is_complete(promise: *mut aws_promise) -> bool;
    pub fn aws_promise_error_code(promise: *mut aws_promise) -> ::core::ffi::c_int;
    pub fn aws_promise_value(promise: *mut aws_promise) -> *mut ::core::ffi::c_void;
    pub fn aws_promise_take_value(promise: *mut aws_promise) -> *mut ::core::ffi::c_void;
    #[doc = " Initializes a ref-counter structure.  After initialization, the ref count will be 1.\n\n @param ref_count ref-counter to initialize\n @param object object being ref counted\n @param on_zero_fn function to invoke when the ref count reaches zero"]
    pub fn aws_ref_count_init(
        ref_count: *mut aws_ref_count,
        object: *mut ::core::ffi::c_void,
        on_zero_fn: aws_simple_completion_callback,
    );
    #[doc = " Increments a ref-counter's ref count\n\n @param ref_count ref-counter to increment the count for\n @return the object being ref-counted"]
    pub fn aws_ref_count_acquire(ref_count: *mut aws_ref_count) -> *mut ::core::ffi::c_void;
    #[doc = " Decrements a ref-counter's ref count.  Invokes the on_zero callback if the ref count drops to zero\n @param ref_count ref-counter to decrement the count for\n @return the value of the decremented ref count"]
    pub fn aws_ref_count_release(ref_count: *mut aws_ref_count) -> usize;
    #[doc = " Initializes a ring buffer with an allocation of size `size`. Returns AWS_OP_SUCCESS on a successful initialization,\n AWS_OP_ERR otherwise."]
    pub fn aws_ring_buffer_init(
        ring_buf: *mut aws_ring_buffer,
        allocator: *mut aws_allocator,
        size: usize,
    ) -> ::core::ffi::c_int;
    #[doc = " Cleans up the ring buffer's resources."]
    pub fn aws_ring_buffer_clean_up(ring_buf: *mut aws_ring_buffer);
    #[doc = " Attempts to acquire `requested_size` buffer and stores the result in `dest` if successful. Returns AWS_OP_SUCCESS if\n the requested size was available for use, AWS_OP_ERR otherwise."]
    pub fn aws_ring_buffer_acquire(
        ring_buf: *mut aws_ring_buffer,
        requested_size: usize,
        dest: *mut aws_byte_buf,
    ) -> ::core::ffi::c_int;
    #[doc = " Attempts to acquire `requested_size` buffer and stores the result in `dest` if successful. If not available, it will\n attempt to acquire anywhere from 1 byte to `requested_size`. Returns AWS_OP_SUCCESS if some buffer space is available\n for use, AWS_OP_ERR otherwise."]
    pub fn aws_ring_buffer_acquire_up_to(
        ring_buf: *mut aws_ring_buffer,
        minimum_size: usize,
        requested_size: usize,
        dest: *mut aws_byte_buf,
    ) -> ::core::ffi::c_int;
    #[doc = " Releases `buf` back to the ring buffer for further use. RELEASE MUST HAPPEN in the SAME ORDER AS ACQUIRE.\n If you do not, your application, and possibly computers within a thousand mile radius, may die terrible deaths,\n and the local drinking water will be poisoned for generations\n with fragments of what is left of your radioactive corrupted memory."]
    pub fn aws_ring_buffer_release(ring_buffer: *mut aws_ring_buffer, buf: *mut aws_byte_buf);
    #[doc = " Returns true if the memory in `buf` was vended by this ring buffer, false otherwise.\n Make sure `buf->buffer` and `ring_buffer->allocation` refer to the same memory region."]
    pub fn aws_ring_buffer_buf_belongs_to_pool(
        ring_buffer: *const aws_ring_buffer,
        buf: *const aws_byte_buf,
    ) -> bool;
    #[doc = " Initializes a new platform instance of mutex."]
    pub fn aws_rw_lock_init(lock: *mut aws_rw_lock) -> ::core::ffi::c_int;
    #[doc = " Cleans up internal resources."]
    pub fn aws_rw_lock_clean_up(lock: *mut aws_rw_lock);
    #[doc = " Blocks until it acquires the lock. While on some platforms such as Windows,\n this may behave as a reentrant mutex, you should not treat it like one. On\n platforms it is possible for it to be non-reentrant, it will be."]
    pub fn aws_rw_lock_rlock(lock: *mut aws_rw_lock) -> ::core::ffi::c_int;
    pub fn aws_rw_lock_wlock(lock: *mut aws_rw_lock) -> ::core::ffi::c_int;
    #[doc = " Attempts to acquire the lock but returns immediately if it can not.\n While on some platforms such as Windows, this may behave as a reentrant mutex,\n you should not treat it like one. On platforms it is possible for it to be non-reentrant, it will be.\n Note: For windows, minimum support server version is Windows Server 2008 R2 [desktop apps | UWP apps]"]
    pub fn aws_rw_lock_try_rlock(lock: *mut aws_rw_lock) -> ::core::ffi::c_int;
    pub fn aws_rw_lock_try_wlock(lock: *mut aws_rw_lock) -> ::core::ffi::c_int;
    #[doc = " Releases the lock."]
    pub fn aws_rw_lock_runlock(lock: *mut aws_rw_lock) -> ::core::ffi::c_int;
    pub fn aws_rw_lock_wunlock(lock: *mut aws_rw_lock) -> ::core::ffi::c_int;
    #[doc = " Submits a list of statistics objects to a statistics handler for processing\n\n handler - the statistics handler that will process the statistics objects\n interval - time period over which the statistics were gathered\n stats - list of pointers to structures that can be case to aws_crt_statistics_base (i.e. have category as a first\n   member)\n context - (optional) additional context specific to where the statistics handler has been attached"]
    pub fn aws_crt_statistics_handler_process_statistics(
        handler: *mut aws_crt_statistics_handler,
        interval: *mut aws_crt_statistics_sample_interval,
        stats: *mut aws_array_list,
        context: *mut ::core::ffi::c_void,
    );
    #[doc = " Queries the frequency (via an interval in milliseconds) which a statistics handler would like to be informed\n of statistics."]
    pub fn aws_crt_statistics_handler_get_report_interval_ms(
        handler: *mut aws_crt_statistics_handler,
    ) -> u64;
    #[doc = " completely destroys a statistics handler.  The handler's cleanup function must clean up the impl portion completely\n (including its allocation, if done separately)."]
    pub fn aws_crt_statistics_handler_destroy(handler: *mut aws_crt_statistics_handler);
    #[doc = " Allocates and initializes information about the system the current process is executing on.\n If successful returns an instance of aws_system_environment. If it fails, it will return NULL.\n\n Note: This api is used internally and is still early in its evolution.\n It may change in incompatible ways in the future."]
    pub fn aws_system_environment_load(
        allocator: *mut aws_allocator,
    ) -> *mut aws_system_environment;
    pub fn aws_system_environment_acquire(
        env: *mut aws_system_environment,
    ) -> *mut aws_system_environment;
    pub fn aws_system_environment_release(env: *mut aws_system_environment);
    #[doc = " Returns the virtualization vendor for the specified compute environment, e.g. \"Xen, Amazon EC2, etc...\"\n\n The return value may be empty and in that case no vendor was detected."]
    pub fn aws_system_environment_get_virtualization_vendor(
        env: *const aws_system_environment,
    ) -> aws_byte_cursor;
    #[doc = " Returns the product name for the specified compute environment. For example, the Amazon EC2 Instance type.\n\n The return value may be empty and in that case no vendor was detected."]
    pub fn aws_system_environment_get_virtualization_product_name(
        env: *const aws_system_environment,
    ) -> aws_byte_cursor;
    #[doc = " Returns the number of processors for the specified compute environment."]
    pub fn aws_system_environment_get_processor_count(env: *mut aws_system_environment) -> usize;
    #[doc = " Returns the number of separate cpu groupings (multi-socket configurations or NUMA)."]
    pub fn aws_system_environment_get_cpu_group_count(env: *const aws_system_environment) -> usize;
    pub fn aws_get_platform_build_os() -> aws_platform_os;
    pub fn aws_system_info_processor_count() -> usize;
    #[doc = " Returns the logical processor groupings on the system (such as multiple numa nodes)."]
    pub fn aws_get_cpu_group_count() -> u16;
    #[doc = " For a group, returns the number of CPUs it contains."]
    pub fn aws_get_cpu_count_for_group(group_idx: u16) -> usize;
    #[doc = " Fills in cpu_ids_array with the cpu_id's for the group. To obtain the size to allocate for cpu_ids_array\n and the value for argument for cpu_ids_array_length, call aws_get_cpu_count_for_group()."]
    pub fn aws_get_cpu_ids_for_group(
        group_idx: u16,
        cpu_ids_array: *mut aws_cpu_info,
        cpu_ids_array_length: usize,
    );
    pub fn aws_is_debugger_present() -> bool;
    pub fn aws_debug_break();
    pub fn aws_backtrace(stack_frames: *mut *mut ::core::ffi::c_void, num_frames: usize) -> usize;
    pub fn aws_backtrace_symbols(
        stack_frames: *const *mut ::core::ffi::c_void,
        stack_depth: usize,
    ) -> *mut *mut ::core::ffi::c_char;
    pub fn aws_backtrace_addr2line(
        stack_frames: *const *mut ::core::ffi::c_void,
        stack_depth: usize,
    ) -> *mut *mut ::core::ffi::c_char;
    #[doc = " Print a backtrace from either the current stack, or (if provided) the current exception/signal\n  call_site_data is siginfo_t* on POSIX, and LPEXCEPTION_POINTERS on Windows, and can be null"]
    pub fn aws_backtrace_print(fp: *mut FILE, call_site_data: *mut ::core::ffi::c_void);
    pub fn aws_backtrace_log(log_level: ::core::ffi::c_int);
    pub fn aws_init_memory_usage_for_current_process(
        memory_usage: *mut aws_memory_usage_stats,
    ) -> ::core::ffi::c_int;
    #[doc = " Init an aws_task"]
    pub fn aws_task_init(
        task: *mut aws_task,
        fn_: aws_task_fn,
        arg: *mut ::core::ffi::c_void,
        type_tag: *const ::core::ffi::c_char,
    );
    pub fn aws_task_run(task: *mut aws_task, status: aws_task_status);
    #[doc = " Initializes a task scheduler instance."]
    pub fn aws_task_scheduler_init(
        scheduler: *mut aws_task_scheduler,
        alloc: *mut aws_allocator,
    ) -> ::core::ffi::c_int;
    #[doc = " Empties and executes all queued tasks, passing the AWS_TASK_STATUS_CANCELED status to the task function.\n Cleans up any memory allocated, and prepares the instance for reuse or deletion."]
    pub fn aws_task_scheduler_clean_up(scheduler: *mut aws_task_scheduler);
    pub fn aws_task_scheduler_is_valid(scheduler: *const aws_task_scheduler) -> bool;
    #[doc = " Returns whether the scheduler has any scheduled tasks.\n next_task_time (optional) will be set to time of the next task, note that 0 will be set if tasks were\n added via aws_task_scheduler_schedule_now() and UINT64_MAX will be set if no tasks are scheduled at all."]
    pub fn aws_task_scheduler_has_tasks(
        scheduler: *const aws_task_scheduler,
        next_task_time: *mut u64,
    ) -> bool;
    #[doc = " Schedules a task to run immediately.\n The task should not be cleaned up or modified until its function is executed."]
    pub fn aws_task_scheduler_schedule_now(scheduler: *mut aws_task_scheduler, task: *mut aws_task);
    #[doc = " Schedules a task to run at time_to_run.\n The task should not be cleaned up or modified until its function is executed."]
    pub fn aws_task_scheduler_schedule_future(
        scheduler: *mut aws_task_scheduler,
        task: *mut aws_task,
        time_to_run: u64,
    );
    #[doc = " Removes task from the scheduler and invokes the task with the AWS_TASK_STATUS_CANCELED status."]
    pub fn aws_task_scheduler_cancel_task(scheduler: *mut aws_task_scheduler, task: *mut aws_task);
    #[doc = " Sequentially execute all tasks scheduled to run at, or before current_time.\n AWS_TASK_STATUS_RUN_READY will be passed to the task function as the task status.\n\n If a task schedules another task, the new task will not be executed until the next call to this function."]
    pub fn aws_task_scheduler_run_all(scheduler: *mut aws_task_scheduler, current_time: u64);
    #[doc = " Convert a status value to a c-string suitable for logging"]
    pub fn aws_task_status_to_c_str(status: aws_task_status) -> *const ::core::ffi::c_char;
    #[doc = " Creates a new instance of a thread scheduler. This object receives scheduled tasks and executes them inside a\n background thread. On success, this function returns an instance with a ref-count of 1. On failure it returns NULL.\n\n thread_options are optional.\n\n The semantics of this interface conform to the semantics of aws_task_scheduler."]
    pub fn aws_thread_scheduler_new(
        allocator: *mut aws_allocator,
        thread_options: *const aws_thread_options,
    ) -> *mut aws_thread_scheduler;
    #[doc = " Acquire a reference to the scheduler."]
    pub fn aws_thread_scheduler_acquire(scheduler: *mut aws_thread_scheduler);
    #[doc = " Release a reference to the scheduler."]
    pub fn aws_thread_scheduler_release(scheduler: *const aws_thread_scheduler);
    #[doc = " Schedules a task to run in the future. time_to_run is the absolute time from the system hw_clock."]
    pub fn aws_thread_scheduler_schedule_future(
        scheduler: *mut aws_thread_scheduler,
        task: *mut aws_task,
        time_to_run: u64,
    );
    #[doc = " Schedules a task to run as soon as possible."]
    pub fn aws_thread_scheduler_schedule_now(
        scheduler: *mut aws_thread_scheduler,
        task: *mut aws_task,
    );
    #[doc = " Cancel a task that has been scheduled. The cancellation callback will be invoked in the background thread.\n This function is slow, so please don't do it in the hot path for your code."]
    pub fn aws_thread_scheduler_cancel_task(
        scheduler: *mut aws_thread_scheduler,
        task: *mut aws_task,
    );
    #[doc = " Cross platform friendly version of timegm"]
    pub fn aws_timegm(t: *mut tm) -> time_t;
    #[doc = " Cross platform friendly version of localtime_r"]
    pub fn aws_localtime(time: time_t, t: *mut tm);
    #[doc = " Cross platform friendly version of gmtime_r"]
    pub fn aws_gmtime(time: time_t, t: *mut tm);
    #[doc = " Parses 'uri_str' and initializes uri. Returns AWS_OP_SUCCESS, on success, AWS_OP_ERR on failure.\n After calling this function, the parts can be accessed."]
    pub fn aws_uri_init_parse(
        uri: *mut aws_uri,
        allocator: *mut aws_allocator,
        uri_str: *const aws_byte_cursor,
    ) -> ::core::ffi::c_int;
    #[doc = " Initializes uri to values specified in options. Returns AWS_OP_SUCCESS, on success, AWS_OP_ERR on failure.\n After calling this function, the parts can be accessed."]
    pub fn aws_uri_init_from_builder_options(
        uri: *mut aws_uri,
        allocator: *mut aws_allocator,
        options: *mut aws_uri_builder_options,
    ) -> ::core::ffi::c_int;
    pub fn aws_uri_clean_up(uri: *mut aws_uri);
    #[doc = " Returns the scheme portion of the uri (e.g. http, https, ftp, ftps, etc...). If the scheme was not present\n in the uri, the returned value will be empty. It is the users job to determine the appropriate defaults\n if this field is empty, based on protocol, port, etc..."]
    pub fn aws_uri_scheme(uri: *const aws_uri) -> *const aws_byte_cursor;
    #[doc = " Returns the authority portion of the uri (host[:port]). If it was not present, this was a request uri. In that\n case, the value will be empty."]
    pub fn aws_uri_authority(uri: *const aws_uri) -> *const aws_byte_cursor;
    #[doc = " Returns the path portion of the uri, including any leading '/'. If not present, this value will be empty."]
    pub fn aws_uri_path(uri: *const aws_uri) -> *const aws_byte_cursor;
    #[doc = " Returns the query string portion of the uri, minus the '?'. If not present, this value will be empty."]
    pub fn aws_uri_query_string(uri: *const aws_uri) -> *const aws_byte_cursor;
    #[doc = " Returns the 'host_name' portion of the authority. If no authority was present, this value will be empty."]
    pub fn aws_uri_host_name(uri: *const aws_uri) -> *const aws_byte_cursor;
    #[doc = " Returns the port portion of the authority if it was present, otherwise, returns 0.\n If this is 0, it is the users job to determine the correct port based on scheme and protocol."]
    pub fn aws_uri_port(uri: *const aws_uri) -> u32;
    #[doc = " Returns the path and query portion of the uri (i.e., the thing you send across the wire)."]
    pub fn aws_uri_path_and_query(uri: *const aws_uri) -> *const aws_byte_cursor;
    #[doc = " For iterating over the params in the query string.\n `param` is an in/out argument used to track progress, it MUST be zeroed out to start.\n If true is returned, `param` contains the value of the next param.\n If false is returned, there are no further params.\n\n Edge cases:\n 1) Entries without '=' sign are treated as having a key and no value.\n    Example: First param in query string \"a&b=c\" has key=\"a\" value=\"\"\n\n 2) Blank entries are skipped.\n    Example: The only param in query string \"&&a=b\" is key=\"a\" value=\"b\""]
    pub fn aws_query_string_next_param(
        query_string: aws_byte_cursor,
        param: *mut aws_uri_param,
    ) -> bool;
    #[doc = " Parses query string and stores the parameters in 'out_params'. Returns AWS_OP_SUCCESS on success and\n AWS_OP_ERR on failure. The user is responsible for initializing out_params with item size of struct aws_query_param.\n The user is also responsible for cleaning up out_params when finished."]
    pub fn aws_query_string_params(
        query_string: aws_byte_cursor,
        out_params: *mut aws_array_list,
    ) -> ::core::ffi::c_int;
    #[doc = " For iterating over the params in the uri query string.\n `param` is an in/out argument used to track progress, it MUST be zeroed out to start.\n If true is returned, `param` contains the value of the next param.\n If false is returned, there are no further params.\n\n Edge cases:\n 1) Entries without '=' sign are treated as having a key and no value.\n    Example: First param in query string \"a&b=c\" has key=\"a\" value=\"\"\n\n 2) Blank entries are skipped.\n    Example: The only param in query string \"&&a=b\" is key=\"a\" value=\"b\""]
    pub fn aws_uri_query_string_next_param(uri: *const aws_uri, param: *mut aws_uri_param) -> bool;
    #[doc = " Parses query string and stores the parameters in 'out_params'. Returns AWS_OP_SUCCESS on success and\n AWS_OP_ERR on failure. The user is responsible for initializing out_params with item size of struct aws_query_param.\n The user is also responsible for cleaning up out_params when finished."]
    pub fn aws_uri_query_string_params(
        uri: *const aws_uri,
        out_params: *mut aws_array_list,
    ) -> ::core::ffi::c_int;
    #[doc = " Writes the uri path encoding of a cursor to a buffer.  This is the modified version of rfc3986 used by\n sigv4 signing."]
    pub fn aws_byte_buf_append_encoding_uri_path(
        buffer: *mut aws_byte_buf,
        cursor: *const aws_byte_cursor,
    ) -> ::core::ffi::c_int;
    #[doc = " Writes the uri query param encoding (passthrough alnum + '-' '_' '~' '.') of a UTF-8 cursor to a buffer\n For example, reading \"a b_c\" would write \"a%20b_c\"."]
    pub fn aws_byte_buf_append_encoding_uri_param(
        buffer: *mut aws_byte_buf,
        cursor: *const aws_byte_cursor,
    ) -> ::core::ffi::c_int;
    #[doc = " Writes the uri decoding of a UTF-8 cursor to a buffer,\n replacing %xx escapes by their single byte equivalent.\n For example, reading \"a%20b_c\" would write \"a b_c\"."]
    pub fn aws_byte_buf_append_decoding_uri(
        buffer: *mut aws_byte_buf,
        cursor: *const aws_byte_cursor,
    ) -> ::core::ffi::c_int;
    pub fn aws_uuid_init(uuid: *mut aws_uuid) -> ::core::ffi::c_int;
    pub fn aws_uuid_init_from_str(
        uuid: *mut aws_uuid,
        uuid_str: *const aws_byte_cursor,
    ) -> ::core::ffi::c_int;
    pub fn aws_uuid_to_str(uuid: *const aws_uuid, output: *mut aws_byte_buf) -> ::core::ffi::c_int;
    pub fn aws_uuid_equals(a: *const aws_uuid, b: *const aws_uuid) -> bool;
    #[doc = " Parse an XML document.\n WARNING: This is not a public API. It is only intended for use within the aws-c libraries."]
    pub fn aws_xml_parse(
        allocator: *mut aws_allocator,
        options: *const aws_xml_parser_options,
    ) -> ::core::ffi::c_int;
    #[doc = " Writes the contents of the body of node into out_body. out_body is an output parameter in this case. Upon success,\n out_body will contain the body of the node."]
    pub fn aws_xml_node_as_body(
        node: *mut aws_xml_node,
        out_body: *mut aws_byte_cursor,
    ) -> ::core::ffi::c_int;
    #[doc = " Traverse node and invoke on_node_encountered when a nested node is encountered."]
    pub fn aws_xml_node_traverse(
        node: *mut aws_xml_node,
        on_node_encountered: aws_xml_parser_on_node_encountered_fn,
        user_data: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    pub fn aws_xml_node_get_name(node: *const aws_xml_node) -> aws_byte_cursor;
    pub fn aws_xml_node_get_num_attributes(node: *const aws_xml_node) -> usize;
    pub fn aws_xml_node_get_attribute(
        node: *const aws_xml_node,
        attribute_index: usize,
    ) -> aws_xml_attribute;
}
