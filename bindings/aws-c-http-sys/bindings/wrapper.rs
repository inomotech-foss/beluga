/* automatically generated by rust-bindgen 0.69.1 */

pub type aws_http_errors = ::core::ffi::c_uint;
pub type aws_http2_error_code = ::core::ffi::c_uint;
pub type aws_http_log_subject = ::core::ffi::c_uint;
pub type aws_http_version = ::core::ffi::c_uint;
#[doc = " Invoked when connect completes.\n\n If unsuccessful, error_code will be set, connection will be NULL,\n and the on_shutdown callback will never be invoked.\n\n If successful, error_code will be 0 and connection will be valid.\n The user is now responsible for the connection and must\n call aws_http_connection_release() when they are done with it.\n\n The connection uses one event-loop thread to do all its work.\n The thread invoking this callback will be the same thread that invokes all\n future callbacks for this connection and its streams."]
pub type aws_http_on_client_connection_setup_fn = ::core::option::Option<
    unsafe extern "C" fn(
        connection: *mut aws_http_connection,
        error_code: ::core::ffi::c_int,
        user_data: *mut ::core::ffi::c_void,
    ),
>;
#[doc = " Invoked when the connection has finished shutting down.\n Never invoked if on_setup failed.\n This is always invoked on connection's event-loop thread.\n Note that the connection is not completely done until on_shutdown has been invoked\n AND aws_http_connection_release() has been called."]
pub type aws_http_on_client_connection_shutdown_fn = ::core::option::Option<
    unsafe extern "C" fn(
        connection: *mut aws_http_connection,
        error_code: ::core::ffi::c_int,
        user_data: *mut ::core::ffi::c_void,
    ),
>;
#[doc = " Invoked when the HTTP/2 settings change is complete.\n If connection setup successfully this will always be invoked whether settings change successfully or unsuccessfully.\n If error_code is AWS_ERROR_SUCCESS (0), then the peer has acknowledged the settings and the change has been applied.\n If error_code is non-zero, then a connection error occurred before the settings could be fully acknowledged and\n applied. This is always invoked on the connection's event-loop thread."]
pub type aws_http2_on_change_settings_complete_fn = ::core::option::Option<
    unsafe extern "C" fn(
        http2_connection: *mut aws_http_connection,
        error_code: ::core::ffi::c_int,
        user_data: *mut ::core::ffi::c_void,
    ),
>;
#[doc = " Invoked when the HTTP/2 PING completes, whether peer has acknowledged it or not.\n If error_code is AWS_ERROR_SUCCESS (0), then the peer has acknowledged the PING and round_trip_time_ns will be the\n round trip time in nano seconds for the connection.\n If error_code is non-zero, then a connection error occurred before the PING get acknowledgment and round_trip_time_ns\n will be useless in this case."]
pub type aws_http2_on_ping_complete_fn = ::core::option::Option<
    unsafe extern "C" fn(
        http2_connection: *mut aws_http_connection,
        round_trip_time_ns: u64,
        error_code: ::core::ffi::c_int,
        user_data: *mut ::core::ffi::c_void,
    ),
>;
#[doc = " Invoked when an HTTP/2 GOAWAY frame is received from peer.\n Implies that the peer has initiated shutdown, or encountered a serious error.\n Once a GOAWAY is received, no further streams may be created on this connection.\n\n @param http2_connection This HTTP/2 connection.\n @param last_stream_id ID of the last locally-initiated stream that peer will\n      process. Any locally-initiated streams with a higher ID are ignored by\n      peer, and are safe to retry on another connection.\n @param http2_error_code The HTTP/2 error code (RFC-7540 section 7) sent by peer.\n      `enum aws_http2_error_code` lists official codes.\n @param debug_data The debug data sent by peer. It can be empty. (NOTE: this data is only valid for the lifetime of\n      the callback. Make a deep copy if you wish to keep it longer.)\n @param user_data User-data passed to the callback."]
pub type aws_http2_on_goaway_received_fn = ::core::option::Option<
    unsafe extern "C" fn(
        http2_connection: *mut aws_http_connection,
        last_stream_id: u32,
        http2_error_code: u32,
        debug_data: aws_byte_cursor,
        user_data: *mut ::core::ffi::c_void,
    ),
>;
#[doc = " Invoked when new HTTP/2 settings from peer have been applied.\n Settings_array is the array of aws_http2_settings that contains all the settings we just changed in the order we\n applied (the order settings arrived). Num_settings is the number of elements in that array."]
pub type aws_http2_on_remote_settings_change_fn = ::core::option::Option<
    unsafe extern "C" fn(
        http2_connection: *mut aws_http_connection,
        settings_array: *const aws_http2_setting,
        num_settings: usize,
        user_data: *mut ::core::ffi::c_void,
    ),
>;
#[doc = " Callback invoked on each statistics sample.\n\n connection_nonce is unique to each connection for disambiguation of each callback per connection."]
pub type aws_http_statistics_observer_fn = ::core::option::Option<
    unsafe extern "C" fn(
        connection_nonce: usize,
        stats_list: *const aws_array_list,
        user_data: *mut ::core::ffi::c_void,
    ),
>;
pub type aws_http2_settings_id = ::core::ffi::c_uint;
pub type aws_http_connection_manager_on_connection_setup_fn = ::core::option::Option<
    unsafe extern "C" fn(
        connection: *mut aws_http_connection,
        error_code: ::core::ffi::c_int,
        user_data: *mut ::core::ffi::c_void,
    ),
>;
pub type aws_http_connection_manager_shutdown_complete_fn =
    ::core::option::Option<unsafe extern "C" fn(user_data: *mut ::core::ffi::c_void)>;
#[doc = " Always invoked asynchronously when the stream was created, successfully or not.\n When stream is NULL, error code will be set to indicate what happened.\n If there is a stream returned, you own the stream completely.\n Invoked on the same thread as other callback of the stream, which will be the thread of the connection, ideally.\n If there is no connection made, the callback will be invoked from a sperate thread."]
pub type aws_http2_stream_manager_on_stream_acquired_fn = ::core::option::Option<
    unsafe extern "C" fn(
        stream: *mut aws_http_stream,
        error_code: ::core::ffi::c_int,
        user_data: *mut ::core::ffi::c_void,
    ),
>;
#[doc = " Invoked asynchronously when the stream manager has been shutdown completely.\n Never invoked when `aws_http2_stream_manager_new` failed."]
pub type aws_http2_stream_manager_shutdown_complete_fn =
    ::core::option::Option<unsafe extern "C" fn(user_data: *mut ::core::ffi::c_void)>;
#[doc = " Controls whether a header's strings may be compressed by encoding the index of\n strings in a cache, rather than encoding the literal string.\n\n This setting has no effect on HTTP/1.x connections.\n On HTTP/2 connections this controls HPACK behavior.\n See RFC-7541 Section 7.1 for security considerations."]
pub type aws_http_header_compression = ::core::ffi::c_uint;
#[doc = " Header block type.\n INFORMATIONAL: Header block for 1xx informational (interim) responses.\n MAIN: Main header block sent with request or response.\n TRAILING: Headers sent after the body of a request or response."]
pub type aws_http_header_block = ::core::ffi::c_uint;
#[doc = " Function to invoke when a message transformation completes.\n This function MUST be invoked or the application will soft-lock.\n `message` and `complete_ctx` must be the same pointers provided to the `aws_http_message_transform_fn`.\n `error_code` should should be AWS_ERROR_SUCCESS if transformation was successful,\n otherwise pass a different AWS_ERROR_X value."]
pub type aws_http_message_transform_complete_fn = ::core::option::Option<
    unsafe extern "C" fn(
        message: *mut aws_http_message,
        error_code: ::core::ffi::c_int,
        complete_ctx: *mut ::core::ffi::c_void,
    ),
>;
#[doc = " A function that may modify a request or response before it is sent.\n The transformation may be asynchronous or immediate.\n The user MUST invoke the `complete_fn` when transformation is complete or the application will soft-lock.\n When invoking the `complete_fn`, pass along the `message` and `complete_ctx` provided here and an error code.\n The error code should be AWS_ERROR_SUCCESS if transformation was successful,\n otherwise pass a different AWS_ERROR_X value."]
pub type aws_http_message_transform_fn = ::core::option::Option<
    unsafe extern "C" fn(
        message: *mut aws_http_message,
        user_data: *mut ::core::ffi::c_void,
        complete_fn: aws_http_message_transform_complete_fn,
        complete_ctx: *mut ::core::ffi::c_void,
    ),
>;
#[doc = " Invoked repeatedly times as headers are received.\n At this point, aws_http_stream_get_incoming_response_status() can be called for the client.\n And aws_http_stream_get_incoming_request_method() and aws_http_stream_get_incoming_request_uri() can be called for\n the server.\n This is always invoked on the HTTP connection's event-loop thread.\n\n Return AWS_OP_SUCCESS to continue processing the stream.\n Return AWS_OP_ERR to indicate failure and cancel the stream."]
pub type aws_http_on_incoming_headers_fn = ::core::option::Option<
    unsafe extern "C" fn(
        stream: *mut aws_http_stream,
        header_block: aws_http_header_block,
        header_array: *const aws_http_header,
        num_headers: usize,
        user_data: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int,
>;
#[doc = " Invoked when the incoming header block of this type(informational/main/trailing) has been completely read.\n This is always invoked on the HTTP connection's event-loop thread.\n\n Return AWS_OP_SUCCESS to continue processing the stream.\n Return AWS_OP_ERR to indicate failure and cancel the stream."]
pub type aws_http_on_incoming_header_block_done_fn = ::core::option::Option<
    unsafe extern "C" fn(
        stream: *mut aws_http_stream,
        header_block: aws_http_header_block,
        user_data: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int,
>;
#[doc = " Called repeatedly as body data is received.\n The data must be copied immediately if you wish to preserve it.\n This is always invoked on the HTTP connection's event-loop thread.\n\n Note that, if the connection is using manual_window_management then the window\n size has shrunk by the amount of body data received. If the window size\n reaches 0 no further data will be received. Increment the window size with\n aws_http_stream_update_window().\n\n Return AWS_OP_SUCCESS to continue processing the stream.\n Return AWS_OP_ERR to indicate failure and cancel the stream."]
pub type aws_http_on_incoming_body_fn = ::core::option::Option<
    unsafe extern "C" fn(
        stream: *mut aws_http_stream,
        data: *const aws_byte_cursor,
        user_data: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int,
>;
#[doc = " Invoked when request has been completely read.\n This is always invoked on the HTTP connection's event-loop thread.\n\n Return AWS_OP_SUCCESS to continue processing the stream.\n Return AWS_OP_ERR to indicate failure and cancel the stream."]
pub type aws_http_on_incoming_request_done_fn = ::core::option::Option<
    unsafe extern "C" fn(
        stream: *mut aws_http_stream,
        user_data: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int,
>;
#[doc = " Invoked when a request/response stream is complete, whether successful or unsuccessful\n This is always invoked on the HTTP connection's event-loop thread.\n This will not be invoked if the stream is never activated."]
pub type aws_http_on_stream_complete_fn = ::core::option::Option<
    unsafe extern "C" fn(
        stream: *mut aws_http_stream,
        error_code: ::core::ffi::c_int,
        user_data: *mut ::core::ffi::c_void,
    ),
>;
#[doc = " Invoked when request/response stream destroy completely.\n This can be invoked within the same thead who release the refcount on http stream.\n This is invoked even if the stream is never activated."]
pub type aws_http_on_stream_destroy_fn =
    ::core::option::Option<unsafe extern "C" fn(user_data: *mut ::core::ffi::c_void)>;
#[doc = " Invoked right before request/response stream is complete to report the tracing metrics for aws_http_stream.\n This may be invoked synchronously when aws_http_stream_release() is called.\n This is invoked even if the stream is never activated.\n See `aws_http_stream_metrics` for details."]
pub type aws_http_on_stream_metrics_fn = ::core::option::Option<
    unsafe extern "C" fn(
        stream: *mut aws_http_stream,
        metrics: *const aws_http_stream_metrics,
        user_data: *mut ::core::ffi::c_void,
    ),
>;
#[doc = " Invoked when the data stream of an outgoing HTTP write operation is no longer in use.\n This is always invoked on the HTTP connection's event-loop thread.\n\n @param stream        HTTP-stream this write operation was submitted to.\n @param error_code    If error_code is AWS_ERROR_SUCCESS (0), the data was successfully sent.\n                      Any other error_code indicates that the HTTP-stream is in the process of terminating.\n                      If the error_code is AWS_ERROR_HTTP_STREAM_HAS_COMPLETED,\n                      the stream's termination has nothing to do with this write operation.\n                      Any other non-zero error code indicates a problem with this particular write\n                      operation's data.\n @param user_data     User data for this write operation."]
pub type aws_http_stream_write_complete_fn = ::core::option::Option<
    unsafe extern "C" fn(
        stream: *mut aws_http_stream,
        error_code: ::core::ffi::c_int,
        user_data: *mut ::core::ffi::c_void,
    ),
>;
#[doc = " Invoked when the data of an outgoing HTTP/1.1 chunk is no longer in use.\n This is always invoked on the HTTP connection's event-loop thread.\n\n @param stream        HTTP-stream this chunk was submitted to.\n @param error_code    If error_code is AWS_ERROR_SUCCESS (0), the data was successfully sent.\n                      Any other error_code indicates that the HTTP-stream is in the process of terminating.\n                      If the error_code is AWS_ERROR_HTTP_STREAM_HAS_COMPLETED,\n                      the stream's termination has nothing to do with this chunk.\n                      Any other non-zero error code indicates a problem with this particular chunk's data.\n @param user_data     User data for this chunk."]
pub type aws_http1_stream_write_chunk_complete_fn = aws_http_stream_write_complete_fn;
#[doc = " Invoked when the data of an outgoing HTTP2 data frame is no longer in use.\n This is always invoked on the HTTP connection's event-loop thread.\n\n @param stream        HTTP2-stream this write was submitted to.\n @param error_code    If error_code is AWS_ERROR_SUCCESS (0), the data was successfully sent.\n                      Any other error_code indicates that the HTTP-stream is in the process of terminating.\n                      If the error_code is AWS_ERROR_HTTP_STREAM_HAS_COMPLETED,\n                      the stream's termination has nothing to do with this write.\n                      Any other non-zero error code indicates a problem with this particular write's data.\n @param user_data     User data for this write."]
pub type aws_http2_stream_write_data_complete_fn = aws_http_stream_write_complete_fn;
#[doc = " Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n SPDX-License-Identifier: Apache-2.0."]
pub type aws_http_status_code = ::core::ffi::c_int;
#[doc = " @Deprecated - Supported proxy authentication modes.  Superceded by proxy strategy."]
pub type aws_http_proxy_authentication_type = ::core::ffi::c_uint;
pub type aws_http_proxy_env_var_type = ::core::ffi::c_uint;
#[doc = " Supported proxy connection types"]
pub type aws_http_proxy_connection_type = ::core::ffi::c_uint;
#[doc = " Synchronous (for now) callback function to fetch a token used in modifying CONNECT requests"]
pub type aws_http_proxy_negotiation_get_token_sync_fn = ::core::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::core::ffi::c_void,
        out_error_code: *mut ::core::ffi::c_int,
    ) -> *mut aws_string,
>;
#[doc = " Synchronous (for now) callback function to fetch a token used in modifying CONNECT request.  Includes a (byte string)\n context intended to be used as part of a challenge-response flow."]
pub type aws_http_proxy_negotiation_get_challenge_token_sync_fn = ::core::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::core::ffi::c_void,
        challenge_context: *const aws_byte_cursor,
        out_error_code: *mut ::core::ffi::c_int,
    ) -> *mut aws_string,
>;
#[doc = " Proxy negotiation logic must call this function to indicate an unsuccessful outcome"]
pub type aws_http_proxy_negotiation_terminate_fn = ::core::option::Option<
    unsafe extern "C" fn(
        message: *mut aws_http_message,
        error_code: ::core::ffi::c_int,
        internal_proxy_user_data: *mut ::core::ffi::c_void,
    ),
>;
#[doc = " Proxy negotiation logic must call this function to forward the potentially-mutated request back to the proxy\n connection logic."]
pub type aws_http_proxy_negotiation_http_request_forward_fn = ::core::option::Option<
    unsafe extern "C" fn(
        message: *mut aws_http_message,
        internal_proxy_user_data: *mut ::core::ffi::c_void,
    ),
>;
#[doc = " User-supplied transform callback which implements the proxy request flow and ultimately, across all execution\n pathways, invokes either the terminate function or the forward function appropriately.\n\n For tunneling proxy connections, this request flow transform only applies to the CONNECT stage of proxy\n connection establishment.\n\n For forwarding proxy connections, this request flow transform applies to every single http request that goes\n out on the connection.\n\n Forwarding proxy connections cannot yet support a truly async request transform without major surgery on http\n stream creation, so for now, we split into an async version (for tunneling proxies) and a separate\n synchronous version for forwarding proxies.  Also forwarding proxies are a kind of legacy dead-end in some\n sense.\n"]
pub type aws_http_proxy_negotiation_http_request_transform_async_fn = :: core :: option :: Option < unsafe extern "C" fn (proxy_negotiator : * mut aws_http_proxy_negotiator , message : * mut aws_http_message , negotiation_termination_callback : aws_http_proxy_negotiation_terminate_fn , negotiation_http_request_forward_callback : aws_http_proxy_negotiation_http_request_forward_fn , internal_proxy_user_data : * mut :: core :: ffi :: c_void) > ;
pub type aws_http_proxy_negotiation_http_request_transform_fn = ::core::option::Option<
    unsafe extern "C" fn(
        proxy_negotiator: *mut aws_http_proxy_negotiator,
        message: *mut aws_http_message,
    ) -> ::core::ffi::c_int,
>;
#[doc = " Tunneling proxy connections only.  A callback that lets the negotiator examine the headers in the\n response to the most recent CONNECT request as they arrive."]
pub type aws_http_proxy_negotiation_connect_on_incoming_headers_fn = ::core::option::Option<
    unsafe extern "C" fn(
        proxy_negotiator: *mut aws_http_proxy_negotiator,
        header_block: aws_http_header_block,
        header_array: *const aws_http_header,
        num_headers: usize,
    ) -> ::core::ffi::c_int,
>;
#[doc = " Tunneling proxy connections only.  A callback that lets the negotiator examine the status code of the\n response to the most recent CONNECT request."]
pub type aws_http_proxy_negotiator_connect_status_fn = ::core::option::Option<
    unsafe extern "C" fn(
        proxy_negotiator: *mut aws_http_proxy_negotiator,
        status_code: aws_http_status_code,
    ) -> ::core::ffi::c_int,
>;
#[doc = " Tunneling proxy connections only.  A callback that lets the negotiator examine the body of the response\n to the most recent CONNECT request."]
pub type aws_http_proxy_negotiator_connect_on_incoming_body_fn = ::core::option::Option<
    unsafe extern "C" fn(
        proxy_negotiator: *mut aws_http_proxy_negotiator,
        data: *const aws_byte_cursor,
    ) -> ::core::ffi::c_int,
>;
pub type aws_http_proxy_negotiation_retry_directive = ::core::ffi::c_uint;
pub type aws_http_proxy_negotiator_get_retry_directive_fn = ::core::option::Option<
    unsafe extern "C" fn(
        proxy_negotiator: *mut aws_http_proxy_negotiator,
    ) -> aws_http_proxy_negotiation_retry_directive,
>;
pub type aws_http_proxy_strategy_create_negotiator_fn = ::core::option::Option<
    unsafe extern "C" fn(
        proxy_strategy: *mut aws_http_proxy_strategy,
        allocator: *mut aws_allocator,
    ) -> *mut aws_http_proxy_negotiator,
>;
pub type aws_http_server_on_incoming_connection_fn = ::core::option::Option<
    unsafe extern "C" fn(
        server: *mut aws_http_server,
        connection: *mut aws_http_connection,
        error_code: ::core::ffi::c_int,
        user_data: *mut ::core::ffi::c_void,
    ),
>;
pub type aws_http_server_on_destroy_fn =
    ::core::option::Option<unsafe extern "C" fn(user_data: *mut ::core::ffi::c_void)>;
#[doc = " Invoked at the start of an incoming request.\n To process the request, the user must create a request handler stream and return it to the connection.\n If NULL is returned, the request will not be processed and the last error will be reported as the reason for failure."]
pub type aws_http_on_incoming_request_fn = ::core::option::Option<
    unsafe extern "C" fn(
        connection: *mut aws_http_connection,
        user_data: *mut ::core::ffi::c_void,
    ) -> *mut aws_http_stream,
>;
pub type aws_http_on_server_connection_shutdown_fn = ::core::option::Option<
    unsafe extern "C" fn(
        connection: *mut aws_http_connection,
        error_code: ::core::ffi::c_int,
        connection_user_data: *mut ::core::ffi::c_void,
    ),
>;
pub type aws_crt_http_statistics_category = ::core::ffi::c_uint;
#[doc = " Opcode describing the type of a websocket frame.\n RFC-6455 Section 5.2"]
pub type aws_websocket_opcode = ::core::ffi::c_uint;
#[doc = " Called when websocket setup is complete.\n Called exactly once on the websocket's event-loop thread.\n See `aws_websocket_on_connection_setup_data`."]
pub type aws_websocket_on_connection_setup_fn = ::core::option::Option<
    unsafe extern "C" fn(
        setup: *const aws_websocket_on_connection_setup_data,
        user_data: *mut ::core::ffi::c_void,
    ),
>;
#[doc = " Called when the websocket has finished shutting down.\n Called once on the websocket's event-loop thread if setup succeeded.\n If setup failed, this is never called."]
pub type aws_websocket_on_connection_shutdown_fn = ::core::option::Option<
    unsafe extern "C" fn(
        websocket: *mut aws_websocket,
        error_code: ::core::ffi::c_int,
        user_data: *mut ::core::ffi::c_void,
    ),
>;
#[doc = " Called when a new frame arrives.\n Invoked once per frame on the websocket's event-loop thread.\n Each incoming-frame-begin call will eventually be followed by an incoming-frame-complete call,\n before the next frame begins and before the websocket shuts down.\n\n Return true to proceed normally. If false is returned, the websocket will read no further data,\n the frame will complete with an error-code, and the connection will close."]
pub type aws_websocket_on_incoming_frame_begin_fn = ::core::option::Option<
    unsafe extern "C" fn(
        websocket: *mut aws_websocket,
        frame: *const aws_websocket_incoming_frame,
        user_data: *mut ::core::ffi::c_void,
    ) -> bool,
>;
#[doc = " Called repeatedly as payload data arrives.\n Invoked 0 or more times on the websocket's event-loop thread.\n Payload data will not be valid after this call, so copy if necessary.\n The payload data is always unmasked at this point.\n\n NOTE: If you created the websocket with `manual_window_management` set true, you must maintain the read window.\n Whenever the read window reaches 0, you will stop receiving anything.\n The websocket's `initial_window_size` determines the starting size of the read window.\n The read window shrinks as you receive the payload from \"data\" frames (TEXT, BINARY, and CONTINUATION).\n Use aws_websocket_increment_read_window() to increment the window again and keep frames flowing.\n Maintain a larger window to keep up high throughput.\n You only need to worry about the payload from \"data\" frames.\n The websocket automatically increments the window to account for any\n other incoming bytes, including other parts of a frame (opcode, payload-length, etc)\n and the payload of other frame types (PING, PONG, CLOSE).\n\n Return true to proceed normally. If false is returned, the websocket will read no further data,\n the frame will complete with an error-code, and the connection will close."]
pub type aws_websocket_on_incoming_frame_payload_fn = ::core::option::Option<
    unsafe extern "C" fn(
        websocket: *mut aws_websocket,
        frame: *const aws_websocket_incoming_frame,
        data: aws_byte_cursor,
        user_data: *mut ::core::ffi::c_void,
    ) -> bool,
>;
#[doc = " Called when done processing an incoming frame.\n If error_code is non-zero, an error occurred and the payload may not have been completely received.\n Invoked once per frame on the websocket's event-loop thread.\n\n Return true to proceed normally. If false is returned, the websocket will read no further data\n and the connection will close."]
pub type aws_websocket_on_incoming_frame_complete_fn = ::core::option::Option<
    unsafe extern "C" fn(
        websocket: *mut aws_websocket,
        frame: *const aws_websocket_incoming_frame,
        error_code: ::core::ffi::c_int,
        user_data: *mut ::core::ffi::c_void,
    ) -> bool,
>;
#[doc = " Called repeatedly as the websocket's payload is streamed out.\n The user should write payload data to out_buf, up to available capacity.\n The websocket will mask this data for you, if necessary.\n Invoked repeatedly on the websocket's event-loop thread.\n\n Return true to proceed normally. If false is returned, the websocket will send no further data,\n the frame will complete with an error-code, and the connection will close."]
pub type aws_websocket_stream_outgoing_payload_fn = ::core::option::Option<
    unsafe extern "C" fn(
        websocket: *mut aws_websocket,
        out_buf: *mut aws_byte_buf,
        user_data: *mut ::core::ffi::c_void,
    ) -> bool,
>;
#[doc = " Called when a aws_websocket_send_frame() operation completes.\n error_code will be zero if the operation was successful.\n \"Success\" does not guarantee that the peer actually received or processed the frame.\n Invoked exactly once per sent frame on the websocket's event-loop thread."]
pub type aws_websocket_outgoing_frame_complete_fn = ::core::option::Option<
    unsafe extern "C" fn(
        websocket: *mut aws_websocket,
        error_code: ::core::ffi::c_int,
        user_data: *mut ::core::ffi::c_void,
    ),
>;
#[doc = " An HTTP connection.\n This type is used by both server-side and client-side connections.\n This type is also used by all supported versions of HTTP."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_http_connection {
    _unused: [u8; 0],
}
#[doc = " Configuration options for connection monitoring"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_http_connection_monitoring_options {
    #[doc = " minimum required throughput of the connection.  Throughput is only measured against the interval of time where\n there is actual io to perform.  Read and write throughput are measured and checked independently of one another."]
    pub minimum_throughput_bytes_per_second: u64,
    pub allowable_throughput_failure_interval_seconds: u32,
    #[doc = " invoked on each statistics publish by the underlying IO channel. Install this callback to receive the statistics\n for observation. This field is optional."]
    pub statistics_observer_fn: aws_http_statistics_observer_fn,
    #[doc = " user_data to be passed to statistics_observer_fn."]
    pub statistics_observer_user_data: *mut ::core::ffi::c_void,
}
#[doc = " Options specific to HTTP/1.x connections."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_http1_connection_options {
    #[doc = " Optional\n Capacity in bytes of the HTTP/1 connection's read buffer.\n The buffer grows if the flow-control window of the incoming HTTP-stream\n reaches zero. If the buffer reaches capacity, no further socket data is\n read until the HTTP-stream's window opens again, allowing data to resume flowing.\n\n Ignored if `manual_window_management` is false.\n If zero is specified (the default) then a default capacity is chosen.\n A capacity that is too small may hinder throughput.\n A capacity that is too big may waste memory without helping throughput."]
    pub read_buffer_capacity: usize,
}
#[doc = " Options specific to HTTP/2 connections."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_http2_connection_options {
    #[doc = " Optional\n The data of settings to change for initial settings.\n Note: each setting has its boundary. If settings_array is not set, num_settings has to be 0 to send an empty\n SETTINGS frame."]
    pub initial_settings_array: *mut aws_http2_setting,
    #[doc = " Required\n The num of settings to change (Length of the initial_settings_array)."]
    pub num_initial_settings: usize,
    #[doc = " Optional.\n Invoked when the HTTP/2 initial settings change is complete.\n If failed to setup the connection, this will not be invoked.\n Otherwise, this will be invoked, whether settings change successfully or unsuccessfully.\n See `aws_http2_on_change_settings_complete_fn`."]
    pub on_initial_settings_completed: aws_http2_on_change_settings_complete_fn,
    #[doc = " Optional\n The max number of recently-closed streams to remember.\n Set it to zero to use the default setting, AWS_HTTP2_DEFAULT_MAX_CLOSED_STREAMS\n\n If the connection receives a frame for a closed stream,\n the frame will be ignored or cause a connection error,\n depending on the frame type and how the stream was closed.\n Remembering more streams reduces the chances that a late frame causes\n a connection error, but costs some memory."]
    pub max_closed_streams: usize,
    #[doc = " Optional.\n Invoked when a valid GOAWAY frame received.\n See `aws_http2_on_goaway_received_fn`."]
    pub on_goaway_received: aws_http2_on_goaway_received_fn,
    #[doc = " Optional.\n Invoked when new settings from peer have been applied.\n See `aws_http2_on_remote_settings_change_fn`."]
    pub on_remote_settings_change: aws_http2_on_remote_settings_change_fn,
    #[doc = " Optional.\n Set to true to manually manage the flow-control window of whole HTTP/2 connection.\n\n If false, the connection will maintain its flow-control windows such that\n no back-pressure is applied and data arrives as fast as possible.\n\n If true, the flow-control window of the whole connection will shrink as body data\n is received (headers, padding, and other metadata do not affect the window) for every streams\n created on this connection.\n The initial connection flow-control window is 65,535.\n Once the connection's flow-control window reaches to 0, all the streams on the connection stop receiving any\n further data.\n The user must call aws_http2_connection_update_window() to increment the connection's\n window and keep data flowing.\n Note: the padding of data frame counts to the flow-control window.\n But, the client will always automatically update the window for padding even for manual window update."]
    pub conn_manual_window_management: bool,
}
#[doc = " Options for creating an HTTP client connection.\n Initialize with AWS_HTTP_CLIENT_CONNECTION_OPTIONS_INIT to set default values."]
#[repr(C)]
pub struct aws_http_client_connection_options {
    #[doc = " The sizeof() this struct, used for versioning.\n Set by AWS_HTTP_CLIENT_CONNECTION_OPTIONS_INIT."]
    pub self_size: usize,
    #[doc = " Required.\n Must outlive the connection."]
    pub allocator: *mut aws_allocator,
    #[doc = " Required.\n The connection keeps the bootstrap alive via ref-counting."]
    pub bootstrap: *mut aws_client_bootstrap,
    #[doc = " Required.\n aws_http_client_connect() makes a copy."]
    pub host_name: aws_byte_cursor,
    #[doc = " Required."]
    pub port: u32,
    #[doc = " Required.\n aws_http_client_connect() makes a copy."]
    pub socket_options: *const aws_socket_options,
    #[doc = " Optional.\n aws_http_client_connect() deep-copies all contents,\n and keeps `aws_tls_ctx` alive via ref-counting."]
    pub tls_options: *const aws_tls_connection_options,
    #[doc = " Optional\n Configuration options related to http proxy usage.\n Relevant fields are copied internally."]
    pub proxy_options: *const aws_http_proxy_options,
    pub proxy_ev_settings: *const proxy_env_var_settings,
    #[doc = " Optional\n Configuration options related to connection health monitoring"]
    pub monitoring_options: *const aws_http_connection_monitoring_options,
    #[doc = " Optional (ignored if 0).\n After a request is fully sent, if the server does not begin responding within N milliseconds,\n then fail with AWS_ERROR_HTTP_RESPONSE_FIRST_BYTE_TIMEOUT.\n This can be overridden per-request by aws_http_make_request_options.response_first_byte_timeout_ms.\n TODO: Only supported in HTTP/1.1 now, support it in HTTP/2"]
    pub response_first_byte_timeout_ms: u64,
    #[doc = " Set to true to manually manage the flow-control window of each stream.\n\n If false, the connection will maintain its flow-control windows such that\n no back-pressure is applied and data arrives as fast as possible.\n\n If true, the flow-control window of each stream will shrink as body data\n is received (headers, padding, and other metadata do not affect the window).\n `initial_window_size` determines the starting size of each stream's window for HTTP/1 stream, while HTTP/2 stream\n will use the settings AWS_HTTP2_SETTINGS_INITIAL_WINDOW_SIZE to inform the other side about read back pressure\n\n If a stream's flow-control window reaches 0, no further data will be received. The user must call\n aws_http_stream_update_window() to increment the stream's window and keep data flowing.\n\n If a HTTP/2 connection created, it will ONLY control the stream window\n management. Connection window management is controlled by\n conn_manual_window_management. Note: the padding of data frame counts to the flow-control window.\n But, the client will always automatically update the window for padding even for manual window update."]
    pub manual_window_management: bool,
    #[doc = " The starting size of each HTTP stream's flow-control window for HTTP/1 connection.\n Required if `manual_window_management` is true,\n ignored if `manual_window_management` is false.\n\n Always ignored when HTTP/2 connection created. The initial window size is controlled by the settings,\n `AWS_HTTP2_SETTINGS_INITIAL_WINDOW_SIZE`"]
    pub initial_window_size: usize,
    #[doc = " User data for callbacks\n Optional."]
    pub user_data: *mut ::core::ffi::c_void,
    #[doc = " Invoked when connect completes.\n Required.\n See `aws_http_on_client_connection_setup_fn`."]
    pub on_setup: aws_http_on_client_connection_setup_fn,
    #[doc = " Invoked when the connection has finished shutting down.\n Never invoked if setup failed.\n Optional.\n See `aws_http_on_client_connection_shutdown_fn`."]
    pub on_shutdown: aws_http_on_client_connection_shutdown_fn,
    #[doc = " Optional.\n When true, use prior knowledge to set up an HTTP/2 connection on a cleartext\n connection.\n When TLS is set and this is true, the connection will failed to be established,\n as prior knowledge only works for cleartext TLS.\n Refer to RFC7540 3.4"]
    pub prior_knowledge_http2: bool,
    #[doc = " Optional.\n Pointer to the hash map containing the ALPN string to protocol to use.\n Hash from `struct aws_string *` to `enum aws_http_version`.\n If not set, only the predefined string `h2` and `http/1.1` will be recognized. Other negotiated ALPN string will\n result in a HTTP1/1 connection\n Note: Connection will keep a deep copy of the table and the strings."]
    pub alpn_string_map: *mut aws_hash_table,
    #[doc = " Options specific to HTTP/1.x connections.\n Optional.\n Ignored if connection is not HTTP/1.x.\n If connection is HTTP/1.x and options were not specified, default values are used."]
    pub http1_options: *const aws_http1_connection_options,
    #[doc = " Options specific to HTTP/2 connections.\n Optional.\n Ignored if connection is not HTTP/2.\n If connection is HTTP/2 and options were not specified, default values are used."]
    pub http2_options: *const aws_http2_connection_options,
    #[doc = " Optional.\n Requests the channel/connection be bound to a specific event loop rather than chosen sequentially from the\n event loop group associated with the client bootstrap."]
    pub requested_event_loop: *mut aws_event_loop,
    #[doc = " Optional\n Host resolution override that allows the user to override DNS behavior for this particular connection."]
    pub host_resolution_config: *mut aws_host_resolution_config,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_http2_setting {
    pub id: aws_http2_settings_id,
    pub value: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_http_connection_manager {
    _unused: [u8; 0],
}
#[doc = " Metrics for logging and debugging purpose."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_http_manager_metrics {
    #[doc = " The number of additional concurrent requests that can be supported by the HTTP manager without needing to\n establish additional connections to the target server.\n\n For connection manager, it equals to connections that's idle.\n For stream manager, it equals to the number of streams that are possible to be made without creating new\n connection, although the implementation can create new connection without fully filling it."]
    pub available_concurrency: usize,
    pub pending_concurrency_acquires: usize,
    pub leased_concurrency: usize,
}
#[repr(C)]
pub struct aws_http_connection_manager_options {
    pub bootstrap: *mut aws_client_bootstrap,
    pub initial_window_size: usize,
    pub socket_options: *const aws_socket_options,
    #[doc = " Options to create secure (HTTPS) connections.\n For secure connections, set \"h2\" in the ALPN string for HTTP/2, otherwise HTTP/1.1 is used.\n\n Leave NULL to create cleartext (HTTP) connections.\n For cleartext connections, use `http2_prior_knowledge` (RFC-7540 3.4)\n to control whether that are treated as HTTP/1.1 or HTTP/2."]
    pub tls_connection_options: *const aws_tls_connection_options,
    #[doc = " Specify whether you have prior knowledge that cleartext (HTTP) connections are HTTP/2 (RFC-7540 3.4).\n If false, then cleartext connections are treated as HTTP/1.1.\n It is illegal to set this true when secure connections are being used.\n Note that upgrading from HTTP/1.1 to HTTP/2 is not supported (RFC-7540 3.2)."]
    pub http2_prior_knowledge: bool,
    pub monitoring_options: *const aws_http_connection_monitoring_options,
    pub host: aws_byte_cursor,
    pub port: u32,
    #[doc = " Optional.\n HTTP/2 specific configuration. Check `struct aws_http2_connection_options` for details of each config"]
    pub initial_settings_array: *const aws_http2_setting,
    pub num_initial_settings: usize,
    pub max_closed_streams: usize,
    pub http2_conn_manual_window_management: bool,
    pub proxy_options: *const aws_http_proxy_options,
    pub proxy_ev_settings: *const proxy_env_var_settings,
    pub max_connections: usize,
    pub shutdown_complete_user_data: *mut ::core::ffi::c_void,
    pub shutdown_complete_callback: aws_http_connection_manager_shutdown_complete_fn,
    #[doc = " If set to true, the read back pressure mechanism will be enabled."]
    pub enable_read_back_pressure: bool,
    #[doc = " If set to a non-zero value, then connections that stay in the pool longer than the specified\n timeout will be closed automatically."]
    pub max_connection_idle_in_milliseconds: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_http2_stream_manager {
    _unused: [u8; 0],
}
#[doc = " A stream exists for the duration of a request/response exchange.\n A client creates a stream to send a request and receive a response.\n A server creates a stream to receive a request and send a response.\n In http/2, a push-promise stream can be sent by a server and received by a client."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_http_stream {
    _unused: [u8; 0],
}
#[doc = " HTTP/2 stream manager configuration struct.\n\n Contains all of the configuration needed to create an http2 connection as well as\n connection manager under the hood."]
#[repr(C)]
pub struct aws_http2_stream_manager_options {
    #[doc = " basic http connection configuration"]
    pub bootstrap: *mut aws_client_bootstrap,
    pub socket_options: *const aws_socket_options,
    #[doc = " Options to create secure (HTTPS) connections.\n For secure connections, the ALPN string must be \"h2\".\n\n To create cleartext (HTTP) connections, leave this NULL\n and set `http2_prior_knowledge` (RFC-7540 3.4)."]
    pub tls_connection_options: *const aws_tls_connection_options,
    #[doc = " Specify whether you have prior knowledge that cleartext (HTTP) connections are HTTP/2 (RFC-7540 3.4).\n It is illegal to set this true when secure connections are being used.\n Note that upgrading from HTTP/1.1 to HTTP/2 is not supported (RFC-7540 3.2)."]
    pub http2_prior_knowledge: bool,
    pub host: aws_byte_cursor,
    pub port: u32,
    #[doc = " Optional.\n HTTP/2 connection configuration. Check `struct aws_http2_connection_options` for details of each config.\n Notes for window control:\n - By default, client will will maintain its flow-control windows such that no back-pressure is applied and data\n arrives as fast as possible.\n - For connection level window control, `conn_manual_window_management` will enable manual control. The\n inital window size is not controllable.\n - For stream level window control, `enable_read_back_pressure` will enable manual control. The initial window\n size needs to be set through `initial_settings_array`."]
    pub initial_settings_array: *const aws_http2_setting,
    pub num_initial_settings: usize,
    pub max_closed_streams: usize,
    pub conn_manual_window_management: bool,
    #[doc = " HTTP/2 Stream window control.\n If set to true, the read back pressure mechanism will be enabled for streams created.\n The initial window size can be set by `AWS_HTTP2_SETTINGS_INITIAL_WINDOW_SIZE` via `initial_settings_array`"]
    pub enable_read_back_pressure: bool,
    pub monitoring_options: *const aws_http_connection_monitoring_options,
    pub proxy_options: *const aws_http_proxy_options,
    pub proxy_ev_settings: *const proxy_env_var_settings,
    #[doc = " Required.\n When the stream manager finishes deleting all the resources, the callback will be invoked."]
    pub shutdown_complete_user_data: *mut ::core::ffi::c_void,
    pub shutdown_complete_callback: aws_http2_stream_manager_shutdown_complete_fn,
    #[doc = " Optional.\n When set, connection will be closed if 5xx response received from server."]
    pub close_connection_on_server_error: bool,
    #[doc = " Optional.\n The period for all the connections held by stream manager to send a PING in milliseconds.\n If you specify 0, manager will NOT send any PING.\n Note: if set, it must be large than the time of ping timeout setting."]
    pub connection_ping_period_ms: usize,
    #[doc = " Optional.\n Network connection will be closed if a ping response is not received\n within this amount of time (milliseconds).\n If you specify 0, a default value will be used."]
    pub connection_ping_timeout_ms: usize,
    #[doc = " Optional.\n 0 will be considered as using a default value.\n The ideal number of concurrent streams for a connection. Stream manager will try to create a new connection if\n one connection reaches this number. But, if the max connections reaches, manager will reuse connections to create\n the acquired steams as much as possible."]
    pub ideal_concurrent_streams_per_connection: usize,
    #[doc = " Optional.\n Default is no limit, which will use the limit from the server. 0 will be considered as using the default value.\n The real number of concurrent streams per connection will be controlled by the minmal value of the setting from\n other end and the value here."]
    pub max_concurrent_streams_per_connection: usize,
    #[doc = " Required.\n The max number of connections will be open at same time. If all the connections are full, manager will wait until\n available to vender more streams"]
    pub max_connections: usize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_http2_stream_manager_acquire_stream_options {
    #[doc = " Required.\n Invoked when the stream finishes acquiring by stream manager."]
    pub callback: aws_http2_stream_manager_on_stream_acquired_fn,
    #[doc = " Optional.\n User data for the callback."]
    pub user_data: *mut ::core::ffi::c_void,
    pub options: *const aws_http_make_request_options,
}
#[doc = " A lightweight HTTP header struct.\n Note that the underlying strings are not owned by the byte cursors."]
#[repr(C)]
pub struct aws_http_header {
    pub name: aws_byte_cursor,
    pub value: aws_byte_cursor,
    pub compression: aws_http_header_compression,
}
#[doc = " A transformable block of HTTP headers.\n Provides a nice API for getting/setting header names and values.\n\n All strings are copied and stored within this datastructure.\n The index of a given header may change any time headers are modified.\n When iterating headers, the following ordering rules apply:\n\n - Headers with the same name will always be in the same order, relative to one another.\n   If \"A: one\" is added before \"A: two\", then \"A: one\" will always precede \"A: two\".\n\n - Headers with different names could be in any order, relative to one another.\n   If \"A: one\" is seen before \"B: bee\" in one iteration, you might see \"B: bee\" before \"A: one\" on the next."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_http_headers {
    _unused: [u8; 0],
}
#[doc = " The definition for an outgoing HTTP request or response.\n The message may be transformed (ex: signing the request) before its data is eventually sent.\n\n The message keeps internal copies of its trivial strings (method, path, headers)\n but does NOT take ownership of its body stream.\n\n A language binding would likely present this as an HttpMessage base class with\n HttpRequest and HttpResponse subclasses."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_http_message {
    _unused: [u8; 0],
}
#[doc = " Tracing metrics for aws_http_stream.\n Data maybe not be available if the data of stream was never sent/received before it completes."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_http_stream_metrics {
    pub send_start_timestamp_ns: i64,
    pub send_end_timestamp_ns: i64,
    pub sending_duration_ns: i64,
    pub receive_start_timestamp_ns: i64,
    pub receive_end_timestamp_ns: i64,
    pub receiving_duration_ns: i64,
    pub stream_id: u32,
}
#[doc = " Options for creating a stream which sends a request from the client and receives a response from the server."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_http_make_request_options {
    #[doc = " The sizeof() this struct, used for versioning.\n Required."]
    pub self_size: usize,
    #[doc = " Definition for outgoing request.\n Required.\n The request will be kept alive via refcounting until the request completes."]
    pub request: *mut aws_http_message,
    pub user_data: *mut ::core::ffi::c_void,
    #[doc = " Invoked repeatedly times as headers are received.\n Optional.\n See `aws_http_on_incoming_headers_fn`."]
    pub on_response_headers: aws_http_on_incoming_headers_fn,
    #[doc = " Invoked when response header block has been completely read.\n Optional.\n See `aws_http_on_incoming_header_block_done_fn`."]
    pub on_response_header_block_done: aws_http_on_incoming_header_block_done_fn,
    #[doc = " Invoked repeatedly as body data is received.\n Optional.\n See `aws_http_on_incoming_body_fn`."]
    pub on_response_body: aws_http_on_incoming_body_fn,
    #[doc = " Invoked right before stream is complete, whether successful or unsuccessful\n Optional.\n See `aws_http_on_stream_metrics_fn`"]
    pub on_metrics: aws_http_on_stream_metrics_fn,
    #[doc = " Invoked when request/response stream is complete, whether successful or unsuccessful\n Optional.\n See `aws_http_on_stream_complete_fn`."]
    pub on_complete: aws_http_on_stream_complete_fn,
    pub on_destroy: aws_http_on_stream_destroy_fn,
    #[doc = " When using HTTP/2, request body data will be provided over time. The stream will only be polled for writing\n when data has been supplied via `aws_http2_stream_write_data`"]
    pub http2_use_manual_data_writes: bool,
    #[doc = " Optional (ignored if 0).\n After a request is fully sent, if the server does not begin responding within N milliseconds, then fail with\n AWS_ERROR_HTTP_RESPONSE_FIRST_BYTE_TIMEOUT.\n It override the connection level settings, when the request completes, the\n original monitoring options will be applied back to the connection.\n TODO: Only supported in HTTP/1.1 now, support it in HTTP/2"]
    pub response_first_byte_timeout_ms: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_http_request_handler_options {
    pub self_size: usize,
    #[doc = " Required."]
    pub server_connection: *mut aws_http_connection,
    #[doc = " user_data passed to callbacks.\n Optional."]
    pub user_data: *mut ::core::ffi::c_void,
    #[doc = " Invoked repeatedly times as headers are received.\n Optional.\n See `aws_http_on_incoming_headers_fn`."]
    pub on_request_headers: aws_http_on_incoming_headers_fn,
    #[doc = " Invoked when the request header block has been completely read.\n Optional.\n See `aws_http_on_incoming_header_block_done_fn`."]
    pub on_request_header_block_done: aws_http_on_incoming_header_block_done_fn,
    #[doc = " Invoked as body data is received.\n Optional.\n See `aws_http_on_incoming_body_fn`."]
    pub on_request_body: aws_http_on_incoming_body_fn,
    #[doc = " Invoked when request has been completely read.\n Optional.\n See `aws_http_on_incoming_request_done_fn`."]
    pub on_request_done: aws_http_on_incoming_request_done_fn,
    #[doc = " Invoked when request/response stream is complete, whether successful or unsuccessful\n Optional.\n See `aws_http_on_stream_complete_fn`."]
    pub on_complete: aws_http_on_stream_complete_fn,
    pub on_destroy: aws_http_on_stream_destroy_fn,
}
#[doc = " HTTP/1.1 chunk extension for chunked encoding.\n Note that the underlying strings are not owned by the byte cursors."]
#[repr(C)]
pub struct aws_http1_chunk_extension {
    pub key: aws_byte_cursor,
    pub value: aws_byte_cursor,
}
#[doc = " Encoding options for an HTTP/1.1 chunked transfer encoding chunk."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_http1_chunk_options {
    pub chunk_data: *mut aws_input_stream,
    pub chunk_data_size: u64,
    #[doc = " A pointer to an array of chunked extensions.\n The num_extensions must match the length of the array.\n This data is deep-copied by aws_http1_stream_write_chunk(),\n it does not need to remain valid until on_complete is invoked."]
    pub extensions: *mut aws_http1_chunk_extension,
    #[doc = " The number of elements defined in the extensions array."]
    pub num_extensions: usize,
    #[doc = " Invoked when the chunk data is no longer in use, whether or not it was successfully sent.\n Optional.\n See `aws_http1_stream_write_chunk_complete_fn`."]
    pub on_complete: aws_http1_stream_write_chunk_complete_fn,
    #[doc = " User provided data passed to the on_complete callback on its invocation."]
    pub user_data: *mut ::core::ffi::c_void,
}
#[doc = " Encoding options for manual H2 data frame writes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_http2_stream_write_data_options {
    #[doc = " The data to be sent.\n Optional.\n If not set, input stream with length 0 will be used."]
    pub data: *mut aws_input_stream,
    #[doc = " Set true when it's the last chunk to be sent.\n After a write with end_stream, no more data write will be accepted."]
    pub end_stream: bool,
    #[doc = " Invoked when the data stream is no longer in use, whether or not it was successfully sent.\n Optional.\n See `aws_http2_stream_write_data_complete_fn`."]
    pub on_complete: aws_http2_stream_write_data_complete_fn,
    #[doc = " User provided data passed to the on_complete callback on its invocation."]
    pub user_data: *mut ::core::ffi::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_http_proxy_config {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct proxy_env_var_settings {
    pub env_var_type: aws_http_proxy_env_var_type,
    pub connection_type: aws_http_proxy_connection_type,
    pub tls_options: *const aws_tls_connection_options,
}
#[doc = " Options for http proxy server usage"]
#[repr(C)]
pub struct aws_http_proxy_options {
    #[doc = " Type of proxy connection to make"]
    pub connection_type: aws_http_proxy_connection_type,
    #[doc = " Proxy host to connect to"]
    pub host: aws_byte_cursor,
    #[doc = " Port to make the proxy connection to"]
    pub port: u32,
    #[doc = " Optional.\n TLS configuration for the Local <-> Proxy connection\n Must be distinct from the the TLS options in the parent aws_http_connection_options struct"]
    pub tls_options: *const aws_tls_connection_options,
    #[doc = " Optional\n Advanced option that allows the user to create a custom strategy that gives low-level control of\n certain logical flows within the proxy logic.\n\n For tunneling proxies it allows custom retry and adaptive negotiation of CONNECT requests.\n For forwarding proxies it allows custom request transformations."]
    pub proxy_strategy: *mut aws_http_proxy_strategy,
    #[doc = " @Deprecated - What type of proxy authentication to use, if any.\n Replaced by instantiating a proxy_strategy"]
    pub auth_type: aws_http_proxy_authentication_type,
    #[doc = " @Deprecated - Optional user name to use for basic authentication\n Replaced by instantiating a proxy_strategy via aws_http_proxy_strategy_new_basic_auth()"]
    pub auth_username: aws_byte_cursor,
    #[doc = " @Deprecated - Optional password to use for basic authentication\n Replaced by instantiating a proxy_strategy via aws_http_proxy_strategy_new_basic_auth()"]
    pub auth_password: aws_byte_cursor,
}
#[doc = " Vtable for forwarding-based proxy negotiators"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_http_proxy_negotiator_forwarding_vtable {
    pub forward_request_transform: aws_http_proxy_negotiation_http_request_transform_fn,
}
#[doc = " Vtable for tunneling-based proxy negotiators"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_http_proxy_negotiator_tunnelling_vtable {
    pub connect_request_transform: aws_http_proxy_negotiation_http_request_transform_async_fn,
    pub on_incoming_headers_callback: aws_http_proxy_negotiation_connect_on_incoming_headers_fn,
    pub on_status_callback: aws_http_proxy_negotiator_connect_status_fn,
    pub on_incoming_body_callback: aws_http_proxy_negotiator_connect_on_incoming_body_fn,
    pub get_retry_directive: aws_http_proxy_negotiator_get_retry_directive_fn,
}
#[repr(C)]
pub struct aws_http_proxy_negotiator {
    pub ref_count: aws_ref_count,
    pub impl_: *mut ::core::ffi::c_void,
    pub strategy_vtable: aws_http_proxy_negotiator__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_http_proxy_strategy_vtable {
    pub create_negotiator: aws_http_proxy_strategy_create_negotiator_fn,
}
#[repr(C)]
pub struct aws_http_proxy_strategy {
    pub ref_count: aws_ref_count,
    pub vtable: *mut aws_http_proxy_strategy_vtable,
    pub impl_: *mut ::core::ffi::c_void,
    pub proxy_connection_type: aws_http_proxy_connection_type,
}
#[repr(C)]
pub struct aws_http_proxy_strategy_basic_auth_options {
    pub proxy_connection_type: aws_http_proxy_connection_type,
    pub user_name: aws_byte_cursor,
    pub password: aws_byte_cursor,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_http_proxy_strategy_tunneling_kerberos_options {
    pub get_token: aws_http_proxy_negotiation_get_token_sync_fn,
    pub get_token_user_data: *mut ::core::ffi::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_http_proxy_strategy_tunneling_ntlm_options {
    pub get_token: aws_http_proxy_negotiation_get_token_sync_fn,
    pub get_challenge_token: aws_http_proxy_negotiation_get_challenge_token_sync_fn,
    pub get_challenge_token_user_data: *mut ::core::ffi::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_http_proxy_strategy_tunneling_adaptive_options {
    pub kerberos_options: *mut aws_http_proxy_strategy_tunneling_kerberos_options,
    pub ntlm_options: *mut aws_http_proxy_strategy_tunneling_ntlm_options,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_http_proxy_strategy_tunneling_sequence_options {
    pub strategies: *mut *mut aws_http_proxy_strategy,
    pub strategy_count: u32,
}
#[doc = " A listening socket which accepts incoming HTTP connections,\n creating a server-side aws_http_connection to handle each one."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_http_server {
    _unused: [u8; 0],
}
#[doc = " Options for creating an HTTP server.\n Initialize with AWS_HTTP_SERVER_OPTIONS_INIT to set default values."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_http_server_options {
    #[doc = " The sizeof() this struct, used for versioning.\n Set by AWS_HTTP_SERVER_OPTIONS_INIT."]
    pub self_size: usize,
    #[doc = " Required.\n Must outlive server."]
    pub allocator: *mut aws_allocator,
    #[doc = " Required.\n Must outlive server."]
    pub bootstrap: *mut aws_server_bootstrap,
    #[doc = " Required.\n Server makes copy."]
    pub endpoint: *mut aws_socket_endpoint,
    #[doc = " Required.\n Server makes a copy."]
    pub socket_options: *mut aws_socket_options,
    #[doc = " Optional.\n Server copies all contents except the `aws_tls_ctx`, which must outlive the server."]
    pub tls_options: *mut aws_tls_connection_options,
    #[doc = " Initial window size for incoming connections.\n Optional.\n A default size is set by AWS_HTTP_SERVER_OPTIONS_INIT."]
    pub initial_window_size: usize,
    #[doc = " User data passed to callbacks.\n Optional."]
    pub server_user_data: *mut ::core::ffi::c_void,
    #[doc = " Invoked when an incoming connection has been set up, or when setup has failed.\n Required.\n If setup succeeds, the user must call aws_http_connection_configure_server()."]
    pub on_incoming_connection: aws_http_server_on_incoming_connection_fn,
    #[doc = " Invoked when the server finishes the destroy operation.\n Optional."]
    pub on_destroy_complete: aws_http_server_on_destroy_fn,
    #[doc = " Set to true to manually manage the read window size.\n\n If this is false, the connection will maintain a constant window size.\n\n If this is true, the caller must manually increment the window size using aws_http_stream_update_window().\n If the window is not incremented, it will shrink by the amount of body data received. If the window size\n reaches 0, no further data will be received."]
    pub manual_window_management: bool,
}
#[doc = " Options for configuring a server-side aws_http_connection.\n Initialized with AWS_HTTP_SERVER_CONNECTION_OPTIONS_INIT to set default values."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_http_server_connection_options {
    #[doc = " The sizeof() this struct, used for versioning.\n Set by AWS_HTTP_SERVER_CONNECTION_OPTIONS_INIT."]
    pub self_size: usize,
    #[doc = " User data specific to this connection.\n Optional."]
    pub connection_user_data: *mut ::core::ffi::c_void,
    #[doc = " Invoked at the start of an incoming request.\n Required.\n The user must create a request handler stream and return it to the connection.\n See `aws_http_on_incoming_request_fn`."]
    pub on_incoming_request: aws_http_on_incoming_request_fn,
    #[doc = " Invoked when the connection is shut down.\n Optional."]
    pub on_shutdown: aws_http_on_server_connection_shutdown_fn,
}
#[doc = " A statistics struct for http handlers.  Tracks the actual amount of time that incoming and outgoing requests are\n waiting for their IO to complete."]
#[repr(C)]
pub struct aws_crt_statistics_http1_channel {
    pub category: aws_crt_statistics_category_t,
    pub pending_outgoing_stream_ms: u64,
    pub pending_incoming_stream_ms: u64,
    pub current_outgoing_stream_id: u32,
    pub current_incoming_stream_id: u32,
}
#[repr(C)]
pub struct aws_crt_statistics_http2_channel {
    pub category: aws_crt_statistics_category_t,
    pub pending_outgoing_stream_ms: u64,
    pub pending_incoming_stream_ms: u64,
    pub was_inactive: bool,
}
#[doc = " A websocket connection."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_websocket {
    _unused: [u8; 0],
}
#[doc = " Data passed to the websocket on_connection_setup callback.\n\n An error_code of zero indicates that setup was completely successful.\n You own the websocket pointer now and must call aws_websocket_release() when you are done with it.\n You can inspect the response headers, if you're interested.\n\n A non-zero error_code indicates that setup failed.\n The websocket pointer will be NULL.\n If the server sent a response, you can inspect its status-code, headers, and body,\n but this data will NULL if setup failed before a full response could be received.\n If you wish to persist data from the response make a deep copy.\n The response data becomes invalid once the callback completes."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_websocket_on_connection_setup_data {
    pub error_code: ::core::ffi::c_int,
    pub websocket: *mut aws_websocket,
    pub handshake_response_status: *const ::core::ffi::c_int,
    pub handshake_response_header_array: *const aws_http_header,
    pub num_handshake_response_headers: usize,
    pub handshake_response_body: *const aws_byte_cursor,
}
#[doc = " Data about an incoming frame.\n See RFC-6455 Section 5.2."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_websocket_incoming_frame {
    pub payload_length: u64,
    pub opcode: u8,
    pub fin: bool,
}
#[doc = " Options for creating a websocket client connection."]
#[repr(C)]
pub struct aws_websocket_client_connection_options {
    #[doc = " Required.\n Must outlive the connection."]
    pub allocator: *mut aws_allocator,
    #[doc = " Required.\n The connection keeps the bootstrap alive via ref-counting."]
    pub bootstrap: *mut aws_client_bootstrap,
    #[doc = " Required.\n aws_websocket_client_connect() makes a copy."]
    pub socket_options: *const aws_socket_options,
    #[doc = " Optional.\n aws_websocket_client_connect() deep-copies all contents,\n and keeps the `aws_tls_ctx` alive via ref-counting."]
    pub tls_options: *const aws_tls_connection_options,
    #[doc = " Optional\n Configuration options related to http proxy usage."]
    pub proxy_options: *const aws_http_proxy_options,
    #[doc = " Required.\n aws_websocket_client_connect() makes a copy."]
    pub host: aws_byte_cursor,
    #[doc = " Optional.\n Defaults to 443 if tls_options is present, 80 if it is not."]
    pub port: u32,
    #[doc = " Required.\n The request will be kept alive via ref-counting until the handshake completes.\n Suggestion: create via aws_http_message_new_websocket_handshake_request()\n\n The method MUST be set to GET.\n The following headers are required (replace values in []):\n\n Host: [server.example.com]\n Upgrade: websocket\n Connection: Upgrade\n Sec-WebSocket-Key: [dGhlIHNhbXBsZSBub25jZQ==]\n Sec-WebSocket-Version: 13\n\n Sec-Websocket-Key should be a random 16 bytes value, Base64 encoded."]
    pub handshake_request: *mut aws_http_message,
    #[doc = " Initial size of the websocket's read window.\n Ignored unless `manual_window_management` is true.\n Set to 0 to prevent any incoming websocket frames until aws_websocket_increment_read_window() is called."]
    pub initial_window_size: usize,
    #[doc = " User data for callbacks.\n Optional."]
    pub user_data: *mut ::core::ffi::c_void,
    #[doc = " Called when connect completes.\n Required.\n If unsuccessful, error_code will be set, connection will be NULL,\n and the on_connection_shutdown callback will never be called.\n If successful, the user is now responsible for the websocket and must\n call aws_websocket_release() when they are done with it."]
    pub on_connection_setup: aws_websocket_on_connection_setup_fn,
    #[doc = " Called when connection has finished shutting down.\n Optional.\n Never called if `on_connection_setup` reported failure.\n Note that the connection is not completely done until `on_connection_shutdown` has been called\n AND aws_websocket_release() has been called."]
    pub on_connection_shutdown: aws_websocket_on_connection_shutdown_fn,
    #[doc = " Called when each new frame arrives.\n Optional.\n See `aws_websocket_on_incoming_frame_begin_fn`."]
    pub on_incoming_frame_begin: aws_websocket_on_incoming_frame_begin_fn,
    #[doc = " Called repeatedly as payload data arrives.\n Optional.\n See `aws_websocket_on_incoming_frame_payload_fn`."]
    pub on_incoming_frame_payload: aws_websocket_on_incoming_frame_payload_fn,
    #[doc = " Called when done processing an incoming frame.\n Optional.\n See `aws_websocket_on_incoming_frame_complete_fn`."]
    pub on_incoming_frame_complete: aws_websocket_on_incoming_frame_complete_fn,
    #[doc = " Set to true to manually manage the read window size.\n\n If this is false, no backpressure is applied and frames will arrive as fast as possible.\n\n If this is true, then whenever the read window reaches 0 you will stop receiving anything.\n The websocket's `initial_window_size` determines the starting size of the read window.\n The read window shrinks as you receive the payload from \"data\" frames (TEXT, BINARY, and CONTINUATION).\n Use aws_websocket_increment_read_window() to increment the window again and keep frames flowing.\n Maintain a larger window to keep up high throughput.\n You only need to worry about the payload from \"data\" frames.\n The websocket automatically increments the window to account for any\n other incoming bytes, including other parts of a frame (opcode, payload-length, etc)\n and the payload of other frame types (PING, PONG, CLOSE)."]
    pub manual_window_management: bool,
    #[doc = " Optional\n If set, requests that a specific event loop be used to seat the connection, rather than the next one\n in the event loop group.  Useful for serializing all io and external events related to a client onto\n a single thread."]
    pub requested_event_loop: *mut aws_event_loop,
    #[doc = " Optional\n Host resolution override that allows the user to override DNS behavior for this particular connection."]
    pub host_resolution_config: *const aws_host_resolution_config,
}
#[doc = " Options for sending a websocket frame.\n This structure is copied immediately by aws_websocket_send().\n For descriptions of opcode, fin, and payload_length see in RFC-6455 Section 5.2."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_websocket_send_frame_options {
    #[doc = " Size of payload to be sent via `stream_outgoing_payload` callback."]
    pub payload_length: u64,
    #[doc = " User data passed to callbacks."]
    pub user_data: *mut ::core::ffi::c_void,
    #[doc = " Callback for sending payload data.\n See `aws_websocket_stream_outgoing_payload_fn`.\n Required if `payload_length` is non-zero."]
    pub stream_outgoing_payload: aws_websocket_stream_outgoing_payload_fn,
    #[doc = " Callback for completion of send operation.\n See `aws_websocket_outgoing_frame_complete_fn`.\n Optional."]
    pub on_complete: aws_websocket_outgoing_frame_complete_fn,
    #[doc = " Frame type.\n `aws_websocket_opcode` enum provides standard values."]
    pub opcode: u8,
    #[doc = " Indicates that this is the final fragment in a message. The first fragment MAY also be the final fragment."]
    pub fin: bool,
}
pub const AWS_C_HTTP_PACKAGE_ID: u32 = 2;
pub const AWS_HTTP2_DEFAULT_MAX_CLOSED_STREAMS: u32 = 32;
pub const AWS_HTTP2_PING_DATA_SIZE: u32 = 8;
pub const AWS_HTTP2_SETTINGS_COUNT: u32 = 6;
pub const AWS_WEBSOCKET_MAX_PAYLOAD_LENGTH: u64 = 9223372036854775807;
pub const AWS_WEBSOCKET_MAX_HANDSHAKE_KEY_LENGTH: u32 = 25;
pub const AWS_WEBSOCKET_CLOSE_TIMEOUT: u32 = 1000000000;
pub const AWS_ERROR_HTTP_UNKNOWN: aws_http_errors = 2048;
pub const AWS_ERROR_HTTP_HEADER_NOT_FOUND: aws_http_errors = 2049;
pub const AWS_ERROR_HTTP_INVALID_HEADER_FIELD: aws_http_errors = 2050;
pub const AWS_ERROR_HTTP_INVALID_HEADER_NAME: aws_http_errors = 2051;
pub const AWS_ERROR_HTTP_INVALID_HEADER_VALUE: aws_http_errors = 2052;
pub const AWS_ERROR_HTTP_INVALID_METHOD: aws_http_errors = 2053;
pub const AWS_ERROR_HTTP_INVALID_PATH: aws_http_errors = 2054;
pub const AWS_ERROR_HTTP_INVALID_STATUS_CODE: aws_http_errors = 2055;
pub const AWS_ERROR_HTTP_MISSING_BODY_STREAM: aws_http_errors = 2056;
pub const AWS_ERROR_HTTP_INVALID_BODY_STREAM: aws_http_errors = 2057;
pub const AWS_ERROR_HTTP_CONNECTION_CLOSED: aws_http_errors = 2058;
pub const AWS_ERROR_HTTP_SWITCHED_PROTOCOLS: aws_http_errors = 2059;
pub const AWS_ERROR_HTTP_UNSUPPORTED_PROTOCOL: aws_http_errors = 2060;
pub const AWS_ERROR_HTTP_REACTION_REQUIRED: aws_http_errors = 2061;
pub const AWS_ERROR_HTTP_DATA_NOT_AVAILABLE: aws_http_errors = 2062;
pub const AWS_ERROR_HTTP_OUTGOING_STREAM_LENGTH_INCORRECT: aws_http_errors = 2063;
pub const AWS_ERROR_HTTP_CALLBACK_FAILURE: aws_http_errors = 2064;
pub const AWS_ERROR_HTTP_WEBSOCKET_UPGRADE_FAILURE: aws_http_errors = 2065;
pub const AWS_ERROR_HTTP_WEBSOCKET_CLOSE_FRAME_SENT: aws_http_errors = 2066;
pub const AWS_ERROR_HTTP_WEBSOCKET_IS_MIDCHANNEL_HANDLER: aws_http_errors = 2067;
pub const AWS_ERROR_HTTP_CONNECTION_MANAGER_INVALID_STATE_FOR_ACQUIRE: aws_http_errors = 2068;
pub const AWS_ERROR_HTTP_CONNECTION_MANAGER_VENDED_CONNECTION_UNDERFLOW: aws_http_errors = 2069;
pub const AWS_ERROR_HTTP_SERVER_CLOSED: aws_http_errors = 2070;
pub const AWS_ERROR_HTTP_PROXY_CONNECT_FAILED: aws_http_errors = 2071;
pub const AWS_ERROR_HTTP_CONNECTION_MANAGER_SHUTTING_DOWN: aws_http_errors = 2072;
pub const AWS_ERROR_HTTP_CHANNEL_THROUGHPUT_FAILURE: aws_http_errors = 2073;
pub const AWS_ERROR_HTTP_PROTOCOL_ERROR: aws_http_errors = 2074;
pub const AWS_ERROR_HTTP_STREAM_IDS_EXHAUSTED: aws_http_errors = 2075;
pub const AWS_ERROR_HTTP_GOAWAY_RECEIVED: aws_http_errors = 2076;
pub const AWS_ERROR_HTTP_RST_STREAM_RECEIVED: aws_http_errors = 2077;
pub const AWS_ERROR_HTTP_RST_STREAM_SENT: aws_http_errors = 2078;
pub const AWS_ERROR_HTTP_STREAM_NOT_ACTIVATED: aws_http_errors = 2079;
pub const AWS_ERROR_HTTP_STREAM_HAS_COMPLETED: aws_http_errors = 2080;
pub const AWS_ERROR_HTTP_PROXY_STRATEGY_NTLM_CHALLENGE_TOKEN_MISSING: aws_http_errors = 2081;
pub const AWS_ERROR_HTTP_PROXY_STRATEGY_TOKEN_RETRIEVAL_FAILURE: aws_http_errors = 2082;
pub const AWS_ERROR_HTTP_PROXY_CONNECT_FAILED_RETRYABLE: aws_http_errors = 2083;
pub const AWS_ERROR_HTTP_PROTOCOL_SWITCH_FAILURE: aws_http_errors = 2084;
pub const AWS_ERROR_HTTP_MAX_CONCURRENT_STREAMS_EXCEEDED: aws_http_errors = 2085;
pub const AWS_ERROR_HTTP_STREAM_MANAGER_SHUTTING_DOWN: aws_http_errors = 2086;
pub const AWS_ERROR_HTTP_STREAM_MANAGER_CONNECTION_ACQUIRE_FAILURE: aws_http_errors = 2087;
pub const AWS_ERROR_HTTP_STREAM_MANAGER_UNEXPECTED_HTTP_VERSION: aws_http_errors = 2088;
pub const AWS_ERROR_HTTP_WEBSOCKET_PROTOCOL_ERROR: aws_http_errors = 2089;
pub const AWS_ERROR_HTTP_MANUAL_WRITE_NOT_ENABLED: aws_http_errors = 2090;
pub const AWS_ERROR_HTTP_MANUAL_WRITE_HAS_COMPLETED: aws_http_errors = 2091;
pub const AWS_ERROR_HTTP_RESPONSE_FIRST_BYTE_TIMEOUT: aws_http_errors = 2092;
pub const AWS_ERROR_HTTP_END_RANGE: aws_http_errors = 3071;
pub const AWS_HTTP2_ERR_NO_ERROR: aws_http2_error_code = 0;
pub const AWS_HTTP2_ERR_PROTOCOL_ERROR: aws_http2_error_code = 1;
pub const AWS_HTTP2_ERR_INTERNAL_ERROR: aws_http2_error_code = 2;
pub const AWS_HTTP2_ERR_FLOW_CONTROL_ERROR: aws_http2_error_code = 3;
pub const AWS_HTTP2_ERR_SETTINGS_TIMEOUT: aws_http2_error_code = 4;
pub const AWS_HTTP2_ERR_STREAM_CLOSED: aws_http2_error_code = 5;
pub const AWS_HTTP2_ERR_FRAME_SIZE_ERROR: aws_http2_error_code = 6;
pub const AWS_HTTP2_ERR_REFUSED_STREAM: aws_http2_error_code = 7;
pub const AWS_HTTP2_ERR_CANCEL: aws_http2_error_code = 8;
pub const AWS_HTTP2_ERR_COMPRESSION_ERROR: aws_http2_error_code = 9;
pub const AWS_HTTP2_ERR_CONNECT_ERROR: aws_http2_error_code = 10;
pub const AWS_HTTP2_ERR_ENHANCE_YOUR_CALM: aws_http2_error_code = 11;
pub const AWS_HTTP2_ERR_INADEQUATE_SECURITY: aws_http2_error_code = 12;
pub const AWS_HTTP2_ERR_HTTP_1_1_REQUIRED: aws_http2_error_code = 13;
pub const AWS_HTTP2_ERR_COUNT: aws_http2_error_code = 14;
pub const AWS_LS_HTTP_GENERAL: aws_http_log_subject = 2048;
pub const AWS_LS_HTTP_CONNECTION: aws_http_log_subject = 2049;
pub const AWS_LS_HTTP_ENCODER: aws_http_log_subject = 2050;
pub const AWS_LS_HTTP_DECODER: aws_http_log_subject = 2051;
pub const AWS_LS_HTTP_SERVER: aws_http_log_subject = 2052;
pub const AWS_LS_HTTP_STREAM: aws_http_log_subject = 2053;
pub const AWS_LS_HTTP_CONNECTION_MANAGER: aws_http_log_subject = 2054;
pub const AWS_LS_HTTP_STREAM_MANAGER: aws_http_log_subject = 2055;
pub const AWS_LS_HTTP_WEBSOCKET: aws_http_log_subject = 2056;
pub const AWS_LS_HTTP_WEBSOCKET_SETUP: aws_http_log_subject = 2057;
pub const AWS_LS_HTTP_PROXY_NEGOTIATION: aws_http_log_subject = 2058;
pub const AWS_HTTP_VERSION_UNKNOWN: aws_http_version = 0;
pub const AWS_HTTP_VERSION_1_0: aws_http_version = 1;
pub const AWS_HTTP_VERSION_1_1: aws_http_version = 2;
pub const AWS_HTTP_VERSION_2: aws_http_version = 3;
pub const AWS_HTTP_VERSION_COUNT: aws_http_version = 4;
pub const AWS_HTTP2_SETTINGS_BEGIN_RANGE: aws_http2_settings_id = 1;
pub const AWS_HTTP2_SETTINGS_HEADER_TABLE_SIZE: aws_http2_settings_id = 1;
pub const AWS_HTTP2_SETTINGS_ENABLE_PUSH: aws_http2_settings_id = 2;
pub const AWS_HTTP2_SETTINGS_MAX_CONCURRENT_STREAMS: aws_http2_settings_id = 3;
pub const AWS_HTTP2_SETTINGS_INITIAL_WINDOW_SIZE: aws_http2_settings_id = 4;
pub const AWS_HTTP2_SETTINGS_MAX_FRAME_SIZE: aws_http2_settings_id = 5;
pub const AWS_HTTP2_SETTINGS_MAX_HEADER_LIST_SIZE: aws_http2_settings_id = 6;
pub const AWS_HTTP2_SETTINGS_END_RANGE: aws_http2_settings_id = 7;
#[doc = " Compress header by encoding the cached index of its strings,\n or by updating the cache to contain these strings for future reference.\n Best for headers that are sent repeatedly.\n This is the default setting."]
pub const AWS_HTTP_HEADER_COMPRESSION_USE_CACHE: aws_http_header_compression = 0;
#[doc = " Encode header strings literally.\n If an intermediary re-broadcasts the headers, it is permitted to use cache.\n Best for unique headers that are unlikely to repeat."]
pub const AWS_HTTP_HEADER_COMPRESSION_NO_CACHE: aws_http_header_compression = 1;
#[doc = " Encode header strings literally and forbid all intermediaries from using\n cache when re-broadcasting.\n Best for header fields that are highly valuable or sensitive to recovery."]
pub const AWS_HTTP_HEADER_COMPRESSION_NO_FORWARD_CACHE: aws_http_header_compression = 2;
pub const AWS_HTTP_HEADER_BLOCK_MAIN: aws_http_header_block = 0;
pub const AWS_HTTP_HEADER_BLOCK_INFORMATIONAL: aws_http_header_block = 1;
pub const AWS_HTTP_HEADER_BLOCK_TRAILING: aws_http_header_block = 2;
pub const AWS_HTTP_STATUS_CODE_UNKNOWN: aws_http_status_code = -1;
pub const AWS_HTTP_STATUS_CODE_100_CONTINUE: aws_http_status_code = 100;
pub const AWS_HTTP_STATUS_CODE_101_SWITCHING_PROTOCOLS: aws_http_status_code = 101;
pub const AWS_HTTP_STATUS_CODE_102_PROCESSING: aws_http_status_code = 102;
pub const AWS_HTTP_STATUS_CODE_103_EARLY_HINTS: aws_http_status_code = 103;
pub const AWS_HTTP_STATUS_CODE_200_OK: aws_http_status_code = 200;
pub const AWS_HTTP_STATUS_CODE_201_CREATED: aws_http_status_code = 201;
pub const AWS_HTTP_STATUS_CODE_202_ACCEPTED: aws_http_status_code = 202;
pub const AWS_HTTP_STATUS_CODE_203_NON_AUTHORITATIVE_INFORMATION: aws_http_status_code = 203;
pub const AWS_HTTP_STATUS_CODE_204_NO_CONTENT: aws_http_status_code = 204;
pub const AWS_HTTP_STATUS_CODE_205_RESET_CONTENT: aws_http_status_code = 205;
pub const AWS_HTTP_STATUS_CODE_206_PARTIAL_CONTENT: aws_http_status_code = 206;
pub const AWS_HTTP_STATUS_CODE_207_MULTI_STATUS: aws_http_status_code = 207;
pub const AWS_HTTP_STATUS_CODE_208_ALREADY_REPORTED: aws_http_status_code = 208;
pub const AWS_HTTP_STATUS_CODE_226_IM_USED: aws_http_status_code = 226;
pub const AWS_HTTP_STATUS_CODE_300_MULTIPLE_CHOICES: aws_http_status_code = 300;
pub const AWS_HTTP_STATUS_CODE_301_MOVED_PERMANENTLY: aws_http_status_code = 301;
pub const AWS_HTTP_STATUS_CODE_302_FOUND: aws_http_status_code = 302;
pub const AWS_HTTP_STATUS_CODE_303_SEE_OTHER: aws_http_status_code = 303;
pub const AWS_HTTP_STATUS_CODE_304_NOT_MODIFIED: aws_http_status_code = 304;
pub const AWS_HTTP_STATUS_CODE_305_USE_PROXY: aws_http_status_code = 305;
pub const AWS_HTTP_STATUS_CODE_307_TEMPORARY_REDIRECT: aws_http_status_code = 307;
pub const AWS_HTTP_STATUS_CODE_308_PERMANENT_REDIRECT: aws_http_status_code = 308;
pub const AWS_HTTP_STATUS_CODE_400_BAD_REQUEST: aws_http_status_code = 400;
pub const AWS_HTTP_STATUS_CODE_401_UNAUTHORIZED: aws_http_status_code = 401;
pub const AWS_HTTP_STATUS_CODE_402_PAYMENT_REQUIRED: aws_http_status_code = 402;
pub const AWS_HTTP_STATUS_CODE_403_FORBIDDEN: aws_http_status_code = 403;
pub const AWS_HTTP_STATUS_CODE_404_NOT_FOUND: aws_http_status_code = 404;
pub const AWS_HTTP_STATUS_CODE_405_METHOD_NOT_ALLOWED: aws_http_status_code = 405;
pub const AWS_HTTP_STATUS_CODE_406_NOT_ACCEPTABLE: aws_http_status_code = 406;
pub const AWS_HTTP_STATUS_CODE_407_PROXY_AUTHENTICATION_REQUIRED: aws_http_status_code = 407;
pub const AWS_HTTP_STATUS_CODE_408_REQUEST_TIMEOUT: aws_http_status_code = 408;
pub const AWS_HTTP_STATUS_CODE_409_CONFLICT: aws_http_status_code = 409;
pub const AWS_HTTP_STATUS_CODE_410_GONE: aws_http_status_code = 410;
pub const AWS_HTTP_STATUS_CODE_411_LENGTH_REQUIRED: aws_http_status_code = 411;
pub const AWS_HTTP_STATUS_CODE_412_PRECONDITION_FAILED: aws_http_status_code = 412;
pub const AWS_HTTP_STATUS_CODE_413_REQUEST_ENTITY_TOO_LARGE: aws_http_status_code = 413;
pub const AWS_HTTP_STATUS_CODE_414_REQUEST_URI_TOO_LONG: aws_http_status_code = 414;
pub const AWS_HTTP_STATUS_CODE_415_UNSUPPORTED_MEDIA_TYPE: aws_http_status_code = 415;
pub const AWS_HTTP_STATUS_CODE_416_REQUESTED_RANGE_NOT_SATISFIABLE: aws_http_status_code = 416;
pub const AWS_HTTP_STATUS_CODE_417_EXPECTATION_FAILED: aws_http_status_code = 417;
pub const AWS_HTTP_STATUS_CODE_421_MISDIRECTED_REQUEST: aws_http_status_code = 421;
pub const AWS_HTTP_STATUS_CODE_422_UNPROCESSABLE_ENTITY: aws_http_status_code = 422;
pub const AWS_HTTP_STATUS_CODE_423_LOCKED: aws_http_status_code = 423;
pub const AWS_HTTP_STATUS_CODE_424_FAILED_DEPENDENCY: aws_http_status_code = 424;
pub const AWS_HTTP_STATUS_CODE_425_TOO_EARLY: aws_http_status_code = 425;
pub const AWS_HTTP_STATUS_CODE_426_UPGRADE_REQUIRED: aws_http_status_code = 426;
pub const AWS_HTTP_STATUS_CODE_428_PRECONDITION_REQUIRED: aws_http_status_code = 428;
pub const AWS_HTTP_STATUS_CODE_429_TOO_MANY_REQUESTS: aws_http_status_code = 429;
pub const AWS_HTTP_STATUS_CODE_431_REQUEST_HEADER_FIELDS_TOO_LARGE: aws_http_status_code = 431;
pub const AWS_HTTP_STATUS_CODE_451_UNAVAILABLE_FOR_LEGAL_REASON: aws_http_status_code = 451;
pub const AWS_HTTP_STATUS_CODE_500_INTERNAL_SERVER_ERROR: aws_http_status_code = 500;
pub const AWS_HTTP_STATUS_CODE_501_NOT_IMPLEMENTED: aws_http_status_code = 501;
pub const AWS_HTTP_STATUS_CODE_502_BAD_GATEWAY: aws_http_status_code = 502;
pub const AWS_HTTP_STATUS_CODE_503_SERVICE_UNAVAILABLE: aws_http_status_code = 503;
pub const AWS_HTTP_STATUS_CODE_504_GATEWAY_TIMEOUT: aws_http_status_code = 504;
pub const AWS_HTTP_STATUS_CODE_505_HTTP_VERSION_NOT_SUPPORTED: aws_http_status_code = 505;
pub const AWS_HTTP_STATUS_CODE_506_VARIANT_ALSO_NEGOTIATES: aws_http_status_code = 506;
pub const AWS_HTTP_STATUS_CODE_507_INSUFFICIENT_STORAGE: aws_http_status_code = 507;
pub const AWS_HTTP_STATUS_CODE_508_LOOP_DETECTED: aws_http_status_code = 508;
pub const AWS_HTTP_STATUS_CODE_510_NOT_EXTENDED: aws_http_status_code = 510;
pub const AWS_HTTP_STATUS_CODE_511_NETWORK_AUTHENTICATION_REQUIRED: aws_http_status_code = 511;
pub const AWS_HPAT_NONE: aws_http_proxy_authentication_type = 0;
pub const AWS_HPAT_BASIC: aws_http_proxy_authentication_type = 1;
#[doc = " Default.\n Disable reading from environment variable for proxy."]
pub const AWS_HPEV_DISABLE: aws_http_proxy_env_var_type = 0;
#[doc = " Enable get proxy URL from environment variable, when the manual proxy options of connection manager is not set.\n env HTTPS_PROXY/https_proxy will be checked when the main connection use tls.\n env HTTP_PROXY/http_proxy will be checked when the main connection NOT use tls.\n The lower case version has precedence."]
pub const AWS_HPEV_ENABLE: aws_http_proxy_env_var_type = 1;
#[doc = " Deprecated, but 0-valued for backwards compatibility\n\n If tls options are provided (for the main connection) then treat the proxy as a tunneling proxy\n If tls options are not provided (for the main connection), then treat the proxy as a forwarding proxy"]
pub const AWS_HPCT_HTTP_LEGACY: aws_http_proxy_connection_type = 0;
#[doc = " Use the proxy to forward http requests.  Attempting to use both this mode and TLS on the tunnel destination\n is a configuration error."]
pub const AWS_HPCT_HTTP_FORWARD: aws_http_proxy_connection_type = 1;
#[doc = " Use the proxy to establish a connection to a remote endpoint via a CONNECT request through the proxy.\n Works for both plaintext and tls connections."]
pub const AWS_HPCT_HTTP_TUNNEL: aws_http_proxy_connection_type = 2;
pub const AWS_HPNRD_STOP: aws_http_proxy_negotiation_retry_directive = 0;
pub const AWS_HPNRD_NEW_CONNECTION: aws_http_proxy_negotiation_retry_directive = 1;
pub const AWS_HPNRD_CURRENT_CONNECTION: aws_http_proxy_negotiation_retry_directive = 2;
pub const AWSCRT_STAT_CAT_HTTP1_CHANNEL: aws_crt_http_statistics_category = 512;
pub const AWSCRT_STAT_CAT_HTTP2_CHANNEL: aws_crt_http_statistics_category = 513;
pub const AWS_WEBSOCKET_OPCODE_CONTINUATION: aws_websocket_opcode = 0;
pub const AWS_WEBSOCKET_OPCODE_TEXT: aws_websocket_opcode = 1;
pub const AWS_WEBSOCKET_OPCODE_BINARY: aws_websocket_opcode = 2;
pub const AWS_WEBSOCKET_OPCODE_CLOSE: aws_websocket_opcode = 8;
pub const AWS_WEBSOCKET_OPCODE_PING: aws_websocket_opcode = 9;
pub const AWS_WEBSOCKET_OPCODE_PONG: aws_websocket_opcode = 10;
#[repr(C)]
#[derive(Copy, Clone)]
pub union aws_http_proxy_negotiator__bindgen_ty_1 {
    pub forwarding_vtable: *mut aws_http_proxy_negotiator_forwarding_vtable,
    pub tunnelling_vtable: *mut aws_http_proxy_negotiator_tunnelling_vtable,
}
extern "C" {
    #[doc = " Initializes internal datastructures used by aws-c-http.\n Must be called before using any functionality in aws-c-http."]
    pub fn aws_http_library_init(alloc: *mut aws_allocator);
    #[doc = " Clean up internal datastructures used by aws-c-http.\n Must not be called until application is done using functionality in aws-c-http."]
    pub fn aws_http_library_clean_up();
    #[doc = " Returns the description of common status codes.\n Ex: 404 -> \"Not Found\"\n An empty string is returned if the status code is not recognized."]
    pub fn aws_http_status_text(status_code: ::core::ffi::c_int) -> *const ::core::ffi::c_char;
    #[doc = " Shortcuts for common HTTP request methods"]
    pub static aws_http_method_get: aws_byte_cursor;
    pub static aws_http_method_head: aws_byte_cursor;
    pub static aws_http_method_post: aws_byte_cursor;
    pub static aws_http_method_put: aws_byte_cursor;
    pub static aws_http_method_delete: aws_byte_cursor;
    pub static aws_http_method_connect: aws_byte_cursor;
    pub static aws_http_method_options: aws_byte_cursor;
    pub static aws_http_header_method: aws_byte_cursor;
    pub static aws_http_header_scheme: aws_byte_cursor;
    pub static aws_http_header_authority: aws_byte_cursor;
    pub static aws_http_header_path: aws_byte_cursor;
    pub static aws_http_header_status: aws_byte_cursor;
    pub static aws_http_scheme_http: aws_byte_cursor;
    pub static aws_http_scheme_https: aws_byte_cursor;
    #[doc = " Asynchronously establish a client connection.\n The on_setup callback is invoked when the operation has created a connection or failed."]
    pub fn aws_http_client_connect(
        options: *const aws_http_client_connection_options,
    ) -> ::core::ffi::c_int;
    #[doc = " Users must release the connection when they are done with it.\n The connection's memory cannot be reclaimed until this is done.\n If the connection was not already shutting down, it will be shut down.\n\n Users should always wait for the on_shutdown() callback to be called before releasing any data passed to the\n http_connection (Eg aws_tls_connection_options, aws_socket_options) otherwise there will be race conditions between\n http_connection shutdown tasks and memory release tasks, causing Segfaults."]
    pub fn aws_http_connection_release(connection: *mut aws_http_connection);
    #[doc = " Begin shutdown sequence of the connection if it hasn't already started. This will schedule shutdown tasks on the\n EventLoop that may send HTTP/TLS/TCP shutdown messages to peers if necessary, and will eventually cause internal\n connection memory to stop being accessed and on_shutdown() callback to be called.\n\n It's safe to call this function regardless of the connection state as long as you hold a reference to the connection."]
    pub fn aws_http_connection_close(connection: *mut aws_http_connection);
    #[doc = " Stop accepting new requests for the connection. It will NOT start the shutdown process for the connection. The\n requests that are already open can still wait to be completed, but new requests will fail to be created,"]
    pub fn aws_http_connection_stop_new_requests(connection: *mut aws_http_connection);
    #[doc = " Returns true unless the connection is closed or closing."]
    pub fn aws_http_connection_is_open(connection: *const aws_http_connection) -> bool;
    #[doc = " Return whether the connection can make a new requests.\n If false, then a new connection must be established to make further requests."]
    pub fn aws_http_connection_new_requests_allowed(connection: *const aws_http_connection)
        -> bool;
    #[doc = " Returns true if this is a client connection."]
    pub fn aws_http_connection_is_client(connection: *const aws_http_connection) -> bool;
    pub fn aws_http_connection_get_version(
        connection: *const aws_http_connection,
    ) -> aws_http_version;
    #[doc = " Returns the channel hosting the HTTP connection.\n Do not expose this function to language bindings."]
    pub fn aws_http_connection_get_channel(
        connection: *mut aws_http_connection,
    ) -> *mut aws_channel;
    #[doc = " Returns the remote endpoint of the HTTP connection."]
    pub fn aws_http_connection_get_remote_endpoint(
        connection: *const aws_http_connection,
    ) -> *const aws_socket_endpoint;
    #[doc = " Initialize an map copied from the *src map, which maps `struct aws_string *` to `enum aws_http_version`."]
    pub fn aws_http_alpn_map_init_copy(
        allocator: *mut aws_allocator,
        dest: *mut aws_hash_table,
        src: *mut aws_hash_table,
    ) -> ::core::ffi::c_int;
    #[doc = " Initialize an empty hash-table that maps `struct aws_string *` to `enum aws_http_version`.\n This map can used in aws_http_client_connections_options.alpn_string_map."]
    pub fn aws_http_alpn_map_init(
        allocator: *mut aws_allocator,
        map: *mut aws_hash_table,
    ) -> ::core::ffi::c_int;
    #[doc = " Checks http proxy options for correctness"]
    pub fn aws_http_options_validate_proxy_configuration(
        options: *const aws_http_client_connection_options,
    ) -> ::core::ffi::c_int;
    #[doc = " Send a SETTINGS frame (HTTP/2 only).\n SETTINGS will be applied locally when SETTINGS ACK is received from peer.\n\n @param http2_connection HTTP/2 connection.\n @param settings_array The array of settings to change. Note: each setting has its boundary.\n @param num_settings The num of settings to change in settings_array.\n @param on_completed Optional callback, see `aws_http2_on_change_settings_complete_fn`.\n @param user_data User-data pass to on_completed callback."]
    pub fn aws_http2_connection_change_settings(
        http2_connection: *mut aws_http_connection,
        settings_array: *const aws_http2_setting,
        num_settings: usize,
        on_completed: aws_http2_on_change_settings_complete_fn,
        user_data: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    #[doc = " Send a PING frame (HTTP/2 only).\n Round-trip-time is calculated when PING ACK is received from peer.\n\n @param http2_connection HTTP/2 connection.\n @param optional_opaque_data Optional payload for PING frame.\n      Must be NULL, or exactly 8 bytes (AWS_HTTP2_PING_DATA_SIZE).\n      If NULL, the 8 byte payload will be all zeroes.\n @param on_completed Optional callback, invoked when PING ACK is received from peer,\n      or when a connection error prevents the PING ACK from being received.\n      Callback always fires on the connection's event-loop thread.\n @param user_data User-data pass to on_completed callback."]
    pub fn aws_http2_connection_ping(
        http2_connection: *mut aws_http_connection,
        optional_opaque_data: *const aws_byte_cursor,
        on_completed: aws_http2_on_ping_complete_fn,
        user_data: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    #[doc = " Get the local settings we are using to affect the decoding.\n\n @param http2_connection HTTP/2 connection.\n @param out_settings fixed size array of aws_http2_setting gets set to the local settings"]
    pub fn aws_http2_connection_get_local_settings(
        http2_connection: *const aws_http_connection,
        out_settings: *mut [aws_http2_setting; 6usize],
    );
    #[doc = " Get the settings received from remote peer, which we are using to restricts the message to send.\n\n @param http2_connection HTTP/2 connection.\n @param out_settings fixed size array of aws_http2_setting gets set to the remote settings"]
    pub fn aws_http2_connection_get_remote_settings(
        http2_connection: *const aws_http_connection,
        out_settings: *mut [aws_http2_setting; 6usize],
    );
    #[doc = " Send a custom GOAWAY frame (HTTP/2 only).\n\n Note that the connection automatically attempts to send a GOAWAY during\n shutdown (unless a GOAWAY with a valid Last-Stream-ID has already been sent).\n\n This call can be used to gracefully warn the peer of an impending shutdown\n (http2_error=0, allow_more_streams=true), or to customize the final GOAWAY\n frame that is sent by this connection.\n\n The other end may not receive the goaway, if the connection already closed.\n\n @param http2_connection HTTP/2 connection.\n @param http2_error The HTTP/2 error code (RFC-7540 section 7) to send.\n      `enum aws_http2_error_code` lists official codes.\n @param allow_more_streams If true, new peer-initiated streams will continue\n      to be acknowledged and the GOAWAY's Last-Stream-ID will be set to a max value.\n      If false, new peer-initiated streams will be ignored and the GOAWAY's\n      Last-Stream-ID will be set to the latest acknowledged stream.\n @param optional_debug_data Optional debug data to send. Size must not exceed 16KB."]
    pub fn aws_http2_connection_send_goaway(
        http2_connection: *mut aws_http_connection,
        http2_error: u32,
        allow_more_streams: bool,
        optional_debug_data: *const aws_byte_cursor,
    );
    #[doc = " Get data about the latest GOAWAY frame sent to peer (HTTP/2 only).\n If no GOAWAY has been sent, AWS_ERROR_HTTP_DATA_NOT_AVAILABLE will be raised.\n Note that GOAWAY frames are typically sent automatically by the connection\n during shutdown.\n\n @param http2_connection HTTP/2 connection.\n @param out_http2_error Gets set to HTTP/2 error code sent in most recent GOAWAY.\n @param out_last_stream_id Gets set to Last-Stream-ID sent in most recent GOAWAY."]
    pub fn aws_http2_connection_get_sent_goaway(
        http2_connection: *mut aws_http_connection,
        out_http2_error: *mut u32,
        out_last_stream_id: *mut u32,
    ) -> ::core::ffi::c_int;
    #[doc = " Get data about the latest GOAWAY frame received from peer (HTTP/2 only).\n If no GOAWAY has been received, or the GOAWAY payload is still in transmitting,\n AWS_ERROR_HTTP_DATA_NOT_AVAILABLE will be raised.\n\n @param http2_connection HTTP/2 connection.\n @param out_http2_error Gets set to HTTP/2 error code received in most recent GOAWAY.\n @param out_last_stream_id Gets set to Last-Stream-ID received in most recent GOAWAY."]
    pub fn aws_http2_connection_get_received_goaway(
        http2_connection: *mut aws_http_connection,
        out_http2_error: *mut u32,
        out_last_stream_id: *mut u32,
    ) -> ::core::ffi::c_int;
    #[doc = " Increment the connection's flow-control window to keep data flowing (HTTP/2 only).\n\n If the connection was created with `conn_manual_window_management` set true,\n the flow-control window of the connection will shrink as body data is received for all the streams created on it.\n (headers, padding, and other metadata do not affect the window).\n The initial connection flow-control window is 65,535.\n Once the connection's flow-control window reaches to 0, all the streams on the connection stop receiving any further\n data.\n\n If `conn_manual_window_management` is false, this call will have no effect.\n The connection maintains its flow-control windows such that\n no back-pressure is applied and data arrives as fast as possible.\n\n If you are not connected, this call will have no effect.\n\n Crashes when the connection is not http2 connection.\n The limit of the Maximum Size is 2**31 - 1. If the increment size cause the connection flow window exceeds the\n Maximum size, this call will result in the connection lost.\n\n @param http2_connection HTTP/2 connection.\n @param increment_size The size to increment for the connection's flow control window"]
    pub fn aws_http2_connection_update_window(
        http2_connection: *mut aws_http_connection,
        increment_size: u32,
    );
    pub fn aws_http_connection_manager_acquire(manager: *mut aws_http_connection_manager);
    pub fn aws_http_connection_manager_release(manager: *mut aws_http_connection_manager);
    pub fn aws_http_connection_manager_new(
        allocator: *mut aws_allocator,
        options: *const aws_http_connection_manager_options,
    ) -> *mut aws_http_connection_manager;
    pub fn aws_http_connection_manager_acquire_connection(
        manager: *mut aws_http_connection_manager,
        callback: aws_http_connection_manager_on_connection_setup_fn,
        user_data: *mut ::core::ffi::c_void,
    );
    pub fn aws_http_connection_manager_release_connection(
        manager: *mut aws_http_connection_manager,
        connection: *mut aws_http_connection,
    ) -> ::core::ffi::c_int;
    #[doc = " Fetch the current manager metrics from connection manager."]
    pub fn aws_http_connection_manager_fetch_metrics(
        manager: *const aws_http_connection_manager,
        out_metrics: *mut aws_http_manager_metrics,
    );
    #[doc = " Acquire a refcount from the stream manager, stream manager will start to destroy after the refcount drops to zero.\n NULL is acceptable. Initial refcount after new is 1.\n\n @param manager\n @return The same pointer acquiring."]
    pub fn aws_http2_stream_manager_acquire(
        manager: *mut aws_http2_stream_manager,
    ) -> *mut aws_http2_stream_manager;
    #[doc = " Release a refcount from the stream manager, stream manager will start to destroy after the refcount drops to zero.\n NULL is acceptable. Initial refcount after new is 1.\n\n @param manager\n @return NULL"]
    pub fn aws_http2_stream_manager_release(
        manager: *mut aws_http2_stream_manager,
    ) -> *mut aws_http2_stream_manager;
    pub fn aws_http2_stream_manager_new(
        allocator: *mut aws_allocator,
        options: *const aws_http2_stream_manager_options,
    ) -> *mut aws_http2_stream_manager;
    #[doc = " Acquire a stream from stream manager asynchronously.\n\n @param http2_stream_manager\n @param acquire_stream_option see `aws_http2_stream_manager_acquire_stream_options`"]
    pub fn aws_http2_stream_manager_acquire_stream(
        http2_stream_manager: *mut aws_http2_stream_manager,
        acquire_stream_option: *const aws_http2_stream_manager_acquire_stream_options,
    );
    #[doc = " Fetch the current metrics from stream manager.\n\n @param http2_stream_manager\n @param out_metrics The metrics to be fetched"]
    pub fn aws_http2_stream_manager_fetch_metrics(
        http2_stream_manager: *const aws_http2_stream_manager,
        out_metrics: *mut aws_http_manager_metrics,
    );
    #[doc = " Return whether both names are equivalent.\n This is a case-insensitive string comparison.\n\n Example Matches:\n \"Content-Length\" == \"content-length\" // upper or lower case ok\n\n Example Mismatches:\n \"Content-Length\" != \" Content-Length\" // leading whitespace bad"]
    pub fn aws_http_header_name_eq(name_a: aws_byte_cursor, name_b: aws_byte_cursor) -> bool;
    #[doc = " Create a new headers object.\n The caller has a hold on the object and must call aws_http_headers_release() when they are done with it."]
    pub fn aws_http_headers_new(allocator: *mut aws_allocator) -> *mut aws_http_headers;
    #[doc = " Acquire a hold on the object, preventing it from being deleted until\n aws_http_headers_release() is called by all those with a hold on it."]
    pub fn aws_http_headers_acquire(headers: *mut aws_http_headers);
    #[doc = " Release a hold on the object.\n The object is deleted when all holds on it are released."]
    pub fn aws_http_headers_release(headers: *mut aws_http_headers);
    #[doc = " Add a header.\n The underlying strings are copied."]
    pub fn aws_http_headers_add_header(
        headers: *mut aws_http_headers,
        header: *const aws_http_header,
    ) -> ::core::ffi::c_int;
    #[doc = " Add a header.\n The underlying strings are copied."]
    pub fn aws_http_headers_add(
        headers: *mut aws_http_headers,
        name: aws_byte_cursor,
        value: aws_byte_cursor,
    ) -> ::core::ffi::c_int;
    #[doc = " Add an array of headers.\n The underlying strings are copied."]
    pub fn aws_http_headers_add_array(
        headers: *mut aws_http_headers,
        array: *const aws_http_header,
        count: usize,
    ) -> ::core::ffi::c_int;
    #[doc = " Set a header value.\n The header is added if necessary and any existing values for this name are removed.\n The underlying strings are copied."]
    pub fn aws_http_headers_set(
        headers: *mut aws_http_headers,
        name: aws_byte_cursor,
        value: aws_byte_cursor,
    ) -> ::core::ffi::c_int;
    #[doc = " Get the total number of headers."]
    pub fn aws_http_headers_count(headers: *const aws_http_headers) -> usize;
    #[doc = " Get the header at the specified index.\n The index of a given header may change any time headers are modified.\n When iterating headers, the following ordering rules apply:\n\n - Headers with the same name will always be in the same order, relative to one another.\n   If \"A: one\" is added before \"A: two\", then \"A: one\" will always precede \"A: two\".\n\n - Headers with different names could be in any order, relative to one another.\n   If \"A: one\" is seen before \"B: bee\" in one iteration, you might see \"B: bee\" before \"A: one\" on the next.\n\n AWS_ERROR_INVALID_INDEX is raised if the index is invalid."]
    pub fn aws_http_headers_get_index(
        headers: *const aws_http_headers,
        index: usize,
        out_header: *mut aws_http_header,
    ) -> ::core::ffi::c_int;
    #[doc = " Get all values with this name, combined into one new aws_string that you are responsible for destroying.\n If there are multiple headers with this name, their values are appended with comma-separators.\n If there are no headers with this name, NULL is returned and AWS_ERROR_HTTP_HEADER_NOT_FOUND is raised."]
    pub fn aws_http_headers_get_all(
        headers: *const aws_http_headers,
        name: aws_byte_cursor,
    ) -> *mut aws_string;
    #[doc = " Get the first value for this name, ignoring any additional values.\n AWS_ERROR_HTTP_HEADER_NOT_FOUND is raised if the name is not found."]
    pub fn aws_http_headers_get(
        headers: *const aws_http_headers,
        name: aws_byte_cursor,
        out_value: *mut aws_byte_cursor,
    ) -> ::core::ffi::c_int;
    #[doc = " Test if header name exists or not in headers"]
    pub fn aws_http_headers_has(headers: *const aws_http_headers, name: aws_byte_cursor) -> bool;
    #[doc = " Remove all headers with this name.\n AWS_ERROR_HTTP_HEADER_NOT_FOUND is raised if no headers with this name are found."]
    pub fn aws_http_headers_erase(
        headers: *mut aws_http_headers,
        name: aws_byte_cursor,
    ) -> ::core::ffi::c_int;
    #[doc = " Remove the first header found with this name and value.\n AWS_ERROR_HTTP_HEADER_NOT_FOUND is raised if no such header is found."]
    pub fn aws_http_headers_erase_value(
        headers: *mut aws_http_headers,
        name: aws_byte_cursor,
        value: aws_byte_cursor,
    ) -> ::core::ffi::c_int;
    #[doc = " Remove the header at the specified index.\n\n AWS_ERROR_INVALID_INDEX is raised if the index is invalid."]
    pub fn aws_http_headers_erase_index(
        headers: *mut aws_http_headers,
        index: usize,
    ) -> ::core::ffi::c_int;
    #[doc = " Clear all headers."]
    pub fn aws_http_headers_clear(headers: *mut aws_http_headers);
    #[doc = " Get the `:method` value (HTTP/2 headers only)."]
    pub fn aws_http2_headers_get_request_method(
        h2_headers: *const aws_http_headers,
        out_method: *mut aws_byte_cursor,
    ) -> ::core::ffi::c_int;
    #[doc = " Set `:method` (HTTP/2 headers only).\n The headers makes its own copy of the underlying string."]
    pub fn aws_http2_headers_set_request_method(
        h2_headers: *mut aws_http_headers,
        method: aws_byte_cursor,
    ) -> ::core::ffi::c_int;
    pub fn aws_http2_headers_get_request_scheme(
        h2_headers: *const aws_http_headers,
        out_scheme: *mut aws_byte_cursor,
    ) -> ::core::ffi::c_int;
    #[doc = " Set `:scheme` (request pseudo headers only).\n The pseudo headers makes its own copy of the underlying string."]
    pub fn aws_http2_headers_set_request_scheme(
        h2_headers: *mut aws_http_headers,
        scheme: aws_byte_cursor,
    ) -> ::core::ffi::c_int;
    pub fn aws_http2_headers_get_request_authority(
        h2_headers: *const aws_http_headers,
        out_authority: *mut aws_byte_cursor,
    ) -> ::core::ffi::c_int;
    #[doc = " Set `:authority` (request pseudo headers only).\n The pseudo headers makes its own copy of the underlying string."]
    pub fn aws_http2_headers_set_request_authority(
        h2_headers: *mut aws_http_headers,
        authority: aws_byte_cursor,
    ) -> ::core::ffi::c_int;
    pub fn aws_http2_headers_get_request_path(
        h2_headers: *const aws_http_headers,
        out_path: *mut aws_byte_cursor,
    ) -> ::core::ffi::c_int;
    #[doc = " Set `:path` (request pseudo headers only).\n The pseudo headers makes its own copy of the underlying string."]
    pub fn aws_http2_headers_set_request_path(
        h2_headers: *mut aws_http_headers,
        path: aws_byte_cursor,
    ) -> ::core::ffi::c_int;
    #[doc = " Get `:status` (response pseudo headers only).\n If no status is set, AWS_ERROR_HTTP_DATA_NOT_AVAILABLE is raised."]
    pub fn aws_http2_headers_get_response_status(
        h2_headers: *const aws_http_headers,
        out_status_code: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    #[doc = " Set `:status` (response pseudo headers only)."]
    pub fn aws_http2_headers_set_response_status(
        h2_headers: *mut aws_http_headers,
        status_code: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    #[doc = " Create a new HTTP/1.1 request message.\n The message is blank, all properties (method, path, etc) must be set individually.\n If HTTP/1.1 message used in HTTP/2 connection, the transformation will be automatically applied.\n A HTTP/2 message will created and sent based on the HTTP/1.1 message.\n\n The caller has a hold on the object and must call aws_http_message_release() when they are done with it."]
    pub fn aws_http_message_new_request(allocator: *mut aws_allocator) -> *mut aws_http_message;
    #[doc = " Like aws_http_message_new_request(), but uses existing aws_http_headers instead of creating a new one.\n Acquires a hold on the headers, and releases it when the request is destroyed."]
    pub fn aws_http_message_new_request_with_headers(
        allocator: *mut aws_allocator,
        existing_headers: *mut aws_http_headers,
    ) -> *mut aws_http_message;
    #[doc = " Create a new HTTP/1.1 response message.\n The message is blank, all properties (status, headers, etc) must be set individually.\n\n The caller has a hold on the object and must call aws_http_message_release() when they are done with it."]
    pub fn aws_http_message_new_response(allocator: *mut aws_allocator) -> *mut aws_http_message;
    #[doc = " Create a new HTTP/2 request message.\n pseudo headers need to be set from aws_http2_headers_set_request_* to the headers of the aws_http_message.\n Will be errored out if used in HTTP/1.1 connection.\n\n The caller has a hold on the object and must call aws_http_message_release() when they are done with it."]
    pub fn aws_http2_message_new_request(allocator: *mut aws_allocator) -> *mut aws_http_message;
    #[doc = " Create a new HTTP/2 response message.\n pseudo headers need to be set from aws_http2_headers_set_response_status to the headers of the aws_http_message.\n Will be errored out if used in HTTP/1.1 connection.\n\n The caller has a hold on the object and must call aws_http_message_release() when they are done with it."]
    pub fn aws_http2_message_new_response(allocator: *mut aws_allocator) -> *mut aws_http_message;
    #[doc = " Create an HTTP/2 message from HTTP/1.1 message.\n pseudo headers will be created from the context and added to the headers of new message.\n Normal headers will be copied to the headers of new message.\n Note:\n  - if `host` exist, it will be removed and `:authority` will be added using the information.\n  - `:scheme` always defaults to \"https\". To use a different scheme create the HTTP/2 message directly"]
    pub fn aws_http2_message_new_from_http1(
        alloc: *mut aws_allocator,
        http1_msg: *const aws_http_message,
    ) -> *mut aws_http_message;
    #[doc = " Acquire a hold on the object, preventing it from being deleted until\n aws_http_message_release() is called by all those with a hold on it.\n\n This function returns the passed in message (possibly NULL) so that acquire-and-assign can be done with a single\n statement."]
    pub fn aws_http_message_acquire(message: *mut aws_http_message) -> *mut aws_http_message;
    #[doc = " Release a hold on the object.\n The object is deleted when all holds on it are released.\n\n This function always returns NULL so that release-and-assign-NULL can be done with a single statement."]
    pub fn aws_http_message_release(message: *mut aws_http_message) -> *mut aws_http_message;
    #[doc = " Deprecated. This is equivalent to aws_http_message_release()."]
    pub fn aws_http_message_destroy(message: *mut aws_http_message);
    pub fn aws_http_message_is_request(message: *const aws_http_message) -> bool;
    pub fn aws_http_message_is_response(message: *const aws_http_message) -> bool;
    #[doc = " Get the protocol version of the http message."]
    pub fn aws_http_message_get_protocol_version(
        message: *const aws_http_message,
    ) -> aws_http_version;
    #[doc = " Get the method (request messages only)."]
    pub fn aws_http_message_get_request_method(
        request_message: *const aws_http_message,
        out_method: *mut aws_byte_cursor,
    ) -> ::core::ffi::c_int;
    #[doc = " Set the method (request messages only).\n The request makes its own copy of the underlying string."]
    pub fn aws_http_message_set_request_method(
        request_message: *mut aws_http_message,
        method: aws_byte_cursor,
    ) -> ::core::ffi::c_int;
    pub fn aws_http_message_get_request_path(
        request_message: *const aws_http_message,
        out_path: *mut aws_byte_cursor,
    ) -> ::core::ffi::c_int;
    #[doc = " Set the path-and-query value (request messages only).\n The request makes its own copy of the underlying string."]
    pub fn aws_http_message_set_request_path(
        request_message: *mut aws_http_message,
        path: aws_byte_cursor,
    ) -> ::core::ffi::c_int;
    #[doc = " Get the status code (response messages only).\n If no status is set, AWS_ERROR_HTTP_DATA_NOT_AVAILABLE is raised."]
    pub fn aws_http_message_get_response_status(
        response_message: *const aws_http_message,
        out_status_code: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    #[doc = " Set the status code (response messages only)."]
    pub fn aws_http_message_set_response_status(
        response_message: *mut aws_http_message,
        status_code: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    #[doc = " Get the body stream.\n Returns NULL if no body stream is set."]
    pub fn aws_http_message_get_body_stream(
        message: *const aws_http_message,
    ) -> *mut aws_input_stream;
    #[doc = " Set the body stream.\n NULL is an acceptable value for messages with no body.\n Note: The message does NOT take ownership of the body stream.\n The stream must not be destroyed until the message is complete."]
    pub fn aws_http_message_set_body_stream(
        message: *mut aws_http_message,
        body_stream: *mut aws_input_stream,
    );
    #[doc = " Submit a chunk of data to be sent on an HTTP/1.1 stream.\n The stream must have specified \"chunked\" in a \"transfer-encoding\" header.\n For client streams, activate() must be called before any chunks are submitted.\n For server streams, the response must be submitted before any chunks.\n A final chunk with size 0 must be submitted to successfully complete the HTTP-stream.\n\n Returns AWS_OP_SUCCESS if the chunk has been submitted. The chunk's completion\n callback will be invoked when the HTTP-stream is done with the chunk data,\n whether or not it was successfully sent (see `aws_http1_stream_write_chunk_complete_fn`).\n The chunk data must remain valid until the completion callback is invoked.\n\n Returns AWS_OP_ERR and raises an error if the chunk could not be submitted.\n In this case, the chunk's completion callback will never be invoked.\n Note that it is always possible for the HTTP-stream to terminate unexpectedly\n prior to this call being made, in which case the error raised is\n AWS_ERROR_HTTP_STREAM_HAS_COMPLETED."]
    pub fn aws_http1_stream_write_chunk(
        http1_stream: *mut aws_http_stream,
        options: *const aws_http1_chunk_options,
    ) -> ::core::ffi::c_int;
    #[doc = " The stream must have specified `http2_use_manual_data_writes` during request creation.\n For client streams, activate() must be called before any frames are submitted.\n For server streams, the response headers must be submitted before any frames.\n A write with options that has end_stream set to be true will end the stream and prevent any further write.\n\n @return AWS_OP_SUCCESS if the write was queued\n         AWS_OP_ERROR indicating the attempt raised an error code.\n              AWS_ERROR_INVALID_STATE will be raised for invalid usage.\n              AWS_ERROR_HTTP_STREAM_HAS_COMPLETED will be raised if the stream ended for reasons behind the scenes.\n\n Typical usage will be something like:\n options.http2_use_manual_data_writes = true;\n stream = aws_http_connection_make_request(connection, &options);\n aws_http_stream_activate(stream);\n ...\n struct aws_http2_stream_write_data_options write;\n aws_http2_stream_write_data(stream, &write);\n ...\n struct aws_http2_stream_write_data_options last_write;\n last_write.end_stream = true;\n aws_http2_stream_write_data(stream, &write);\n ...\n aws_http_stream_release(stream);"]
    pub fn aws_http2_stream_write_data(
        http2_stream: *mut aws_http_stream,
        options: *const aws_http2_stream_write_data_options,
    ) -> ::core::ffi::c_int;
    #[doc = " Add a list of headers to be added as trailing headers sent after the last chunk is sent.\n a \"Trailer\" header field which indicates the fields present in the trailer.\n\n Certain headers are forbidden in the trailer (e.g., Transfer-Encoding, Content-Length, Host). See RFC-7541\n Section 4.1.2 for more details.\n\n For client streams, activate() must be called before any chunks are submitted.\n\n For server streams, the response must be submitted before the trailer can be added\n\n aws_http1_stream_add_chunked_trailer must be called before the final size 0 chunk, and at the moment can only\n be called once, though this could change if need be.\n\n Returns AWS_OP_SUCCESS if the chunk has been submitted."]
    pub fn aws_http1_stream_add_chunked_trailer(
        http1_stream: *mut aws_http_stream,
        trailing_headers: *const aws_http_headers,
    ) -> ::core::ffi::c_int;
    #[doc = " This datastructure has more functions for inspecting and modifying headers than\n are available on the aws_http_message datastructure."]
    pub fn aws_http_message_get_headers(message: *const aws_http_message) -> *mut aws_http_headers;
    #[doc = " Get the message's const aws_http_headers."]
    pub fn aws_http_message_get_const_headers(
        message: *const aws_http_message,
    ) -> *const aws_http_headers;
    #[doc = " Get the number of headers."]
    pub fn aws_http_message_get_header_count(message: *const aws_http_message) -> usize;
    #[doc = " Get the header at the specified index.\n This function cannot fail if a valid index is provided.\n Otherwise, AWS_ERROR_INVALID_INDEX will be raised.\n\n The underlying strings are stored within the message."]
    pub fn aws_http_message_get_header(
        message: *const aws_http_message,
        out_header: *mut aws_http_header,
        index: usize,
    ) -> ::core::ffi::c_int;
    #[doc = " Add a header to the end of the array.\n The message makes its own copy of the underlying strings."]
    pub fn aws_http_message_add_header(
        message: *mut aws_http_message,
        header: aws_http_header,
    ) -> ::core::ffi::c_int;
    #[doc = " Add an array of headers to the end of the header array.\n The message makes its own copy of the underlying strings.\n\n This is a helper function useful when it's easier to define headers as a stack array, rather than calling add_header\n repeatedly."]
    pub fn aws_http_message_add_header_array(
        message: *mut aws_http_message,
        headers: *const aws_http_header,
        num_headers: usize,
    ) -> ::core::ffi::c_int;
    #[doc = " Remove the header at the specified index.\n Headers after this index are all shifted back one position.\n\n This function cannot fail if a valid index is provided.\n Otherwise, AWS_ERROR_INVALID_INDEX will be raised."]
    pub fn aws_http_message_erase_header(
        message: *mut aws_http_message,
        index: usize,
    ) -> ::core::ffi::c_int;
    #[doc = " Create a stream, with a client connection sending a request.\n The request does not start sending automatically once the stream is created. You must call\n aws_http_stream_activate to begin execution of the request.\n\n The `options` are copied during this call.\n\n Tip for language bindings: Do not bind the `options` struct. Use something more natural for your language,\n such as Builder Pattern in Java, or Python's ability to take many optional arguments by name.\n\n Note: The header of the request will be sent as it is when the message to send protocol matches the protocol of the\n connection.\n  - No `user-agent` will be added.\n  - No security check will be enforced. eg: `referer` header privacy should be enforced by the user-agent who adds the\n      header\n  - When HTTP/1 message sent on HTTP/2 connection, `aws_http2_message_new_from_http1` will be applied under the hood.\n  - When HTTP/2 message sent on HTTP/1 connection, no change will be made."]
    pub fn aws_http_connection_make_request(
        client_connection: *mut aws_http_connection,
        options: *const aws_http_make_request_options,
    ) -> *mut aws_http_stream;
    #[doc = " Create a stream, with a server connection receiving and responding to a request.\n This function can only be called from the `aws_http_on_incoming_request_fn` callback.\n aws_http_stream_send_response() should be used to send a response."]
    pub fn aws_http_stream_new_server_request_handler(
        options: *const aws_http_request_handler_options,
    ) -> *mut aws_http_stream;
    #[doc = " Acquire refcount on the stream to prevent it from being cleaned up until it is released."]
    pub fn aws_http_stream_acquire(stream: *mut aws_http_stream) -> *mut aws_http_stream;
    #[doc = " Users must release the stream when they are done with it, or its memory will never be cleaned up.\n This will not cancel the stream, its callbacks will still fire if the stream is still in progress.\n\n Tips for language bindings:\n - Invoke this from the wrapper class's finalizer/destructor.\n - Do not let the wrapper class be destroyed until on_complete() has fired."]
    pub fn aws_http_stream_release(stream: *mut aws_http_stream);
    #[doc = " Only used for client initiated streams (immediately following a call to aws_http_connection_make_request).\n\n Activates the request's outgoing stream processing."]
    pub fn aws_http_stream_activate(stream: *mut aws_http_stream) -> ::core::ffi::c_int;
    pub fn aws_http_stream_get_connection(
        stream: *const aws_http_stream,
    ) -> *mut aws_http_connection;
    pub fn aws_http_stream_get_incoming_response_status(
        stream: *const aws_http_stream,
        out_status: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn aws_http_stream_get_incoming_request_method(
        stream: *const aws_http_stream,
        out_method: *mut aws_byte_cursor,
    ) -> ::core::ffi::c_int;
    pub fn aws_http_stream_get_incoming_request_uri(
        stream: *const aws_http_stream,
        out_uri: *mut aws_byte_cursor,
    ) -> ::core::ffi::c_int;
    #[doc = " Send response (only callable from \"request handler\" streams)\n The response object must stay alive at least until the stream's on_complete is called."]
    pub fn aws_http_stream_send_response(
        stream: *mut aws_http_stream,
        response: *mut aws_http_message,
    ) -> ::core::ffi::c_int;
    #[doc = " Increment the stream's flow-control window to keep data flowing.\n\n If the connection was created with `manual_window_management` set true,\n the flow-control window of each stream will shrink as body data is received\n (headers, padding, and other metadata do not affect the window).\n The connection's `initial_window_size` determines the starting size of each stream's window.\n If a stream's flow-control window reaches 0, no further data will be received.\n\n If `manual_window_management` is false, this call will have no effect.\n The connection maintains its flow-control windows such that\n no back-pressure is applied and data arrives as fast as possible."]
    pub fn aws_http_stream_update_window(stream: *mut aws_http_stream, increment_size: usize);
    #[doc = " Gets the HTTP/2 id associated with a stream.  Even h1 streams have an id (using the same allocation procedure\n as http/2) for easier tracking purposes. For client streams, this will only be non-zero after a successful call\n to aws_http_stream_activate()"]
    pub fn aws_http_stream_get_id(stream: *const aws_http_stream) -> u32;
    #[doc = " Cancel the stream in flight.\n For HTTP/1.1 streams, it's equivalent to closing the connection.\n For HTTP/2 streams, it's equivalent to calling reset on the stream with `AWS_HTTP2_ERR_CANCEL`.\n\n the stream will complete with the error code provided, unless the stream is\n already completing for other reasons, or the stream is not activated,\n in which case this call will have no impact."]
    pub fn aws_http_stream_cancel(stream: *mut aws_http_stream, error_code: ::core::ffi::c_int);
    #[doc = " Reset the HTTP/2 stream (HTTP/2 only).\n Note that if the stream closes before this async call is fully processed, the RST_STREAM frame will not be sent.\n\n @param http2_stream HTTP/2 stream.\n @param http2_error aws_http2_error_code. Reason to reset the stream."]
    pub fn aws_http2_stream_reset(
        http2_stream: *mut aws_http_stream,
        http2_error: u32,
    ) -> ::core::ffi::c_int;
    #[doc = " Get the error code received in rst_stream.\n Only valid if the stream has completed, and an RST_STREAM frame has received.\n\n @param http2_stream HTTP/2 stream.\n @param out_http2_error Gets to set to HTTP/2 error code received in rst_stream."]
    pub fn aws_http2_stream_get_received_reset_error_code(
        http2_stream: *mut aws_http_stream,
        out_http2_error: *mut u32,
    ) -> ::core::ffi::c_int;
    #[doc = " Get the HTTP/2 error code sent in the RST_STREAM frame (HTTP/2 only).\n Only valid if the stream has completed, and has sent an RST_STREAM frame.\n\n @param http2_stream HTTP/2 stream.\n @param out_http2_error Gets to set to HTTP/2 error code sent in rst_stream."]
    pub fn aws_http2_stream_get_sent_reset_error_code(
        http2_stream: *mut aws_http_stream,
        out_http2_error: *mut u32,
    ) -> ::core::ffi::c_int;
    #[doc = " Take a reference to an http proxy negotiator\n @param proxy_negotiator negotiator to take a reference to\n @return the strategy"]
    pub fn aws_http_proxy_negotiator_acquire(
        proxy_negotiator: *mut aws_http_proxy_negotiator,
    ) -> *mut aws_http_proxy_negotiator;
    #[doc = " Release a reference to an http proxy negotiator\n @param proxy_negotiator negotiator to release a reference to"]
    pub fn aws_http_proxy_negotiator_release(proxy_negotiator: *mut aws_http_proxy_negotiator);
    #[doc = " Creates a new proxy negotiator from a proxy strategy\n @param allocator memory allocator to use\n @param strategy strategy to creation a new negotiator for\n @return a new proxy negotiator if successful, otherwise NULL"]
    pub fn aws_http_proxy_strategy_create_negotiator(
        strategy: *mut aws_http_proxy_strategy,
        allocator: *mut aws_allocator,
    ) -> *mut aws_http_proxy_negotiator;
    #[doc = " Take a reference to an http proxy strategy\n @param proxy_strategy strategy to take a reference to\n @return the strategy"]
    pub fn aws_http_proxy_strategy_acquire(
        proxy_strategy: *mut aws_http_proxy_strategy,
    ) -> *mut aws_http_proxy_strategy;
    #[doc = " Release a reference to an http proxy strategy\n @param proxy_strategy strategy to release a reference to"]
    pub fn aws_http_proxy_strategy_release(proxy_strategy: *mut aws_http_proxy_strategy);
    #[doc = " A constructor for a proxy strategy that performs basic authentication by adding the appropriate\n header and header value to requests or CONNECT requests.\n\n @param allocator memory allocator to use\n @param config basic authentication configuration info\n @return a new proxy strategy if successfully constructed, otherwise NULL"]
    pub fn aws_http_proxy_strategy_new_basic_auth(
        allocator: *mut aws_allocator,
        config: *mut aws_http_proxy_strategy_basic_auth_options,
    ) -> *mut aws_http_proxy_strategy;
    #[doc = " Constructor for an adaptive tunneling proxy strategy.  This strategy attempts a vanilla CONNECT and if that\n fails it may make followup CONNECT attempts using kerberos or ntlm tokens, based on configuration and proxy\n response properties.\n\n @param allocator memory allocator to use\n @param config configuration options for the strategy\n @return a new proxy strategy if successfully constructed, otherwise NULL"]
    pub fn aws_http_proxy_strategy_new_tunneling_adaptive(
        allocator: *mut aws_allocator,
        config: *mut aws_http_proxy_strategy_tunneling_adaptive_options,
    ) -> *mut aws_http_proxy_strategy;
    #[doc = " Create a persistent proxy configuration from http connection options\n @param allocator memory allocator to use\n @param options http connection options to source proxy configuration from\n @return"]
    pub fn aws_http_proxy_config_new_from_connection_options(
        allocator: *mut aws_allocator,
        options: *const aws_http_client_connection_options,
    ) -> *mut aws_http_proxy_config;
    #[doc = " Create a persistent proxy configuration from http connection manager options\n @param allocator memory allocator to use\n @param options http connection manager options to source proxy configuration from\n @return"]
    pub fn aws_http_proxy_config_new_from_manager_options(
        allocator: *mut aws_allocator,
        options: *const aws_http_connection_manager_options,
    ) -> *mut aws_http_proxy_config;
    #[doc = " Create a persistent proxy configuration from non-persistent proxy options.  The resulting\n proxy configuration assumes a tunneling connection type.\n\n @param allocator memory allocator to use\n @param options http proxy options to source proxy configuration from\n @return"]
    pub fn aws_http_proxy_config_new_tunneling_from_proxy_options(
        allocator: *mut aws_allocator,
        options: *const aws_http_proxy_options,
    ) -> *mut aws_http_proxy_config;
    #[doc = " Create a persistent proxy configuration from non-persistent proxy options.\n Legacy connection type of proxy options will be rejected.\n\n @param allocator memory allocator to use\n @param options http proxy options to source proxy configuration from\n @return"]
    pub fn aws_http_proxy_config_new_from_proxy_options(
        allocator: *mut aws_allocator,
        options: *const aws_http_proxy_options,
    ) -> *mut aws_http_proxy_config;
    #[doc = " Create a persistent proxy configuration from non-persistent proxy options.\n\n @param allocator memory allocator to use\n @param options http proxy options to source proxy configuration from\n @param is_tls_connection tls connection info of the main connection to determine connection_type\n                          when the connection_type is legacy.\n @return"]
    pub fn aws_http_proxy_config_new_from_proxy_options_with_tls_info(
        allocator: *mut aws_allocator,
        proxy_options: *const aws_http_proxy_options,
        is_tls_connection: bool,
    ) -> *mut aws_http_proxy_config;
    #[doc = " Clones an existing proxy configuration.  A refactor could remove this (do a \"move\" between the old and new user\n data in the one spot it's used) but that should wait until we have better test cases for the logic where this\n gets invoked (ntlm/kerberos chains).\n\n @param allocator memory allocator to use\n @param proxy_config http proxy configuration to clone\n @return"]
    pub fn aws_http_proxy_config_new_clone(
        allocator: *mut aws_allocator,
        proxy_config: *const aws_http_proxy_config,
    ) -> *mut aws_http_proxy_config;
    #[doc = " Destroys an http proxy configuration\n @param config http proxy configuration to destroy"]
    pub fn aws_http_proxy_config_destroy(config: *mut aws_http_proxy_config);
    #[doc = " Initializes non-persistent http proxy options from a persistent http proxy configuration\n @param options http proxy options to initialize\n @param config the http proxy config to use as an initialization source"]
    pub fn aws_http_proxy_options_init_from_config(
        options: *mut aws_http_proxy_options,
        config: *const aws_http_proxy_config,
    );
    #[doc = " Establish an arbitrary protocol connection through an http proxy via tunneling CONNECT.  Alpn is\n not required for this connection process to succeed, but we encourage its use if available.\n\n @param channel_options configuration options for the socket level connection\n @param proxy_options configuration options for the proxy connection\n\n @return AWS_OP_SUCCESS if the asynchronous channel kickoff succeeded, AWS_OP_ERR otherwise"]
    pub fn aws_http_proxy_new_socket_channel(
        channel_options: *mut aws_socket_channel_bootstrap_options,
        proxy_options: *const aws_http_proxy_options,
    ) -> ::core::ffi::c_int;
    #[doc = " Create server, a listening socket that accepts incoming connections."]
    pub fn aws_http_server_new(options: *const aws_http_server_options) -> *mut aws_http_server;
    #[doc = " Release the server. It will close the listening socket and all the connections existing in the server.\n The on_destroy_complete will be invoked when the destroy operation completes"]
    pub fn aws_http_server_release(server: *mut aws_http_server);
    #[doc = " Configure a server connection.\n This must be called from the server's on_incoming_connection callback."]
    pub fn aws_http_connection_configure_server(
        connection: *mut aws_http_connection,
        options: *const aws_http_server_connection_options,
    ) -> ::core::ffi::c_int;
    #[doc = " Returns true if this is a server connection."]
    pub fn aws_http_connection_is_server(connection: *const aws_http_connection) -> bool;
    #[doc = " Initializes a http channel handler statistics struct"]
    pub fn aws_crt_statistics_http1_channel_init(
        stats: *mut aws_crt_statistics_http1_channel,
    ) -> ::core::ffi::c_int;
    #[doc = " Cleans up a http channel handler statistics struct"]
    pub fn aws_crt_statistics_http1_channel_cleanup(stats: *mut aws_crt_statistics_http1_channel);
    #[doc = " Resets a http channel handler statistics struct's statistics"]
    pub fn aws_crt_statistics_http1_channel_reset(stats: *mut aws_crt_statistics_http1_channel);
    #[doc = " Initializes a HTTP/2 channel handler statistics struct"]
    pub fn aws_crt_statistics_http2_channel_init(stats: *mut aws_crt_statistics_http2_channel);
    #[doc = " Resets a HTTP/2 channel handler statistics struct's statistics"]
    pub fn aws_crt_statistics_http2_channel_reset(stats: *mut aws_crt_statistics_http2_channel);
    #[doc = " Return true if opcode is for a data frame, false if opcode if for a control frame."]
    pub fn aws_websocket_is_data_frame(opcode: u8) -> bool;
    #[doc = " Asynchronously establish a client websocket connection.\n The on_connection_setup callback is invoked when the operation has finished creating a connection, or failed."]
    pub fn aws_websocket_client_connect(
        options: *const aws_websocket_client_connection_options,
    ) -> ::core::ffi::c_int;
    #[doc = " Increment the websocket's ref-count, preventing it from being destroyed.\n @return Always returns the same pointer that is passed in."]
    pub fn aws_websocket_acquire(websocket: *mut aws_websocket) -> *mut aws_websocket;
    #[doc = " Decrement the websocket's ref-count.\n When the ref-count reaches zero, the connection will shut down, if it hasn't already.\n Users must release the websocket when they are done with it.\n The websocket's memory cannot be reclaimed until this is done.\n Callbacks may continue firing after this is called, with \"shutdown\" being the final callback.\n This function may be called from any thread.\n\n It is safe to pass NULL, nothing will happen."]
    pub fn aws_websocket_release(websocket: *mut aws_websocket);
    #[doc = " Close the websocket connection.\n It is safe to call this, even if the connection is already closed or closing.\n The websocket will attempt to send a CLOSE frame during normal shutdown.\n If `free_scarce_resources_immediately` is true, the connection will be torn down as quickly as possible.\n This function may be called from any thread."]
    pub fn aws_websocket_close(
        websocket: *mut aws_websocket,
        free_scarce_resources_immediately: bool,
    );
    #[doc = " Send a websocket frame.\n The `options` struct is copied.\n A callback will be invoked when the operation completes.\n This function may be called from any thread."]
    pub fn aws_websocket_send_frame(
        websocket: *mut aws_websocket,
        options: *const aws_websocket_send_frame_options,
    ) -> ::core::ffi::c_int;
    #[doc = " Manually increment the read window to keep frames flowing.\n\n If the websocket was created with `manual_window_management` set true,\n then whenever the read window reaches 0 you will stop receiving data.\n The websocket's `initial_window_size` determines the starting size of the read window.\n The read window shrinks as you receive the payload from \"data\" frames (TEXT, BINARY, and CONTINUATION).\n Use aws_websocket_increment_read_window() to increment the window again and keep frames flowing.\n Maintain a larger window to keep up high throughput.\n You only need to worry about the payload from \"data\" frames.\n The websocket automatically increments the window to account for any\n other incoming bytes, including other parts of a frame (opcode, payload-length, etc)\n and the payload of other frame types (PING, PONG, CLOSE).\n\n If the websocket was created with `manual_window_management` set false, this function does nothing.\n\n This function may be called from any thread."]
    pub fn aws_websocket_increment_read_window(websocket: *mut aws_websocket, size: usize);
    #[doc = " Convert the websocket into a mid-channel handler.\n The websocket will stop being usable via its public API and become just another handler in the channel.\n The caller will likely install a channel handler to the right.\n This must not be called in the middle of an incoming frame (between \"frame begin\" and \"frame complete\" callbacks).\n This MUST be called from the websocket's thread.\n\n If successful:\n - Other than aws_websocket_release(), all calls to aws_websocket_x() functions are ignored.\n - The websocket will no longer invoke any \"incoming frame\" callbacks.\n - aws_io_messages written by a downstream handler will be wrapped in binary data frames and sent upstream.\n   The data may be split/combined as it is sent along.\n - aws_io_messages read from upstream handlers will be scanned for binary data frames.\n   The payloads of these frames will be sent downstream.\n   The payloads may be split/combined as they are sent along.\n - An incoming close frame will automatically result in channel-shutdown.\n - aws_websocket_release() must still be called or the websocket and its channel will never be cleaned up.\n - The websocket will still invoke its \"on connection shutdown\" callback when channel shutdown completes.\n\n If unsuccessful, NULL is returned and the websocket is unchanged."]
    pub fn aws_websocket_convert_to_midchannel_handler(
        websocket: *mut aws_websocket,
    ) -> ::core::ffi::c_int;
    #[doc = " Returns the websocket's underlying I/O channel."]
    pub fn aws_websocket_get_channel(websocket: *const aws_websocket) -> *mut aws_channel;
    #[doc = " Generate value for a Sec-WebSocket-Key header and write it into `dst` buffer.\n The buffer should have at least AWS_WEBSOCKET_MAX_HANDSHAKE_KEY_LENGTH space available.\n\n This value is the base64 encoding of a random 16-byte value.\n RFC-6455 Section 4.1"]
    pub fn aws_websocket_random_handshake_key(dst: *mut aws_byte_buf) -> ::core::ffi::c_int;
    #[doc = " Create request with all required fields for a websocket upgrade request.\n The method and path are set, and the the following headers are added:\n\n Host: <host>\n Upgrade: websocket\n Connection: Upgrade\n Sec-WebSocket-Key: <base64 encoding of 16 random bytes>\n Sec-WebSocket-Version: 13"]
    pub fn aws_http_message_new_websocket_handshake_request(
        allocator: *mut aws_allocator,
        path: aws_byte_cursor,
        host: aws_byte_cursor,
    ) -> *mut aws_http_message;
}
