/* automatically generated by rust-bindgen 0.69.1 */

pub type aws_iotdevice_error = ::core::ffi::c_uint;
pub type aws_iotdevice_log_subject = ::core::ffi::c_uint;
#[doc = " Callback to invoke when the defender task needs to \"publish\" a report. Useful to override default\n MQTT publish behavior, for testing report outputs\n\n Notes:\n * This function should not perform blocking IO.\n * This function should copy the report if it needs to hold on to the memory for an IO operation\n\n returns: AWS_OP_SUCCESS if the user callback wants to consider the publish failed."]
pub type aws_iotdevice_defender_publish_fn = ::core::option::Option<
    unsafe extern "C" fn(
        report: aws_byte_cursor,
        userdata: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int,
>;
#[doc = " General callback handler for the task to report that an error occurred while\n running the DeviceDefender task. Error codes can only go so far in describing\n where/when and how the failure occur so the errors here may best communicate\n where/when and the how of the underlying call should be found in log output\n\n \\param[in]    is_task_stopped    flag indicating whether or not the task is unable to continue running\n \\param[in]    error_code         error code describing the nature of the failure"]
pub type aws_iotdevice_defender_task_failure_fn = ::core::option::Option<
    unsafe extern "C" fn(
        is_task_stopped: bool,
        error_code: ::core::ffi::c_int,
        userdata: *mut ::core::ffi::c_void,
    ),
>;
#[doc = " User callback type invoked when DeviceDefender task has completed cancellation. After a request\n to stop the task, this signals the completion of the cancellation and no further user callbacks will\n be invoked.\n\n \\param[in]    userdata      callback userdata"]
pub type aws_iotdevice_defender_task_canceled_fn =
    ::core::option::Option<unsafe extern "C" fn(userdata: *mut ::core::ffi::c_void)>;
#[doc = " User callback type invoked when a report fails to submit.\n\n There are two possibilities for failed submission:\n  1. The MQTT client fails to publish the message and returns an error code. In this\n     scenario, the client_error_code will be a value other than  AWS_ERROR_SUCCESS. The\n     rejected_message_payload parameter will be NULL.\n  2. After a successful publish, a reply is received on the respective MQTT rejected\n     topic with a message. In this scenario, the client_error_code will be\n     AWS_ERROR_SUCCESS, and rejected_message_payload will contain the payload of the\n     rejected message received.\n \\param[in]    rejected_message_payload    response payload recieved from rejection topic\n \\param[in]    userdata                    callback userdata"]
pub type aws_iotdevice_defender_report_rejected_fn = ::core::option::Option<
    unsafe extern "C" fn(
        rejected_message_payload: *const aws_byte_cursor,
        userdata: *mut ::core::ffi::c_void,
    ),
>;
#[doc = " User callback type invoked when the subscribed device defender topic for accepted\n reports receives a message."]
pub type aws_iotdevice_defender_report_accepted_fn = ::core::option::Option<
    unsafe extern "C" fn(
        accepted_message_payload: *const aws_byte_cursor,
        userdata: *mut ::core::ffi::c_void,
    ),
>;
#[doc = " User callback type invoked to retrieve a number type custom metric.\n\n returns: AWS_OP_SUCCESS if the custom metric was successfully added to the task config"]
pub type aws_iotdevice_defender_get_number_fn = ::core::option::Option<
    unsafe extern "C" fn(value: *mut f64, userdata: *mut ::core::ffi::c_void) -> ::core::ffi::c_int,
>;
#[doc = " User callback type invoked to retrieve a number list custom metric\n\n List provided will already be initialized and caller must push items into the list\n of type double.\n\n returns: AWS_OP_SUCCESS if the custom metric was successfully added to the task config"]
pub type aws_iotdevice_defender_get_number_list_fn = ::core::option::Option<
    unsafe extern "C" fn(
        number_list: *mut aws_array_list,
        userdata: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int,
>;
#[doc = " User callback type invoked to retrieve a string list custom metric\n\n List provided will already be initialized and caller must push items into the list\n of type (struct aws_string *). String allocated that are placed into the list are\n destroyed by the defender task after it is done with the list.\n\n returns: AWS_OP_SUCCESS if the custom metric was successfully added to the task config"]
pub type aws_iotdevice_defender_get_string_list_fn = ::core::option::Option<
    unsafe extern "C" fn(
        string_list: *mut aws_array_list,
        userdata: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int,
>;
#[doc = " User callback type invoked to retrieve an ip list custom metric\n\n List provided will already be initialized and caller must push items into the list\n of type (struct aws_string *). String allocated that are placed into the list are\n destroyed by the defender task after it is done with the list.\n\n returns: AWS_OP_SUCCESS if the custom metric was successfully added to the task config"]
pub type aws_iotdevice_defender_get_ip_list_fn = ::core::option::Option<
    unsafe extern "C" fn(
        ip_list: *mut aws_array_list,
        userdata: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int,
>;
pub type aws_iotdevice_defender_report_format = ::core::ffi::c_uint;
#[doc = " Change name if this needs external exposure. Needed to keep track of how to\n interpret instantiated metrics, and cast the supplier_fn correctly."]
pub type defender_custom_metric_type = ::core::ffi::c_uint;
pub type aws_secure_tunneling_local_proxy_mode = ::core::ffi::c_uint;
#[doc = " Type of IoT Secure Tunnel message.\n Enum values match IoT Secure Tunneling Local Proxy V3 Websocket Protocol Guide values.\n\n https://github.com/aws-samples/aws-iot-securetunneling-localproxy/blob/main/V3WebSocketProtocolGuide.md"]
pub type aws_secure_tunnel_message_type = ::core::ffi::c_uint;
#[doc = " Signature of callback to invoke on received messages"]
pub type aws_secure_tunnel_message_received_fn = ::core::option::Option<
    unsafe extern "C" fn(
        message: *const aws_secure_tunnel_message_view,
        user_data: *mut ::core::ffi::c_void,
    ),
>;
#[doc = " Signature of callback to invoke on fully established connection to Secure Tunnel Service"]
pub type aws_secure_tunneling_on_connection_complete_fn = ::core::option::Option<
    unsafe extern "C" fn(
        connection_view: *const aws_secure_tunnel_connection_view,
        error_code: ::core::ffi::c_int,
        user_data: *mut ::core::ffi::c_void,
    ),
>;
#[doc = " Signature of callback to invoke on shutdown of connection to Secure Tunnel Service"]
pub type aws_secure_tunneling_on_connection_shutdown_fn = ::core::option::Option<
    unsafe extern "C" fn(error_code: ::core::ffi::c_int, user_data: *mut ::core::ffi::c_void),
>;
#[doc = " Signature of callback to invoke on completion of an outbound message"]
pub type aws_secure_tunneling_on_send_message_complete_fn = ::core::option::Option<
    unsafe extern "C" fn(
        type_: aws_secure_tunnel_message_type,
        error_code: ::core::ffi::c_int,
        user_data: *mut ::core::ffi::c_void,
    ),
>;
#[doc = " Signature of callback to invoke on the start of a stream"]
pub type aws_secure_tunneling_on_stream_start_fn = ::core::option::Option<
    unsafe extern "C" fn(
        message: *const aws_secure_tunnel_message_view,
        error_code: ::core::ffi::c_int,
        user_data: *mut ::core::ffi::c_void,
    ),
>;
#[doc = " Signature of callback to invoke on a stream being reset"]
pub type aws_secure_tunneling_on_stream_reset_fn = ::core::option::Option<
    unsafe extern "C" fn(
        message: *const aws_secure_tunnel_message_view,
        error_code: ::core::ffi::c_int,
        user_data: *mut ::core::ffi::c_void,
    ),
>;
#[doc = " Signature of callback to invoke on start of a connection id stream"]
pub type aws_secure_tunneling_on_connection_start_fn = ::core::option::Option<
    unsafe extern "C" fn(
        message: *const aws_secure_tunnel_message_view,
        error_code: ::core::ffi::c_int,
        user_data: *mut ::core::ffi::c_void,
    ),
>;
#[doc = " Signature of callback to invoke on a connection id stream being reset"]
pub type aws_secure_tunneling_on_connection_reset_fn = ::core::option::Option<
    unsafe extern "C" fn(
        message: *const aws_secure_tunnel_message_view,
        error_code: ::core::ffi::c_int,
        user_data: *mut ::core::ffi::c_void,
    ),
>;
#[doc = " Signature of callback to invoke on session reset recieved from the Secure Tunnel Service"]
pub type aws_secure_tunneling_on_session_reset_fn =
    ::core::option::Option<unsafe extern "C" fn(user_data: *mut ::core::ffi::c_void)>;
#[doc = " Signature of callback to invoke on Secure Tunnel reaching a STOPPED state"]
pub type aws_secure_tunneling_on_stopped_fn =
    ::core::option::Option<unsafe extern "C" fn(user_data: *mut ::core::ffi::c_void)>;
#[doc = " Signature of callback to invoke on termination completion of the Native Secure Tunnel Client"]
pub type aws_secure_tunneling_on_termination_complete_fn =
    ::core::option::Option<unsafe extern "C" fn(user_data: *mut ::core::ffi::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_iotdevice_defender_task {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_iotdevice_defender_task_config {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_secure_tunnel {
    _unused: [u8; 0],
}
#[doc = " Read-only snapshot of a Secure Tunnel Message"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_secure_tunnel_message_view {
    pub type_: aws_secure_tunnel_message_type,
    #[doc = " If a message is received and its type is unrecognized, and this field is set to true, it is ok for the tunnel\n client to ignore the message safely. If this field is unset, it must be considered as false."]
    pub ignorable: bool,
    pub stream_id: i32,
    pub connection_id: u32,
    #[doc = " Secure tunnel multiplexing identifier"]
    pub service_id: *mut aws_byte_cursor,
    pub service_id_2: *mut aws_byte_cursor,
    pub service_id_3: *mut aws_byte_cursor,
    pub payload: *mut aws_byte_cursor,
}
#[doc = " Read-only snapshot of a Secure Tunnel Connection Completion Data"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_secure_tunnel_connection_view {
    pub service_id_1: *mut aws_byte_cursor,
    pub service_id_2: *mut aws_byte_cursor,
    pub service_id_3: *mut aws_byte_cursor,
}
#[doc = " Basic Secure Tunnel configuration struct.\n\n Contains connection properties for the creation of a Secure Tunnel"]
#[repr(C)]
pub struct aws_secure_tunnel_options {
    #[doc = " Host to establish Secure Tunnel connection to"]
    pub endpoint_host: aws_byte_cursor,
    #[doc = " Secure Tunnel bootstrap to use whenever Secure Tunnel establishes a connection"]
    pub bootstrap: *mut aws_client_bootstrap,
    #[doc = " Socket options to use whenever this Secure Tunnel establishes a connection"]
    pub socket_options: *mut aws_socket_options,
    #[doc = " (Optional) Tls options to use whenever this Secure Tunnel Client establishes a connection"]
    pub tls_options: *mut aws_tls_connection_options,
    #[doc = " (Optional) Http proxy options to use whenever this Secure Tunnel establishes a connection"]
    pub http_proxy_options: *const aws_http_proxy_options,
    #[doc = " Access Token used to establish a Secure Tunnel connection"]
    pub access_token: aws_byte_cursor,
    #[doc = " (Optional) Client Token used to re-establish a Secure Tunnel connection after the one-time use access token has\n been used. If one is not provided, it will automatically be generated and re-used on subsequent reconnects."]
    pub client_token: aws_byte_cursor,
    pub root_ca: *const ::core::ffi::c_char,
    pub on_message_received: aws_secure_tunnel_message_received_fn,
    pub user_data: *mut ::core::ffi::c_void,
    pub local_proxy_mode: aws_secure_tunneling_local_proxy_mode,
    pub on_connection_complete: aws_secure_tunneling_on_connection_complete_fn,
    pub on_connection_shutdown: aws_secure_tunneling_on_connection_shutdown_fn,
    pub on_send_message_complete: aws_secure_tunneling_on_send_message_complete_fn,
    pub on_stream_start: aws_secure_tunneling_on_stream_start_fn,
    pub on_stream_reset: aws_secure_tunneling_on_stream_reset_fn,
    pub on_connection_start: aws_secure_tunneling_on_connection_start_fn,
    pub on_connection_reset: aws_secure_tunneling_on_connection_reset_fn,
    pub on_session_reset: aws_secure_tunneling_on_session_reset_fn,
    pub on_stopped: aws_secure_tunneling_on_stopped_fn,
    #[doc = " Callback for when the secure tunnel has completely destroyed itself."]
    pub on_termination_complete: aws_secure_tunneling_on_termination_complete_fn,
    pub secure_tunnel_on_termination_user_data: *mut ::core::ffi::c_void,
}
pub const AWS_C_IOTDEVICE_PACKAGE_ID: u32 = 13;
pub const AWS_ERROR_IOTDEVICE_INVALID_RESERVED_BITS: aws_iotdevice_error = 13312;
pub const AWS_ERROR_IOTDEVICE_DEFENDER_INVALID_REPORT_INTERVAL: aws_iotdevice_error = 13313;
pub const AWS_ERROR_IOTDEVICE_DEFENDER_UNSUPPORTED_REPORT_FORMAT: aws_iotdevice_error = 13314;
pub const AWS_ERROR_IOTDEVICE_DEFENDER_REPORT_SERIALIZATION_FAILURE: aws_iotdevice_error = 13315;
pub const AWS_ERROR_IOTDEVICE_DEFENDER_UNKNOWN_CUSTOM_METRIC_TYPE: aws_iotdevice_error = 13316;
pub const AWS_ERROR_IOTDEVICE_DEFENDER_INVALID_TASK_CONFIG: aws_iotdevice_error = 13317;
pub const AWS_ERROR_IOTDEVICE_DEFENDER_PUBLISH_FAILURE: aws_iotdevice_error = 13318;
pub const AWS_ERROR_IOTDEVICE_DEFENDER_UNKNOWN_TASK_STATUS: aws_iotdevice_error = 13319;
pub const AWS_ERROR_IOTDEVICE_SECURE_TUNNELING_INVALID_STREAM_ID: aws_iotdevice_error = 13320;
pub const AWS_ERROR_IOTDEVICE_SECURE_TUNNELING_INVALID_CONNECTION_ID: aws_iotdevice_error = 13321;
pub const AWS_ERROR_IOTDEVICE_SECURE_TUNNELING_INVALID_SERVICE_ID: aws_iotdevice_error = 13322;
pub const AWS_ERROR_IOTDEVICE_SECURE_TUNNELING_INCORRECT_MODE: aws_iotdevice_error = 13323;
pub const AWS_ERROR_IOTDEVICE_SECURE_TUNNELING_BAD_SERVICE_ID: aws_iotdevice_error = 13324;
pub const AWS_ERROR_IOTDEVICE_SECURE_TUNNELING_DATA_OPTIONS_VALIDATION: aws_iotdevice_error = 13325;
pub const AWS_ERROR_IOTDEVICE_SECURE_TUNNELING_STREAM_OPTIONS_VALIDATION: aws_iotdevice_error =
    13326;
pub const AWS_ERROR_IOTDEVICE_SECURE_TUNNELING_SECURE_TUNNEL_TERMINATED: aws_iotdevice_error =
    13327;
pub const AWS_ERROR_IOTDEVICE_SECURE_TUNNELING_WEBSOCKET_TIMEOUT: aws_iotdevice_error = 13328;
pub const AWS_ERROR_IOTDEVICE_SECURE_TUNNELING_PING_RESPONSE_TIMEOUT: aws_iotdevice_error = 13329;
pub const AWS_ERROR_IOTDEVICE_SECURE_TUNNELING_OPERATION_FAILED_DUE_TO_DISCONNECTION:
    aws_iotdevice_error = 13330;
pub const AWS_ERROR_IOTDEVICE_SECURE_TUNNELING_OPERATION_PROCESSING_FAILURE: aws_iotdevice_error =
    13331;
pub const AWS_ERROR_IOTDEVICE_SECURE_TUNNELING_OPERATION_FAILED_DUE_TO_OFFLINE_QUEUE_POLICY:
    aws_iotdevice_error = 13332;
pub const AWS_ERROR_IOTDEVICE_SECURE_TUNNELING_UNEXPECTED_HANGUP: aws_iotdevice_error = 13333;
pub const AWS_ERROR_IOTDEVICE_SECURE_TUNNELING_USER_REQUESTED_STOP: aws_iotdevice_error = 13334;
pub const AWS_ERROR_IOTDEVICE_SECURE_TUNNELING_PROTOCOL_VERSION_MISSMATCH: aws_iotdevice_error =
    13335;
pub const AWS_ERROR_IOTDEVICE_SECURE_TUNNELING_PROTOCOL_VERSION_MISMATCH: aws_iotdevice_error =
    13335;
pub const AWS_ERROR_IOTDEVICE_SECURE_TUNNELING_TERMINATED: aws_iotdevice_error = 13336;
pub const AWS_ERROR_IOTDEVICE_SECURE_TUNNELING_DECODE_FAILURE: aws_iotdevice_error = 13337;
pub const AWS_ERROR_IOTDEVICE_SECURE_TUNNELING_DATA_NO_ACTIVE_CONNECTION: aws_iotdevice_error =
    13338;
pub const AWS_ERROR_IOTDEVICE_SECURE_TUNNELING_DATA_PROTOCOL_VERSION_MISMATCH: aws_iotdevice_error =
    13339;
pub const AWS_ERROR_IOTDEVICE_SECURE_TUNNELING_INACTIVE_SERVICE_ID: aws_iotdevice_error = 13340;
pub const AWS_ERROR_END_IOTDEVICE_RANGE: aws_iotdevice_error = 14335;
pub const AWS_LS_IOTDEVICE_DEFENDER_TASK: aws_iotdevice_log_subject = 13312;
pub const AWS_LS_IOTDEVICE_DEFENDER_TASK_CONFIG: aws_iotdevice_log_subject = 13313;
pub const AWS_LS_IOTDEVICE_NETWORK_CONFIG: aws_iotdevice_log_subject = 13314;
pub const AWS_LS_IOTDEVICE_SECURE_TUNNELING: aws_iotdevice_log_subject = 13315;
pub const AWS_IDDRF_JSON: aws_iotdevice_defender_report_format = 0;
pub const AWS_IDDRF_SHORT_JSON: aws_iotdevice_defender_report_format = 1;
pub const AWS_IDDRF_CBOR: aws_iotdevice_defender_report_format = 2;
pub const DD_METRIC_UNKNOWN: defender_custom_metric_type = 0;
pub const DD_METRIC_NUMBER: defender_custom_metric_type = 1;
pub const DD_METRIC_NUMBER_LIST: defender_custom_metric_type = 2;
pub const DD_METRIC_STRING_LIST: defender_custom_metric_type = 3;
pub const DD_METRIC_IP_LIST: defender_custom_metric_type = 4;
pub const AWS_SECURE_TUNNELING_SOURCE_MODE: aws_secure_tunneling_local_proxy_mode = 0;
pub const AWS_SECURE_TUNNELING_DESTINATION_MODE: aws_secure_tunneling_local_proxy_mode = 1;
pub const AWS_SECURE_TUNNEL_MT_UNKNOWN: aws_secure_tunnel_message_type = 0;
#[doc = " Data messages carry a payload with a sequence of bytes to write to the the active data stream"]
pub const AWS_SECURE_TUNNEL_MT_DATA: aws_secure_tunnel_message_type = 1;
#[doc = " StreamStart is the first message sent to start and establish a new and active data stream. This should only be\n sent from a Source to a Destination."]
pub const AWS_SECURE_TUNNEL_MT_STREAM_START: aws_secure_tunnel_message_type = 2;
#[doc = " StreamReset messages convey that the data stream has ended, either in error, or closed intentionally for the\n tunnel peer. It is also sent to the source tunnel peer if an attempt to establish a new data stream fails on the\n destination side."]
pub const AWS_SECURE_TUNNEL_MT_STREAM_RESET: aws_secure_tunnel_message_type = 3;
#[doc = " SessionReset messages can only originate from Secure Tunneling service if an internal data transmission error is\n detected. This will result in all active streams being closed."]
pub const AWS_SECURE_TUNNEL_MT_SESSION_RESET: aws_secure_tunnel_message_type = 4;
#[doc = " ServiceIDs messages can only originate from the Secure Tunneling service and carry a list of unique service IDs\n used when opening a tunnel with services."]
pub const AWS_SECURE_TUNNEL_MT_SERVICE_IDS: aws_secure_tunnel_message_type = 5;
#[doc = " ConnectionStart is the message sent to start and establish a new and active connection when the stream has been\n established and there's one active connection in the stream."]
pub const AWS_SECURE_TUNNEL_MT_CONNECTION_START: aws_secure_tunnel_message_type = 6;
#[doc = " ConnectionReset messages convey that the connection has ended, either in error, or closed intentionally for the\n tunnel peer. These should not be manually sent from either Destination or Source clients."]
pub const AWS_SECURE_TUNNEL_MT_CONNECTION_RESET: aws_secure_tunnel_message_type = 7;
extern "C" {
    #[doc = " Initializes internal datastructures used by aws-c-iot.\n Must be called before using any functionality in aws-c-iot."]
    pub fn aws_iotdevice_library_init(allocator: *mut aws_allocator);
    #[doc = " Shuts down the internal datastructures used by aws-c-iot"]
    pub fn aws_iotdevice_library_clean_up();
    #[doc = " Creates a new reporting task config for Device Defender metrics collection\n\n \\param[in]    config_out     output to write a pointer to a task configuration.\n                          Will write non-NULL if successful in creating the\n                          the task configuration. Will write NULL if there is\n                          an error during creation\n \\param[in]    allocator      allocator to use for the task configuration's\n                          internal data, and the task itself when started\n \\param[in]    thing_name     thing name the task config is reporting for\n \\param[in]    report_format  report format to produce when publishing to IoT\n \\returns  AWS_OP_SUCCESS and config_out will be non-NULL. Returns an error code\n                          otherwise"]
    pub fn aws_iotdevice_defender_config_create(
        config_out: *mut *mut aws_iotdevice_defender_task_config,
        allocator: *mut aws_allocator,
        thing_name: *const aws_byte_cursor,
        report_format: aws_iotdevice_defender_report_format,
    ) -> ::core::ffi::c_int;
    #[doc = " Destroys a new reporting task for Device Defender metrics\n\n \\param[in]    config    defender task configuration"]
    pub fn aws_iotdevice_defender_config_clean_up(config: *mut aws_iotdevice_defender_task_config);
    #[doc = " Sets the task failure callback function to invoke when the running of the\n task encounters a failure. Though this is optional to specify, it is\n important to register a handler to at least monitor failure that stops\n the task from running\n\n The most likely scenario for task not being able to continue is failure to reschedule the task\n\n \\param[in]    config        defender task configuration\n \\param[in]    failure_fn    failure callback function\n \\returns    AWS_OP_SUCCESS when the task failure callback has been\n             set. Returns an error if the callback was not set"]
    pub fn aws_iotdevice_defender_config_set_task_failure_fn(
        config: *mut aws_iotdevice_defender_task_config,
        failure_fn: aws_iotdevice_defender_task_failure_fn,
    ) -> ::core::ffi::c_int;
    #[doc = " Sets the task cancelation callback function to invoke when the task\n is canceled and not going to be scheduled to run. This is a suggestion\n of when it is OK to close or free resources kept around while the task\n is running.\n\n \\param[in]    config       defender task configuration\n \\param[in]    cancel_fn    cancelation callback function\n \\returns    AWS_OP_SUCCESS when the task cancelation callback has been\n             set. Returns an error if the callback was not set"]
    pub fn aws_iotdevice_defender_config_set_task_cancelation_fn(
        config: *mut aws_iotdevice_defender_task_config,
        cancel_fn: aws_iotdevice_defender_task_canceled_fn,
    ) -> ::core::ffi::c_int;
    #[doc = " Sets the report rejected callback function to invoke when\n is canceled and not going to be scheduled to run. This is a suggestion\n of when it is OK to close or free resources kept around while the task\n is running.\n\n \\param[in]    config         defender task configuration\n \\param[in]    accepted_fn    accepted report callback function\n \\returns    AWS_OP_SUCCESS when the report accepted callback has been\n             set. Returns an error if the callback was not set"]
    pub fn aws_iotdevice_defender_config_set_report_accepted_fn(
        config: *mut aws_iotdevice_defender_task_config,
        accepted_fn: aws_iotdevice_defender_report_accepted_fn,
    ) -> ::core::ffi::c_int;
    #[doc = " Sets the report rejected callback function to invoke when\n is canceled and not going to be scheduled to run. This is a suggestion\n of when it is OK to close or free resources kept around while the task\n is running.\n\n \\param[in]    config         defender task configuration\n \\param[in]    rejected_fn    rejected report callback function\n \\returns    AWS_OP_SUCCESS when the report rejected callback has been\n             set. Returns an error if the callback was not set"]
    pub fn aws_iotdevice_defender_config_set_report_rejected_fn(
        config: *mut aws_iotdevice_defender_task_config,
        rejected_fn: aws_iotdevice_defender_report_rejected_fn,
    ) -> ::core::ffi::c_int;
    #[doc = " Sets the period of the device defender task\n\n \\param[in]    config            defender task configuration\n \\param[in]    task_period_ns    how much time in nanoseconds between defender\n                             task runs\n \\returns   AWS_OP_SUCCESS when the property has been set properly. Returns\n            an error code if the value was not able to be set."]
    pub fn aws_iotdevice_defender_config_set_task_period_ns(
        config: *mut aws_iotdevice_defender_task_config,
        task_period_ns: u64,
    ) -> ::core::ffi::c_int;
    #[doc = " Sets the userdata for the device defender task's callback functions\n\n \\param[in]    config      defender task configuration\n \\param[in]    userdata    how much time in nanoseconds between defender\n                       task runs\n \\returns   AWS_OP_SUCCESS when the property has been set properly. Returns\n            an error code if the value was not able to be set"]
    pub fn aws_iotdevice_defender_config_set_callback_userdata(
        config: *mut aws_iotdevice_defender_task_config,
        userdata: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    #[doc = " Adds number custom metric to the Device Defender task configuration.\n Has no impact on a defender task already started using the configuration.\n\n \\param[in]    task_config    the defender task configuration to register the metric to\n \\param[in]    metric_name    UTF8 byte string of the metric name\n \\param[in]    supplier       callback function to produce the metric value when\n                          requested at report generation time\n \\param[in]    userdata       specific callback data for the supplier callback function"]
    pub fn aws_iotdevice_defender_config_register_number_metric(
        task_config: *mut aws_iotdevice_defender_task_config,
        metric_name: *const aws_byte_cursor,
        supplier: aws_iotdevice_defender_get_number_fn,
        userdata: *mut ::core::ffi::c_void,
    );
    #[doc = " Adds number list custom metric to the Device Defender task configuration.\n Has no impact on a defender task already started using the configuration.\n\n \\param[in]    task_config    the defender task configuration to register the metric to\n \\param[in]    metric_name    UTF8 byte string of the metric name\n \\param[in]    supplier       callback function to produce the metric value when\n                          requested at report generation time\n \\param[in]    userdata       specific callback data for the supplier callback function"]
    pub fn aws_iotdevice_defender_config_register_number_list_metric(
        task_config: *mut aws_iotdevice_defender_task_config,
        metric_name: *const aws_byte_cursor,
        supplier: aws_iotdevice_defender_get_number_list_fn,
        userdata: *mut ::core::ffi::c_void,
    );
    #[doc = " Adds string list custom metric to the Device Defender task configuration.\n Has no impact on a defender task already started using the configuration.\n\n \\param[in]    task_config    the defender task configuration to register the metric to\n \\param[in]    metric_name    UTF8 byte string of the metric name\n \\param[in]    supplier       callback function to produce the metric value when\n                          requested at report generation time\n \\param[in]    userdata       specific callback data for the supplier callback function"]
    pub fn aws_iotdevice_defender_config_register_string_list_metric(
        task_config: *mut aws_iotdevice_defender_task_config,
        metric_name: *const aws_byte_cursor,
        supplier: aws_iotdevice_defender_get_string_list_fn,
        userdata: *mut ::core::ffi::c_void,
    );
    #[doc = " Adds IP list custom metric to the Device Defender task configuration.\n Has no impact on a defender task already started using the configuration.\n\n \\param[in]    task_config    the defender task configuration to register the metric to\n \\param[in]    metric_name    UTF8 byte string of the metric name\n \\param[in]    supplier       callback function to produce the metric value when\n                          requested at report generation time\n \\param[in]    userdata       specific callback data for the supplier callback function"]
    pub fn aws_iotdevice_defender_config_register_ip_list_metric(
        task_config: *mut aws_iotdevice_defender_task_config,
        metric_name: *const aws_byte_cursor,
        supplier: aws_iotdevice_defender_get_ip_list_fn,
        userdata: *mut ::core::ffi::c_void,
    );
    #[doc = " Creates and starts a new Device Defender reporting task\n\n \\param[out]    task_out      output parameter to set to point to the defender task\n \\param[in]    config        defender task configuration to use to start the task\n \\param[in]    connection    mqtt connection to use to publish reports to\n \\param[in]    event_loop    IoT device thing name used to determine the MQTT\n                         topic to publish the report to and listen for accepted\n                         or rejected responses\n \\returns AWS_OP_SUCCESS if the task has been created successfully and is scheduled\n          to run"]
    pub fn aws_iotdevice_defender_task_create(
        task_out: *mut *mut aws_iotdevice_defender_task,
        config: *const aws_iotdevice_defender_task_config,
        connection: *mut aws_mqtt_client_connection,
        event_loop: *mut aws_event_loop,
    ) -> ::core::ffi::c_int;
    #[doc = " Creates and starts a new Device Defender reporting task with the ability to define\n a function to accept/handle each report when the task needs to publish.\n\n \\param[out]    task_out      output parameter to set to point to the defender task\n \\param[in]    config        defender task configuration to use to start the task\n \\param[in]    publish_fn    callback to handle reports generated by the task. The\n                         userdata comes from the task config\n \\param[in]    event_loop    IoT device thing name used to determine the MQTT\n                         topic to publish the report to and listen for accepted\n                         or rejected responses\n \\returns AWS_OP_SUCCESS if the task has been created successfully and is scheduled\n          to run"]
    pub fn aws_iotdevice_defender_task_create_ex(
        task_out: *mut *mut aws_iotdevice_defender_task,
        config: *const aws_iotdevice_defender_task_config,
        publish_fn: aws_iotdevice_defender_publish_fn,
        event_loop: *mut aws_event_loop,
    ) -> ::core::ffi::c_int;
    #[doc = " Cancels the running task reporting Device Defender metrics and cleans up.\n If the task is currently running, it will block until the task has been\n canceled and cleaned up successfully\n\n \\param[in]    defender_task running task to stop and clean up"]
    pub fn aws_iotdevice_defender_task_clean_up(defender_task: *mut aws_iotdevice_defender_task);
    #[doc = " Creates a new secure tunnel\n\n @param options secure tunnel configuration\n @return a new secure tunnel or NULL"]
    pub fn aws_secure_tunnel_new(
        allocator: *mut aws_allocator,
        options: *const aws_secure_tunnel_options,
    ) -> *mut aws_secure_tunnel;
    #[doc = " Acquires a reference to a secure tunnel\n\n @param secure_tunnel secure tunnel to acquire a reference to. May be NULL\n @return what was passed in as the secure tunnel (a client or NULL)"]
    pub fn aws_secure_tunnel_acquire(
        secure_tunnel: *mut aws_secure_tunnel,
    ) -> *mut aws_secure_tunnel;
    #[doc = " Release a reference to a secure tunnel. When the secure tunnel ref count drops to zero, the secure tunnel\n will automatically trigger a stop and once the stop completes, the secure tunnel will delete itself.\n\n @param secure_tunnel secure tunnel to release a reference to. May be NULL\n @return NULL"]
    pub fn aws_secure_tunnel_release(
        secure_tunnel: *mut aws_secure_tunnel,
    ) -> *mut aws_secure_tunnel;
    #[doc = " Asynchronous notify to the secure tunnel that you want it to attempt to connect.\n The secure tunnel will attempt to stay connected.\n\n @param secure_tunnel secure tunnel to start\n @return success/failure in the synchronous logic that kicks off the start process"]
    pub fn aws_secure_tunnel_start(secure_tunnel: *mut aws_secure_tunnel) -> ::core::ffi::c_int;
    #[doc = " Asynchronous notify to the secure tunnel that you want it to transition to the stopped state. When the\n secure tunnel reaches the stopped state, all session state is erased.\n\n @param secure_tunnel secure tunnel to stop\n @return success/failure in the synchronous logic that kicks off the start process"]
    pub fn aws_secure_tunnel_stop(secure_tunnel: *mut aws_secure_tunnel) -> ::core::ffi::c_int;
    #[doc = " Queues a message operation in a secure tunnel\n\n @param secure_tunnel secure tunnel to queue a message for\n @param message_options configuration options for the message operation\n @return success/failure in the synchronous logic that kicks off the message operation"]
    pub fn aws_secure_tunnel_send_message(
        secure_tunnel: *mut aws_secure_tunnel,
        message_options: *const aws_secure_tunnel_message_view,
    ) -> ::core::ffi::c_int;
    #[doc = " Get the const char description of a message type\n\n @param message_type message type used by a secure tunnel message\n @return const char translation of the message type"]
    pub fn aws_secure_tunnel_message_type_to_c_string(
        message_type: aws_secure_tunnel_message_type,
    ) -> *const ::core::ffi::c_char;
    #[doc = " Queue a STREAM_START message in a secure tunnel\n @note This function should only be used from source mode.\n @param secure_tunnel secure tunnel to queue a message for\n @param message_options configuration options for the message operation\n @return success/failure in the synchronous logic that kicks off the message operation"]
    pub fn aws_secure_tunnel_stream_start(
        secure_tunnel: *mut aws_secure_tunnel,
        message_options: *const aws_secure_tunnel_message_view,
    ) -> ::core::ffi::c_int;
    #[doc = " Queue a CONNECTION_START message in a secure tunnel\n @note This function should only be used from source mode.\n @param secure_tunnel secure tunnel to queue a message for\n @param message_options configuration options for the message operation\n @return success/failure in the synchronous logic that kicks off the message operation"]
    pub fn aws_secure_tunnel_connection_start(
        secure_tunnel: *mut aws_secure_tunnel,
        message_options: *const aws_secure_tunnel_message_view,
    ) -> ::core::ffi::c_int;
    #[doc = " Queue a STREAM_RESET message in a secure tunnel\n @deprecated This function should not be used.\n @param secure_tunnel secure tunnel to queue a message for\n @param message_options configuration options for the message operation\n @return success/failure in the synchronous logic that kicks off the message operation"]
    pub fn aws_secure_tunnel_stream_reset(
        secure_tunnel: *mut aws_secure_tunnel,
        message_options: *const aws_secure_tunnel_message_view,
    ) -> ::core::ffi::c_int;
}
