/* automatically generated by rust-bindgen 0.69.1 */

pub type aws_mqtt_qos = ::core::ffi::c_uint;
pub type aws_mqtt_connect_return_code = ::core::ffi::c_uint;
pub type aws_mqtt_error = ::core::ffi::c_uint;
pub type aws_mqtt_log_subject = ::core::ffi::c_uint;
#[doc = " Function called on cleanup of a userdata."]
pub type aws_mqtt_userdata_cleanup_fn =
    ::core::option::Option<unsafe extern "C" fn(userdata: *mut ::core::ffi::c_void)>;
#[doc = " Callback called when a request roundtrip is complete (QoS0 immediately, QoS1 on PUBACK, QoS2 on PUBCOMP). Either\n succeed or not"]
pub type aws_mqtt_op_complete_fn = ::core::option::Option<
    unsafe extern "C" fn(
        connection: *mut aws_mqtt_client_connection,
        packet_id: u16,
        error_code: ::core::ffi::c_int,
        userdata: *mut ::core::ffi::c_void,
    ),
>;
#[doc = " Called when a connection attempt is completed, either in success or error.\n\n If error code is AWS_ERROR_SUCCESS, then a CONNACK has been received from the server and return_code and\n session_present contain the values received. If error_code is not AWS_ERROR_SUCCESS, it refers to the internal error\n that occurred during connection, and return_code and session_present are invalid."]
pub type aws_mqtt_client_on_connection_complete_fn = ::core::option::Option<
    unsafe extern "C" fn(
        connection: *mut aws_mqtt_client_connection,
        error_code: ::core::ffi::c_int,
        return_code: aws_mqtt_connect_return_code,
        session_present: bool,
        userdata: *mut ::core::ffi::c_void,
    ),
>;
pub type aws_mqtt_client_on_connection_success_fn = ::core::option::Option<
    unsafe extern "C" fn(
        connection: *mut aws_mqtt_client_connection,
        return_code: aws_mqtt_connect_return_code,
        session_present: bool,
        userdata: *mut ::core::ffi::c_void,
    ),
>;
pub type aws_mqtt_client_on_connection_failure_fn = ::core::option::Option<
    unsafe extern "C" fn(
        connection: *mut aws_mqtt_client_connection,
        error_code: ::core::ffi::c_int,
        userdata: *mut ::core::ffi::c_void,
    ),
>;
pub type aws_mqtt_client_on_connection_interrupted_fn = ::core::option::Option<
    unsafe extern "C" fn(
        connection: *mut aws_mqtt_client_connection,
        error_code: ::core::ffi::c_int,
        userdata: *mut ::core::ffi::c_void,
    ),
>;
#[doc = " Called if the connection to the server is closed by user request\n Note: Currently the \"data\" argument is always NULL, but this may change in the future if additional data is needed to\n be sent."]
pub type aws_mqtt_client_on_connection_closed_fn = ::core::option::Option<
    unsafe extern "C" fn(
        connection: *mut aws_mqtt_client_connection,
        data: *mut on_connection_closed_data,
        userdata: *mut ::core::ffi::c_void,
    ),
>;
#[doc = " Called when a connection to the server is resumed\n (if clean_session is true, calling aws_mqtt_resubscribe_existing_topics is suggested)"]
pub type aws_mqtt_client_on_connection_resumed_fn = ::core::option::Option<
    unsafe extern "C" fn(
        connection: *mut aws_mqtt_client_connection,
        return_code: aws_mqtt_connect_return_code,
        session_present: bool,
        userdata: *mut ::core::ffi::c_void,
    ),
>;
#[doc = " Called when a multi-topic subscription request is complete.\n Note: If any topic_suback's qos value is AWS_MQTT_QOS_FAILURE,\n then that topic subscription was rejected by the broker."]
pub type aws_mqtt_suback_multi_fn = ::core::option::Option<
    unsafe extern "C" fn(
        connection: *mut aws_mqtt_client_connection,
        packet_id: u16,
        topic_subacks: *const aws_array_list,
        error_code: ::core::ffi::c_int,
        userdata: *mut ::core::ffi::c_void,
    ),
>;
#[doc = " Called when a single-topic subscription request is complete.\n Note: If the qos value is AWS_MQTT_QOS_FAILURE,\n then the subscription was rejected by the broker."]
pub type aws_mqtt_suback_fn = ::core::option::Option<
    unsafe extern "C" fn(
        connection: *mut aws_mqtt_client_connection,
        packet_id: u16,
        topic: *const aws_byte_cursor,
        qos: aws_mqtt_qos,
        error_code: ::core::ffi::c_int,
        userdata: *mut ::core::ffi::c_void,
    ),
>;
#[doc = " Called when a publish message is received.\n\n \\param[in] connection    The connection object\n \\param[in] topic         The information channel to which the payload data was published.\n \\param[in] payload       The payload data.\n \\param[in] dup           DUP flag. If true, this might be re-delivery of an earlier attempt to send the message.\n \\param[in] qos           Quality of Service used to deliver the message.\n \\param[in] retain        Retain flag. If true, the message was sent as a result of a new subscription being\n                          made by the client."]
pub type aws_mqtt_client_publish_received_fn = ::core::option::Option<
    unsafe extern "C" fn(
        connection: *mut aws_mqtt_client_connection,
        topic: *const aws_byte_cursor,
        payload: *const aws_byte_cursor,
        dup: bool,
        qos: aws_mqtt_qos,
        retain: bool,
        userdata: *mut ::core::ffi::c_void,
    ),
>;
#[doc = " Called when a connection is closed, right before any resources are deleted"]
pub type aws_mqtt_client_on_disconnect_fn = ::core::option::Option<
    unsafe extern "C" fn(
        connection: *mut aws_mqtt_client_connection,
        userdata: *mut ::core::ffi::c_void,
    ),
>;
#[doc = " Signature of callback invoked on a connection destruction."]
pub type aws_mqtt_client_on_connection_termination_fn =
    ::core::option::Option<unsafe extern "C" fn(userdata: *mut ::core::ffi::c_void)>;
#[doc = " Function to invoke when the websocket handshake request transformation completes.\n This function MUST be invoked or the application will soft-lock.\n\n `request` and `complete_ctx` must be the same pointers provided to the `aws_mqtt_transform_websocket_handshake_fn`.\n `error_code` should should be AWS_ERROR_SUCCESS if transformation was successful,\n otherwise pass a different AWS_ERROR_X value."]
pub type aws_mqtt_transform_websocket_handshake_complete_fn = ::core::option::Option<
    unsafe extern "C" fn(
        request: *mut aws_http_message,
        error_code: ::core::ffi::c_int,
        complete_ctx: *mut ::core::ffi::c_void,
    ),
>;
#[doc = " Function that may transform the websocket handshake request.\n Called each time a websocket connection is attempted.\n\n The default request uses path \"/mqtt\". All required headers are present,\n plus the optional header \"Sec-WebSocket-Protocol: mqtt\".\n\n The user MUST invoke the `complete_fn` when transformation is complete or the application will soft-lock.\n When invoking the `complete_fn`, pass along the `request` and `complete_ctx` provided here and an error code.\n The error code should be AWS_ERROR_SUCCESS if transformation was successful,\n otherwise pass a different AWS_ERROR_X value."]
pub type aws_mqtt_transform_websocket_handshake_fn = ::core::option::Option<
    unsafe extern "C" fn(
        request: *mut aws_http_message,
        user_data: *mut ::core::ffi::c_void,
        complete_fn: aws_mqtt_transform_websocket_handshake_complete_fn,
        complete_ctx: *mut ::core::ffi::c_void,
    ),
>;
#[doc = " Function that may accept or reject a websocket handshake response.\n Called each time a valid websocket connection is established.\n\n All required headers have been checked already (ex: \"Sec-Websocket-Accept\"),\n\n Return AWS_OP_SUCCESS to accept the connection or AWS_OP_ERR to stop the connection attempt."]
pub type aws_mqtt_validate_websocket_handshake_fn = ::core::option::Option<
    unsafe extern "C" fn(
        connection: *mut aws_mqtt_client_connection,
        header_array: *const aws_http_header,
        num_headers: usize,
        userdata: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int,
>;
#[doc = " Over-the-wire packet id as defined in the mqtt spec.  Allocated at the point in time when the packet is\n is next to go down the channel and about to be encoded into an io message buffer.\n\n https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901026"]
pub type aws_mqtt5_packet_id_t = u16;
#[doc = " MQTT Message delivery quality of service.\n Enum values match mqtt spec encoding values.\n\n https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901234"]
pub type aws_mqtt5_qos = ::core::ffi::c_uint;
#[doc = " Server return code for CONNECT attempts.\n Enum values match mqtt spec encoding values.\n\n https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901079"]
pub type aws_mqtt5_connect_reason_code = ::core::ffi::c_uint;
#[doc = " Reason code inside DISCONNECT packets.\n Enum values match mqtt spec encoding values.\n\n https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901208"]
pub type aws_mqtt5_disconnect_reason_code = ::core::ffi::c_uint;
#[doc = " Reason code inside PUBACK packets.\n Enum values match mqtt spec encoding values.\n\n https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901124"]
pub type aws_mqtt5_puback_reason_code = ::core::ffi::c_uint;
#[doc = " Reason code inside SUBACK packet payloads.\n Enum values match mqtt spec encoding values.\n\n https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901178"]
pub type aws_mqtt5_suback_reason_code = ::core::ffi::c_uint;
#[doc = " Reason code inside UNSUBACK packet payloads.\n Enum values match mqtt spec encoding values.\n\n https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901194"]
pub type aws_mqtt5_unsuback_reason_code = ::core::ffi::c_uint;
#[doc = " Type of mqtt packet.\n Enum values match mqtt spec encoding values.\n\n https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901022"]
pub type aws_mqtt5_packet_type = ::core::ffi::c_int;
#[doc = " Optional property describing a message's payload format.\n Enum values match mqtt spec encoding values.\n\n https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901063"]
pub type aws_mqtt5_payload_format_indicator = ::core::ffi::c_uint;
#[doc = " Configures how retained messages should be handled when subscribing with a topic filter that matches topics with\n associated retained messages.\n\n https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169"]
pub type aws_mqtt5_retain_handling_type = ::core::ffi::c_uint;
#[doc = " Controls how the mqtt client should behave with respect to mqtt sessions."]
pub type aws_mqtt5_client_session_behavior_type = ::core::ffi::c_uint;
#[doc = " Outbound topic aliasing behavior is controlled by this type.\n\n Topic alias behavior is described in https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901113\n\n If the server allows topic aliasing, this setting controls how topic aliases are used on PUBLISH packets sent\n from the client to the server.\n\n If topic aliasing is not supported by the server, this setting has no effect and any attempts to directly\n manipulate the topic alias id in outbound publishes will be ignored."]
pub type aws_mqtt5_client_outbound_topic_alias_behavior_type = ::core::ffi::c_uint;
#[doc = " Inbound topic aliasing behavior is controlled by this type.\n\n Topic alias behavior is described in https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901113\n\n This setting controls whether or not the client will send a positive topic alias maximum to the server\n in its CONNECT packets.\n\n If topic aliasing is not supported by the server, this setting has no net effect."]
pub type aws_mqtt5_client_inbound_topic_alias_behavior_type = ::core::ffi::c_uint;
#[doc = " Extended validation and flow control options\n\n Potentially a point of expansion in the future.  We could add custom controls letting people override\n the Aws IOT Core limits based on their account properties.  We could, with IoT Core support, add dynamic\n limit recognition via user properties as well."]
pub type aws_mqtt5_extended_validation_and_flow_control_options = ::core::ffi::c_uint;
#[doc = " Controls how disconnects affect the queued and in-progress operations submitted to the client. Also controls\n how operations are handled while the client is not connected.  In particular, if the client is not connected,\n then any operation that would be failed on disconnect (according to these rules) will be rejected."]
pub type aws_mqtt5_client_operation_queue_behavior_type = ::core::ffi::c_uint;
#[doc = " Type of a client lifecycle event"]
pub type aws_mqtt5_client_lifecycle_event_type = ::core::ffi::c_uint;
#[doc = " Signature of the continuation function to be called after user-code transforms a websocket handshake request"]
pub type aws_mqtt5_transform_websocket_handshake_complete_fn = ::core::option::Option<
    unsafe extern "C" fn(
        request: *mut aws_http_message,
        error_code: ::core::ffi::c_int,
        complete_ctx: *mut ::core::ffi::c_void,
    ),
>;
#[doc = " Signature of the websocket handshake request transformation function.  After transformation, the completion\n function must be invoked to send the request."]
pub type aws_mqtt5_transform_websocket_handshake_fn = ::core::option::Option<
    unsafe extern "C" fn(
        request: *mut aws_http_message,
        user_data: *mut ::core::ffi::c_void,
        complete_fn: aws_mqtt5_transform_websocket_handshake_complete_fn,
        complete_ctx: *mut ::core::ffi::c_void,
    ),
>;
#[doc = " Callback signature for mqtt5 client lifecycle events."]
pub type aws_mqtt5_client_connection_event_callback_fn =
    ::core::option::Option<unsafe extern "C" fn(event: *const aws_mqtt5_client_lifecycle_event)>;
#[doc = " Signature of callback to invoke on Publish success/failure."]
pub type aws_mqtt5_publish_completion_fn = ::core::option::Option<
    unsafe extern "C" fn(
        packet_type: aws_mqtt5_packet_type,
        packet: *const ::core::ffi::c_void,
        error_code: ::core::ffi::c_int,
        complete_ctx: *mut ::core::ffi::c_void,
    ),
>;
#[doc = " Signature of callback to invoke on Subscribe success/failure."]
pub type aws_mqtt5_subscribe_completion_fn = ::core::option::Option<
    unsafe extern "C" fn(
        suback: *const aws_mqtt5_packet_suback_view,
        error_code: ::core::ffi::c_int,
        complete_ctx: *mut ::core::ffi::c_void,
    ),
>;
#[doc = " Signature of callback to invoke on Unsubscribe success/failure."]
pub type aws_mqtt5_unsubscribe_completion_fn = ::core::option::Option<
    unsafe extern "C" fn(
        unsuback: *const aws_mqtt5_packet_unsuback_view,
        error_code: ::core::ffi::c_int,
        complete_ctx: *mut ::core::ffi::c_void,
    ),
>;
#[doc = " Signature of callback to invoke on Publish received"]
pub type aws_mqtt5_publish_received_fn = ::core::option::Option<
    unsafe extern "C" fn(
        publish: *const aws_mqtt5_packet_publish_view,
        user_data: *mut ::core::ffi::c_void,
    ),
>;
#[doc = " Signature of a listener publish received callback that returns an indicator whether or not the publish\n was handled by the listener."]
pub type aws_mqtt5_listener_publish_received_fn = ::core::option::Option<
    unsafe extern "C" fn(
        publish: *const aws_mqtt5_packet_publish_view,
        user_data: *mut ::core::ffi::c_void,
    ) -> bool,
>;
#[doc = " Signature of callback to invoke when a DISCONNECT is fully written to the socket (or fails to be)"]
pub type aws_mqtt5_disconnect_completion_fn = ::core::option::Option<
    unsafe extern "C" fn(error_code: ::core::ffi::c_int, complete_ctx: *mut ::core::ffi::c_void),
>;
#[doc = " Signature of callback invoked when a client has completely destroyed itself"]
pub type aws_mqtt5_client_termination_completion_fn =
    ::core::option::Option<unsafe extern "C" fn(complete_ctx: *mut ::core::ffi::c_void)>;
pub type aws_mqtt5_listener_termination_completion_fn =
    ::core::option::Option<unsafe extern "C" fn(complete_ctx: *mut ::core::ffi::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_mqtt5_client {
    _unused: [u8; 0],
}
#[doc = " Empty struct that is passed when on_connection_closed is called.\n Currently holds nothing but will allow expanding in the future should it be needed."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct on_connection_closed_data {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct aws_mqtt_client {
    pub allocator: *mut aws_allocator,
    pub bootstrap: *mut aws_client_bootstrap,
    pub ref_count: aws_ref_count,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_mqtt_client_connection {
    _unused: [u8; 0],
}
#[doc = " Passed to subscribe() and suback callbacks"]
#[repr(C)]
pub struct aws_mqtt_topic_subscription {
    pub topic: aws_byte_cursor,
    pub qos: aws_mqtt_qos,
    pub on_publish: aws_mqtt_client_publish_received_fn,
    pub on_cleanup: aws_mqtt_userdata_cleanup_fn,
    pub on_publish_ud: *mut ::core::ffi::c_void,
}
#[doc = " host_name                 The server name to connect to. This resource may be freed immediately on return.\n port                      The port on the server to connect to\n client_id                 The clientid to place in the CONNECT packet.\n socket_options            The socket options to pass to the aws_client_bootstrap functions.\n                           This is copied into the connection\n tls_options               TLS settings to use when opening a connection.\n                           This is copied into the connection\n                           Pass NULL to connect without TLS (NOT RECOMMENDED)\n clean_session             True to discard all server session data and start fresh\n keep_alive_time_secs      The keep alive value to place in the CONNECT PACKET, a PING will automatically\n                           be sent at this interval as well. If you specify 0, defaults will be used\n                           and a ping will be sent once per 20 minutes.\n                           This duration must be longer than ping_timeout_ms.\n ping_timeout_ms           Network connection is re-established if a ping response is not received\n                           within this amount of time (milliseconds). If you specify 0, a default value of 3 seconds\n                           is used. Alternatively, tcp keep-alive may be away to accomplish this in a more efficient\n                           (low-power) scenario, but keep-alive options may not work the same way on every platform\n                           and OS version. This duration must be shorter than keep_alive_time_secs.\n protocol_operation_timeout_ms\n                           Timeout when waiting for the response to some operation requires response by protocol.\n                           Set to zero to disable timeout. Otherwise, the operation will fail with error\n                           AWS_ERROR_MQTT_TIMEOUT if no response is received within this amount of time after\n                           the packet is written to the socket. The timer is reset if the connection is interrupted.\n                           It applied to PUBLISH (QoS>0) and UNSUBSCRIBE now.\n                           Note: While the MQTT 3 specification states that a broker MUST respond,\n                           some brokers are known to ignore publish packets in exceptional circumstances\n                           (e.g. AWS IoT Core will not respond if the publish quota is exceeded).\n on_connection_complete    The callback to fire when the connection attempt completes\n user_data                 Passed to the userdata param of on_connection_complete"]
#[repr(C)]
pub struct aws_mqtt_connection_options {
    pub host_name: aws_byte_cursor,
    pub port: u32,
    pub socket_options: *mut aws_socket_options,
    pub tls_options: *mut aws_tls_connection_options,
    pub client_id: aws_byte_cursor,
    pub keep_alive_time_secs: u16,
    pub ping_timeout_ms: u32,
    pub protocol_operation_timeout_ms: u32,
    pub on_connection_complete: aws_mqtt_client_on_connection_complete_fn,
    pub user_data: *mut ::core::ffi::c_void,
    pub clean_session: bool,
}
#[doc = " Contains some simple statistics about the current state of the connection's queue of operations"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_mqtt_connection_operation_statistics {
    #[doc = " total number of operations submitted to the connection that have not yet been completed.  Unacked operations\n are a subset of this."]
    pub incomplete_operation_count: u64,
    #[doc = " total packet size of operations submitted to the connection that have not yet been completed.  Unacked operations\n are a subset of this."]
    pub incomplete_operation_size: u64,
    #[doc = " total number of operations that have been sent to the server and are waiting for a corresponding ACK before\n they can be completed."]
    pub unacked_operation_count: u64,
    #[doc = " total packet size of operations that have been sent to the server and are waiting for a corresponding ACK before\n they can be completed."]
    pub unacked_operation_size: u64,
}
#[doc = " Non-persistent representation of an mqtt5 user property."]
#[repr(C)]
pub struct aws_mqtt5_user_property {
    pub name: aws_byte_cursor,
    pub value: aws_byte_cursor,
}
#[doc = " Configures a single subscription within a Subscribe operation"]
#[repr(C)]
pub struct aws_mqtt5_subscription_view {
    #[doc = " Topic filter to subscribe to"]
    pub topic_filter: aws_byte_cursor,
    #[doc = " Maximum QOS that the subscriber will accept messages for.  Negotiated QoS may be different."]
    pub qos: aws_mqtt5_qos,
    #[doc = " Should the server not send publishes to a client when that client was the one who sent the publish?"]
    pub no_local: bool,
    #[doc = " Should messages sent due to this subscription keep the retain flag preserved on the message?"]
    pub retain_as_published: bool,
    #[doc = " Should retained messages on matching topics be sent in reaction to this subscription?"]
    pub retain_handling_type: aws_mqtt5_retain_handling_type,
}
#[doc = " Read-only snapshot of a DISCONNECT packet\n\n https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901205"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_mqtt5_packet_disconnect_view {
    pub reason_code: aws_mqtt5_disconnect_reason_code,
    pub session_expiry_interval_seconds: *const u32,
    pub reason_string: *const aws_byte_cursor,
    pub user_property_count: usize,
    pub user_properties: *const aws_mqtt5_user_property,
    pub server_reference: *const aws_byte_cursor,
}
#[doc = " Read-only snapshot of a SUBSCRIBE packet\n\n https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_mqtt5_packet_subscribe_view {
    pub packet_id: aws_mqtt5_packet_id_t,
    pub subscription_count: usize,
    pub subscriptions: *const aws_mqtt5_subscription_view,
    pub subscription_identifier: *const u32,
    pub user_property_count: usize,
    pub user_properties: *const aws_mqtt5_user_property,
}
#[doc = " Read-only snapshot of an UNSUBSCRIBE packet\n\n https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_mqtt5_packet_unsubscribe_view {
    pub packet_id: aws_mqtt5_packet_id_t,
    pub topic_filter_count: usize,
    pub topic_filters: *const aws_byte_cursor,
    pub user_property_count: usize,
    pub user_properties: *const aws_mqtt5_user_property,
}
#[doc = " Read-only snapshot of a PUBLISH packet.  Used both in configuration of a publish operation and callback\n data in message receipt.\n\n https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901100"]
#[repr(C)]
pub struct aws_mqtt5_packet_publish_view {
    pub payload: aws_byte_cursor,
    pub packet_id: aws_mqtt5_packet_id_t,
    pub qos: aws_mqtt5_qos,
    pub duplicate: bool,
    pub retain: bool,
    pub topic: aws_byte_cursor,
    pub payload_format: *const aws_mqtt5_payload_format_indicator,
    pub message_expiry_interval_seconds: *const u32,
    pub topic_alias: *const u16,
    pub response_topic: *const aws_byte_cursor,
    pub correlation_data: *const aws_byte_cursor,
    pub subscription_identifier_count: usize,
    pub subscription_identifiers: *const u32,
    pub content_type: *const aws_byte_cursor,
    pub user_property_count: usize,
    pub user_properties: *const aws_mqtt5_user_property,
}
#[doc = " Read-only snapshot of a CONNECT packet\n\n https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901033"]
#[repr(C)]
pub struct aws_mqtt5_packet_connect_view {
    pub keep_alive_interval_seconds: u16,
    pub client_id: aws_byte_cursor,
    pub username: *const aws_byte_cursor,
    pub password: *const aws_byte_cursor,
    pub clean_start: bool,
    pub session_expiry_interval_seconds: *const u32,
    pub request_response_information: *const u8,
    pub request_problem_information: *const u8,
    pub receive_maximum: *const u16,
    pub topic_alias_maximum: *const u16,
    pub maximum_packet_size_bytes: *const u32,
    pub will_delay_interval_seconds: *const u32,
    pub will: *const aws_mqtt5_packet_publish_view,
    pub user_property_count: usize,
    pub user_properties: *const aws_mqtt5_user_property,
    pub authentication_method: *const aws_byte_cursor,
    pub authentication_data: *const aws_byte_cursor,
}
#[doc = " Read-only snapshot of a CONNACK packet.\n\n https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901074"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_mqtt5_packet_connack_view {
    pub session_present: bool,
    pub reason_code: aws_mqtt5_connect_reason_code,
    pub session_expiry_interval: *const u32,
    pub receive_maximum: *const u16,
    pub maximum_qos: *const aws_mqtt5_qos,
    pub retain_available: *const bool,
    pub maximum_packet_size: *const u32,
    pub assigned_client_identifier: *const aws_byte_cursor,
    pub topic_alias_maximum: *const u16,
    pub reason_string: *const aws_byte_cursor,
    pub user_property_count: usize,
    pub user_properties: *const aws_mqtt5_user_property,
    pub wildcard_subscriptions_available: *const bool,
    pub subscription_identifiers_available: *const bool,
    pub shared_subscriptions_available: *const bool,
    pub server_keep_alive: *const u16,
    pub response_information: *const aws_byte_cursor,
    pub server_reference: *const aws_byte_cursor,
    pub authentication_method: *const aws_byte_cursor,
    pub authentication_data: *const aws_byte_cursor,
}
#[doc = " Read-only snapshot of a PUBACK packet\n\n https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901121"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_mqtt5_packet_puback_view {
    pub packet_id: aws_mqtt5_packet_id_t,
    pub reason_code: aws_mqtt5_puback_reason_code,
    pub reason_string: *const aws_byte_cursor,
    pub user_property_count: usize,
    pub user_properties: *const aws_mqtt5_user_property,
}
#[doc = " Read-only snapshot of a SUBACK packet\n\n https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901171"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_mqtt5_packet_suback_view {
    pub packet_id: aws_mqtt5_packet_id_t,
    pub reason_string: *const aws_byte_cursor,
    pub user_property_count: usize,
    pub user_properties: *const aws_mqtt5_user_property,
    pub reason_code_count: usize,
    pub reason_codes: *const aws_mqtt5_suback_reason_code,
}
#[doc = " Read-only snapshot of an UNSUBACK packet\n\n https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901187"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_mqtt5_packet_unsuback_view {
    pub packet_id: aws_mqtt5_packet_id_t,
    pub reason_string: *const aws_byte_cursor,
    pub user_property_count: usize,
    pub user_properties: *const aws_mqtt5_user_property,
    pub reason_code_count: usize,
    pub reason_codes: *const aws_mqtt5_unsuback_reason_code,
}
#[doc = " Configuration struct for all client topic aliasing behavior.  If this is left null, then all default options\n (as it zeroed) will be used."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_mqtt5_client_topic_alias_options {
    #[doc = " Controls what kind of outbound topic aliasing behavior the client should attempt to use."]
    pub outbound_topic_alias_behavior: aws_mqtt5_client_outbound_topic_alias_behavior_type,
    #[doc = " If outbound topic aliasing is set to LRU, this controls the maximum size of the cache.  If outbound topic\n aliasing is set to LRU and this is zero, a sensible default is used (25).  If outbound topic aliasing is not\n set to LRU, then this setting has no effect.\n\n The final size of the cache is determined by the minimum of this setting and the value of the\n topic_alias_maximum property of the received CONNACK.  If the received CONNACK does not have an explicit\n positive value for that field, outbound topic aliasing is disabled for the duration of that connection."]
    pub outbound_alias_cache_max_size: u16,
    #[doc = " Controls what kind of inbound topic aliasing behavior the client should use.\n\n Even if inbound topic aliasing is enabled, it is up to the server to choose whether or not to use it."]
    pub inbound_topic_alias_behavior: aws_mqtt5_client_inbound_topic_alias_behavior_type,
    #[doc = " If inbound topic aliasing is enabled, this will control the size of the inbound alias cache.  If inbound\n aliases are enabled and this is zero, then a sensible default will be used (25).  If inbound aliases are\n disabled, this setting has no effect.\n\n Behaviorally, this value overrides anything present in the topic_alias_maximum field of\n the CONNECT packet options."]
    pub inbound_alias_cache_size: u16,
}
#[doc = " Completion options for the Publish operation"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_mqtt5_publish_completion_options {
    pub completion_callback: aws_mqtt5_publish_completion_fn,
    pub completion_user_data: *mut ::core::ffi::c_void,
    pub ack_timeout_seconds_override: u32,
}
#[doc = " Completion options for the Subscribe operation"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_mqtt5_subscribe_completion_options {
    pub completion_callback: aws_mqtt5_subscribe_completion_fn,
    pub completion_user_data: *mut ::core::ffi::c_void,
    pub ack_timeout_seconds_override: u32,
}
#[doc = " Completion options for the Unsubscribe operation"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_mqtt5_unsubscribe_completion_options {
    pub completion_callback: aws_mqtt5_unsubscribe_completion_fn,
    pub completion_user_data: *mut ::core::ffi::c_void,
    pub ack_timeout_seconds_override: u32,
}
#[doc = " Completion options for the a DISCONNECT operation"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_mqtt5_disconnect_completion_options {
    pub completion_callback: aws_mqtt5_disconnect_completion_fn,
    pub completion_user_data: *mut ::core::ffi::c_void,
}
#[doc = " Mqtt behavior settings that are dynamically negotiated as part of the CONNECT/CONNACK exchange."]
#[repr(C)]
pub struct aws_mqtt5_negotiated_settings {
    #[doc = " The maximum QoS used between the server and client."]
    pub maximum_qos: aws_mqtt5_qos,
    #[doc = " the amount of time in seconds the server will retain the session after a disconnect."]
    pub session_expiry_interval: u32,
    #[doc = " the number of QoS 1 and QoS2 publications the server is willing to process concurrently."]
    pub receive_maximum_from_server: u16,
    #[doc = " the maximum packet size the server is willing to accept."]
    pub maximum_packet_size_to_server: u32,
    #[doc = " the highest value that the server will accept as a Topic Alias sent by the client."]
    pub topic_alias_maximum_to_server: u16,
    #[doc = " the highest value that the client will accept as a Topic Alias sent by the server."]
    pub topic_alias_maximum_to_client: u16,
    #[doc = " the amount of time in seconds before the server will disconnect the client for inactivity."]
    pub server_keep_alive: u16,
    #[doc = " whether the server supports retained messages."]
    pub retain_available: bool,
    #[doc = " whether the server supports wildcard subscriptions."]
    pub wildcard_subscriptions_available: bool,
    #[doc = " whether the server supports subscription identifiers"]
    pub subscription_identifiers_available: bool,
    #[doc = " whether the server supports shared subscriptions"]
    pub shared_subscriptions_available: bool,
    #[doc = " whether the client has rejoined an existing session."]
    pub rejoined_session: bool,
    pub client_id_storage: aws_byte_buf,
}
#[doc = " Contains some simple statistics about the current state of the client's queue of operations"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_mqtt5_client_operation_statistics {
    pub incomplete_operation_count: u64,
    pub incomplete_operation_size: u64,
    pub unacked_operation_count: u64,
    pub unacked_operation_size: u64,
}
#[doc = " Details about a client lifecycle event."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_mqtt5_client_lifecycle_event {
    #[doc = " Type of event this is."]
    pub event_type: aws_mqtt5_client_lifecycle_event_type,
    #[doc = " Client this event corresponds to.  Necessary (can't be replaced with user data) because the client\n doesn't exist at the time the event callback user data is configured."]
    pub client: *mut aws_mqtt5_client,
    #[doc = " Aws-c-* error code associated with the event"]
    pub error_code: ::core::ffi::c_int,
    #[doc = " User data associated with the client's lifecycle event handler.  Set with client configuration."]
    pub user_data: *mut ::core::ffi::c_void,
    #[doc = " If this event was caused by receiving a CONNACK, this will be a view of that packet."]
    pub connack_data: *const aws_mqtt5_packet_connack_view,
    #[doc = " If this is a successful connection establishment, this will contain the negotiated mqtt5 behavioral settings"]
    pub settings: *const aws_mqtt5_negotiated_settings,
    #[doc = " If this event was caused by receiving a DISCONNECT, this will be a view of that packet."]
    pub disconnect_data: *const aws_mqtt5_packet_disconnect_view,
}
#[doc = " Basic mqtt5 client configuration struct.\n\n Contains desired connection properties\n Configuration that represents properties of the mqtt5 CONNECT packet go in the connect view (connect_options)"]
#[repr(C)]
pub struct aws_mqtt5_client_options {
    #[doc = " Host to establish mqtt connections to"]
    pub host_name: aws_byte_cursor,
    #[doc = " Port to establish mqtt connections to"]
    pub port: u32,
    #[doc = " Client bootstrap to use whenever this client establishes a connection"]
    pub bootstrap: *mut aws_client_bootstrap,
    #[doc = " Socket options to use whenever this client establishes a connection"]
    pub socket_options: *const aws_socket_options,
    #[doc = " (Optional) Tls options to use whenever this client establishes a connection"]
    pub tls_options: *const aws_tls_connection_options,
    #[doc = " (Optional) Http proxy options to use whenever this client establishes a connection"]
    pub http_proxy_options: *const aws_http_proxy_options,
    #[doc = " (Optional) Websocket handshake transformation function and user data.  Websockets are used if the\n transformation function is non-null."]
    pub websocket_handshake_transform: aws_mqtt5_transform_websocket_handshake_fn,
    pub websocket_handshake_transform_user_data: *mut ::core::ffi::c_void,
    #[doc = " All CONNECT-related options, includes the will configuration, if desired"]
    pub connect_options: *const aws_mqtt5_packet_connect_view,
    #[doc = " Controls session rejoin behavior"]
    pub session_behavior: aws_mqtt5_client_session_behavior_type,
    #[doc = " Controls if any additional AWS-specific validation or flow control should be performed by the client."]
    pub extended_validation_and_flow_control_options:
        aws_mqtt5_extended_validation_and_flow_control_options,
    #[doc = " Controls how the client treats queued/in-progress operations when the connection drops for any reason."]
    pub offline_queue_behavior: aws_mqtt5_client_operation_queue_behavior_type,
    #[doc = " Controls the exponential backoff behavior when the client is waiting to reconnect.\n\n See: https://aws.amazon.com/blogs/architecture/exponential-backoff-and-jitter/"]
    pub retry_jitter_mode: aws_exponential_backoff_jitter_mode,
    #[doc = " Minimum amount of time in ms to wait before attempting to reconnect.  If this is zero, a default of 1000 ms will\n be used."]
    pub min_reconnect_delay_ms: u64,
    #[doc = " Maximum amount of time in ms to wait before attempting to reconnect.  If this is zero, a default of 120000 ms\n will be used."]
    pub max_reconnect_delay_ms: u64,
    #[doc = " Amount of time that must elapse with a good connection before the reconnect delay is reset to the minimum.  If\n this zero, a default of 30000 ms will be used."]
    pub min_connected_time_to_reset_reconnect_delay_ms: u64,
    #[doc = " Time interval to wait after sending a PINGREQ for a PINGRESP to arrive.  If one does not arrive, the connection\n will be shut down.  If this is zero, a default of 30000 ms will be used."]
    pub ping_timeout_ms: u32,
    #[doc = " Time interval to wait after sending a CONNECT request for a CONNACK to arrive.  If one does not arrive, the\n connection will be shut down.  If this zero, a default of 20000 ms will be used."]
    pub connack_timeout_ms: u32,
    #[doc = " Time interval to wait for an ack after sending a SUBSCRIBE, UNSUBSCRIBE, or PUBLISH with QoS 1+ before\n failing the packet, notifying the client of failure, and removing it.  If this is zero, a default of 60 seconds\n will be used."]
    pub ack_timeout_seconds: u32,
    #[doc = " Controls how the client uses mqtt5 topic aliasing.  If NULL, zero-based defaults will be used."]
    pub topic_aliasing_options: *const aws_mqtt5_client_topic_alias_options,
    #[doc = " Callback for received publish packets"]
    pub publish_received_handler: aws_mqtt5_publish_received_fn,
    pub publish_received_handler_user_data: *mut ::core::ffi::c_void,
    #[doc = " Callback and user data for all client lifecycle events.\n Life cycle events include:\n    ConnectionSuccess\n    ConnectionFailure,\n    Disconnect\n    (client) Stopped\n\n  Disconnect lifecycle events are 1-1 with -- strictly after -- ConnectionSuccess events."]
    pub lifecycle_event_handler: aws_mqtt5_client_connection_event_callback_fn,
    pub lifecycle_event_handler_user_data: *mut ::core::ffi::c_void,
    #[doc = " Callback for when the client has completely destroyed itself"]
    pub client_termination_handler: aws_mqtt5_client_termination_completion_fn,
    pub client_termination_handler_user_data: *mut ::core::ffi::c_void,
    #[doc = " Options to override aspects of DNS resolution.  If unspecified, use a default that matches the regular\n configuration but changes the refresh frequency to a value that prevents DNS pinging."]
    pub host_resolution_override: *mut aws_host_resolution_config,
}
#[doc = " A record that tracks MQTT5 client callbacks which can be dynamically injected via a listener."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_mqtt5_callback_set {
    pub listener_publish_received_handler: aws_mqtt5_listener_publish_received_fn,
    pub listener_publish_received_handler_user_data: *mut ::core::ffi::c_void,
    pub lifecycle_event_handler: aws_mqtt5_client_connection_event_callback_fn,
    pub lifecycle_event_handler_user_data: *mut ::core::ffi::c_void,
}
#[doc = " Configuration options for MQTT5 listener objects."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_mqtt5_listener_config {
    #[doc = " MQTT5 client to listen to events on"]
    pub client: *mut aws_mqtt5_client,
    #[doc = " Callbacks to invoke when events occur on the MQTT5 client"]
    pub listener_callbacks: aws_mqtt5_callback_set,
    #[doc = " Listener destruction is asynchronous and thus requires a termination callback and associated user data\n to notify the user that the listener has been fully destroyed and no further events will be received."]
    pub termination_callback: aws_mqtt5_listener_termination_completion_fn,
    pub termination_callback_user_data: *mut ::core::ffi::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_mqtt5_listener {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct aws_mqtt5_user_property_set {
    pub properties: aws_array_list,
}
#[repr(C)]
pub struct aws_mqtt5_packet_connect_storage {
    pub allocator: *mut aws_allocator,
    pub storage_view: aws_mqtt5_packet_connect_view,
    pub username: aws_byte_cursor,
    pub password: aws_byte_cursor,
    pub session_expiry_interval_seconds: u32,
    pub request_response_information: u8,
    pub request_problem_information: u8,
    pub receive_maximum: u16,
    pub topic_alias_maximum: u16,
    pub maximum_packet_size_bytes: u32,
    pub will: *mut aws_mqtt5_packet_publish_storage,
    pub will_delay_interval_seconds: u32,
    pub user_properties: aws_mqtt5_user_property_set,
    pub authentication_method: aws_byte_cursor,
    pub authentication_data: aws_byte_cursor,
    pub storage: aws_byte_buf,
}
#[repr(C)]
pub struct aws_mqtt5_packet_connack_storage {
    pub allocator: *mut aws_allocator,
    pub storage_view: aws_mqtt5_packet_connack_view,
    pub session_expiry_interval: u32,
    pub receive_maximum: u16,
    pub maximum_qos: aws_mqtt5_qos,
    pub retain_available: bool,
    pub maximum_packet_size: u32,
    pub assigned_client_identifier: aws_byte_cursor,
    pub topic_alias_maximum: u16,
    pub reason_string: aws_byte_cursor,
    pub wildcard_subscriptions_available: bool,
    pub subscription_identifiers_available: bool,
    pub shared_subscriptions_available: bool,
    pub server_keep_alive: u16,
    pub response_information: aws_byte_cursor,
    pub server_reference: aws_byte_cursor,
    pub authentication_method: aws_byte_cursor,
    pub authentication_data: aws_byte_cursor,
    pub user_properties: aws_mqtt5_user_property_set,
    pub storage: aws_byte_buf,
}
#[repr(C)]
pub struct aws_mqtt5_packet_suback_storage {
    pub allocator: *mut aws_allocator,
    pub storage_view: aws_mqtt5_packet_suback_view,
    pub reason_string: aws_byte_cursor,
    pub user_properties: aws_mqtt5_user_property_set,
    pub reason_codes: aws_array_list,
    pub storage: aws_byte_buf,
}
#[repr(C)]
pub struct aws_mqtt5_packet_unsuback_storage {
    pub allocator: *mut aws_allocator,
    pub storage_view: aws_mqtt5_packet_unsuback_view,
    pub reason_string: aws_byte_cursor,
    pub user_properties: aws_mqtt5_user_property_set,
    pub reason_codes: aws_array_list,
    pub storage: aws_byte_buf,
}
#[repr(C)]
pub struct aws_mqtt5_packet_publish_storage {
    pub storage_view: aws_mqtt5_packet_publish_view,
    pub payload_format: aws_mqtt5_payload_format_indicator,
    pub message_expiry_interval_seconds: u32,
    pub topic_alias: u16,
    pub response_topic: aws_byte_cursor,
    pub correlation_data: aws_byte_cursor,
    pub content_type: aws_byte_cursor,
    pub user_properties: aws_mqtt5_user_property_set,
    pub subscription_identifiers: aws_array_list,
    pub storage: aws_byte_buf,
}
#[repr(C)]
pub struct aws_mqtt5_packet_puback_storage {
    pub storage_view: aws_mqtt5_packet_puback_view,
    pub reason_string: aws_byte_cursor,
    pub user_properties: aws_mqtt5_user_property_set,
    pub storage: aws_byte_buf,
}
#[repr(C)]
pub struct aws_mqtt5_packet_disconnect_storage {
    pub storage_view: aws_mqtt5_packet_disconnect_view,
    pub session_expiry_interval_seconds: u32,
    pub reason_string: aws_byte_cursor,
    pub user_properties: aws_mqtt5_user_property_set,
    pub server_reference: aws_byte_cursor,
    pub storage: aws_byte_buf,
}
#[repr(C)]
pub struct aws_mqtt5_packet_subscribe_storage {
    pub storage_view: aws_mqtt5_packet_subscribe_view,
    pub subscription_identifier: u32,
    pub subscriptions: aws_array_list,
    pub user_properties: aws_mqtt5_user_property_set,
    pub storage: aws_byte_buf,
}
#[repr(C)]
pub struct aws_mqtt5_packet_unsubscribe_storage {
    pub storage_view: aws_mqtt5_packet_unsubscribe_view,
    pub topic_filters: aws_array_list,
    pub user_properties: aws_mqtt5_user_property_set,
    pub storage: aws_byte_buf,
}
pub const AWS_C_MQTT_PACKAGE_ID: u32 = 5;
pub const AWS_MQTT5_CLIENT_MAXIMUM_USER_PROPERTIES: u32 = 1024;
pub const AWS_MQTT5_CLIENT_MAXIMUM_SUBSCRIPTIONS_PER_SUBSCRIBE: u32 = 1024;
pub const AWS_MQTT5_CLIENT_MAXIMUM_TOPIC_FILTERS_PER_UNSUBSCRIBE: u32 = 1024;
pub const AWS_MQTT_QOS_AT_MOST_ONCE: aws_mqtt_qos = 0;
pub const AWS_MQTT_QOS_AT_LEAST_ONCE: aws_mqtt_qos = 1;
pub const AWS_MQTT_QOS_EXACTLY_ONCE: aws_mqtt_qos = 2;
pub const AWS_MQTT_QOS_FAILURE: aws_mqtt_qos = 128;
pub const AWS_MQTT_CONNECT_ACCEPTED: aws_mqtt_connect_return_code = 0;
pub const AWS_MQTT_CONNECT_UNACCEPTABLE_PROTOCOL_VERSION: aws_mqtt_connect_return_code = 1;
pub const AWS_MQTT_CONNECT_IDENTIFIER_REJECTED: aws_mqtt_connect_return_code = 2;
pub const AWS_MQTT_CONNECT_SERVER_UNAVAILABLE: aws_mqtt_connect_return_code = 3;
pub const AWS_MQTT_CONNECT_BAD_USERNAME_OR_PASSWORD: aws_mqtt_connect_return_code = 4;
pub const AWS_MQTT_CONNECT_NOT_AUTHORIZED: aws_mqtt_connect_return_code = 5;
pub const AWS_ERROR_MQTT_INVALID_RESERVED_BITS: aws_mqtt_error = 5120;
pub const AWS_ERROR_MQTT_BUFFER_TOO_BIG: aws_mqtt_error = 5121;
pub const AWS_ERROR_MQTT_INVALID_REMAINING_LENGTH: aws_mqtt_error = 5122;
pub const AWS_ERROR_MQTT_UNSUPPORTED_PROTOCOL_NAME: aws_mqtt_error = 5123;
pub const AWS_ERROR_MQTT_UNSUPPORTED_PROTOCOL_LEVEL: aws_mqtt_error = 5124;
pub const AWS_ERROR_MQTT_INVALID_CREDENTIALS: aws_mqtt_error = 5125;
pub const AWS_ERROR_MQTT_INVALID_QOS: aws_mqtt_error = 5126;
pub const AWS_ERROR_MQTT_INVALID_PACKET_TYPE: aws_mqtt_error = 5127;
pub const AWS_ERROR_MQTT_INVALID_TOPIC: aws_mqtt_error = 5128;
pub const AWS_ERROR_MQTT_TIMEOUT: aws_mqtt_error = 5129;
pub const AWS_ERROR_MQTT_PROTOCOL_ERROR: aws_mqtt_error = 5130;
pub const AWS_ERROR_MQTT_NOT_CONNECTED: aws_mqtt_error = 5131;
pub const AWS_ERROR_MQTT_ALREADY_CONNECTED: aws_mqtt_error = 5132;
pub const AWS_ERROR_MQTT_BUILT_WITHOUT_WEBSOCKETS: aws_mqtt_error = 5133;
pub const AWS_ERROR_MQTT_UNEXPECTED_HANGUP: aws_mqtt_error = 5134;
pub const AWS_ERROR_MQTT_CONNECTION_SHUTDOWN: aws_mqtt_error = 5135;
pub const AWS_ERROR_MQTT_CONNECTION_DESTROYED: aws_mqtt_error = 5136;
pub const AWS_ERROR_MQTT_CONNECTION_DISCONNECTING: aws_mqtt_error = 5137;
pub const AWS_ERROR_MQTT_CANCELLED_FOR_CLEAN_SESSION: aws_mqtt_error = 5138;
pub const AWS_ERROR_MQTT_QUEUE_FULL: aws_mqtt_error = 5139;
pub const AWS_ERROR_MQTT5_CLIENT_OPTIONS_VALIDATION: aws_mqtt_error = 5140;
pub const AWS_ERROR_MQTT5_CONNECT_OPTIONS_VALIDATION: aws_mqtt_error = 5141;
pub const AWS_ERROR_MQTT5_DISCONNECT_OPTIONS_VALIDATION: aws_mqtt_error = 5142;
pub const AWS_ERROR_MQTT5_PUBLISH_OPTIONS_VALIDATION: aws_mqtt_error = 5143;
pub const AWS_ERROR_MQTT5_SUBSCRIBE_OPTIONS_VALIDATION: aws_mqtt_error = 5144;
pub const AWS_ERROR_MQTT5_UNSUBSCRIBE_OPTIONS_VALIDATION: aws_mqtt_error = 5145;
pub const AWS_ERROR_MQTT5_USER_PROPERTY_VALIDATION: aws_mqtt_error = 5146;
pub const AWS_ERROR_MQTT5_PACKET_VALIDATION: aws_mqtt_error = 5147;
pub const AWS_ERROR_MQTT5_ENCODE_FAILURE: aws_mqtt_error = 5148;
pub const AWS_ERROR_MQTT5_DECODE_PROTOCOL_ERROR: aws_mqtt_error = 5149;
pub const AWS_ERROR_MQTT5_CONNACK_CONNECTION_REFUSED: aws_mqtt_error = 5150;
pub const AWS_ERROR_MQTT5_CONNACK_TIMEOUT: aws_mqtt_error = 5151;
pub const AWS_ERROR_MQTT5_PING_RESPONSE_TIMEOUT: aws_mqtt_error = 5152;
pub const AWS_ERROR_MQTT5_USER_REQUESTED_STOP: aws_mqtt_error = 5153;
pub const AWS_ERROR_MQTT5_DISCONNECT_RECEIVED: aws_mqtt_error = 5154;
pub const AWS_ERROR_MQTT5_CLIENT_TERMINATED: aws_mqtt_error = 5155;
pub const AWS_ERROR_MQTT5_OPERATION_FAILED_DUE_TO_OFFLINE_QUEUE_POLICY: aws_mqtt_error = 5156;
pub const AWS_ERROR_MQTT5_ENCODE_SIZE_UNSUPPORTED_PACKET_TYPE: aws_mqtt_error = 5157;
pub const AWS_ERROR_MQTT5_OPERATION_PROCESSING_FAILURE: aws_mqtt_error = 5158;
pub const AWS_ERROR_MQTT5_INVALID_INBOUND_TOPIC_ALIAS: aws_mqtt_error = 5159;
pub const AWS_ERROR_MQTT5_INVALID_OUTBOUND_TOPIC_ALIAS: aws_mqtt_error = 5160;
pub const AWS_ERROR_MQTT5_INVALID_UTF8_STRING: aws_mqtt_error = 5161;
pub const AWS_ERROR_MQTT_CONNECTION_RESET_FOR_ADAPTER_CONNECT: aws_mqtt_error = 5162;
pub const AWS_ERROR_MQTT_CONNECTION_RESUBSCRIBE_NO_TOPICS: aws_mqtt_error = 5163;
pub const AWS_ERROR_MQTT_CONNECTION_SUBSCRIBE_FAILURE: aws_mqtt_error = 5164;
pub const AWS_ERROR_END_MQTT_RANGE: aws_mqtt_error = 6143;
pub const AWS_LS_MQTT_GENERAL: aws_mqtt_log_subject = 5120;
pub const AWS_LS_MQTT_CLIENT: aws_mqtt_log_subject = 5121;
pub const AWS_LS_MQTT_TOPIC_TREE: aws_mqtt_log_subject = 5122;
pub const AWS_LS_MQTT5_GENERAL: aws_mqtt_log_subject = 5123;
pub const AWS_LS_MQTT5_CLIENT: aws_mqtt_log_subject = 5124;
pub const AWS_LS_MQTT5_CANARY: aws_mqtt_log_subject = 5125;
pub const AWS_LS_MQTT5_TO_MQTT3_ADAPTER: aws_mqtt_log_subject = 5126;
#[doc = " https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901235"]
pub const AWS_MQTT5_QOS_AT_MOST_ONCE: aws_mqtt5_qos = 0;
#[doc = " https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901236"]
pub const AWS_MQTT5_QOS_AT_LEAST_ONCE: aws_mqtt5_qos = 1;
#[doc = " https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901237"]
pub const AWS_MQTT5_QOS_EXACTLY_ONCE: aws_mqtt5_qos = 2;
pub const AWS_MQTT5_CRC_SUCCESS: aws_mqtt5_connect_reason_code = 0;
pub const AWS_MQTT5_CRC_UNSPECIFIED_ERROR: aws_mqtt5_connect_reason_code = 128;
pub const AWS_MQTT5_CRC_MALFORMED_PACKET: aws_mqtt5_connect_reason_code = 129;
pub const AWS_MQTT5_CRC_PROTOCOL_ERROR: aws_mqtt5_connect_reason_code = 130;
pub const AWS_MQTT5_CRC_IMPLEMENTATION_SPECIFIC_ERROR: aws_mqtt5_connect_reason_code = 131;
pub const AWS_MQTT5_CRC_UNSUPPORTED_PROTOCOL_VERSION: aws_mqtt5_connect_reason_code = 132;
pub const AWS_MQTT5_CRC_CLIENT_IDENTIFIER_NOT_VALID: aws_mqtt5_connect_reason_code = 133;
pub const AWS_MQTT5_CRC_BAD_USERNAME_OR_PASSWORD: aws_mqtt5_connect_reason_code = 134;
pub const AWS_MQTT5_CRC_NOT_AUTHORIZED: aws_mqtt5_connect_reason_code = 135;
pub const AWS_MQTT5_CRC_SERVER_UNAVAILABLE: aws_mqtt5_connect_reason_code = 136;
pub const AWS_MQTT5_CRC_SERVER_BUSY: aws_mqtt5_connect_reason_code = 137;
pub const AWS_MQTT5_CRC_BANNED: aws_mqtt5_connect_reason_code = 138;
pub const AWS_MQTT5_CRC_BAD_AUTHENTICATION_METHOD: aws_mqtt5_connect_reason_code = 140;
pub const AWS_MQTT5_CRC_TOPIC_NAME_INVALID: aws_mqtt5_connect_reason_code = 144;
pub const AWS_MQTT5_CRC_PACKET_TOO_LARGE: aws_mqtt5_connect_reason_code = 149;
pub const AWS_MQTT5_CRC_QUOTA_EXCEEDED: aws_mqtt5_connect_reason_code = 151;
pub const AWS_MQTT5_CRC_PAYLOAD_FORMAT_INVALID: aws_mqtt5_connect_reason_code = 153;
pub const AWS_MQTT5_CRC_RETAIN_NOT_SUPPORTED: aws_mqtt5_connect_reason_code = 154;
pub const AWS_MQTT5_CRC_QOS_NOT_SUPPORTED: aws_mqtt5_connect_reason_code = 155;
pub const AWS_MQTT5_CRC_USE_ANOTHER_SERVER: aws_mqtt5_connect_reason_code = 156;
pub const AWS_MQTT5_CRC_SERVER_MOVED: aws_mqtt5_connect_reason_code = 157;
pub const AWS_MQTT5_CRC_CONNECTION_RATE_EXCEEDED: aws_mqtt5_connect_reason_code = 159;
pub const AWS_MQTT5_DRC_NORMAL_DISCONNECTION: aws_mqtt5_disconnect_reason_code = 0;
pub const AWS_MQTT5_DRC_DISCONNECT_WITH_WILL_MESSAGE: aws_mqtt5_disconnect_reason_code = 4;
pub const AWS_MQTT5_DRC_UNSPECIFIED_ERROR: aws_mqtt5_disconnect_reason_code = 128;
pub const AWS_MQTT5_DRC_MALFORMED_PACKET: aws_mqtt5_disconnect_reason_code = 129;
pub const AWS_MQTT5_DRC_PROTOCOL_ERROR: aws_mqtt5_disconnect_reason_code = 130;
pub const AWS_MQTT5_DRC_IMPLEMENTATION_SPECIFIC_ERROR: aws_mqtt5_disconnect_reason_code = 131;
pub const AWS_MQTT5_DRC_NOT_AUTHORIZED: aws_mqtt5_disconnect_reason_code = 135;
pub const AWS_MQTT5_DRC_SERVER_BUSY: aws_mqtt5_disconnect_reason_code = 137;
pub const AWS_MQTT5_DRC_SERVER_SHUTTING_DOWN: aws_mqtt5_disconnect_reason_code = 139;
pub const AWS_MQTT5_DRC_KEEP_ALIVE_TIMEOUT: aws_mqtt5_disconnect_reason_code = 141;
pub const AWS_MQTT5_DRC_SESSION_TAKEN_OVER: aws_mqtt5_disconnect_reason_code = 142;
pub const AWS_MQTT5_DRC_TOPIC_FILTER_INVALID: aws_mqtt5_disconnect_reason_code = 143;
pub const AWS_MQTT5_DRC_TOPIC_NAME_INVALID: aws_mqtt5_disconnect_reason_code = 144;
pub const AWS_MQTT5_DRC_RECEIVE_MAXIMUM_EXCEEDED: aws_mqtt5_disconnect_reason_code = 147;
pub const AWS_MQTT5_DRC_TOPIC_ALIAS_INVALID: aws_mqtt5_disconnect_reason_code = 148;
pub const AWS_MQTT5_DRC_PACKET_TOO_LARGE: aws_mqtt5_disconnect_reason_code = 149;
pub const AWS_MQTT5_DRC_MESSAGE_RATE_TOO_HIGH: aws_mqtt5_disconnect_reason_code = 150;
pub const AWS_MQTT5_DRC_QUOTA_EXCEEDED: aws_mqtt5_disconnect_reason_code = 151;
pub const AWS_MQTT5_DRC_ADMINISTRATIVE_ACTION: aws_mqtt5_disconnect_reason_code = 152;
pub const AWS_MQTT5_DRC_PAYLOAD_FORMAT_INVALID: aws_mqtt5_disconnect_reason_code = 153;
pub const AWS_MQTT5_DRC_RETAIN_NOT_SUPPORTED: aws_mqtt5_disconnect_reason_code = 154;
pub const AWS_MQTT5_DRC_QOS_NOT_SUPPORTED: aws_mqtt5_disconnect_reason_code = 155;
pub const AWS_MQTT5_DRC_USE_ANOTHER_SERVER: aws_mqtt5_disconnect_reason_code = 156;
pub const AWS_MQTT5_DRC_SERVER_MOVED: aws_mqtt5_disconnect_reason_code = 157;
pub const AWS_MQTT5_DRC_SHARED_SUBSCRIPTIONS_NOT_SUPPORTED: aws_mqtt5_disconnect_reason_code = 158;
pub const AWS_MQTT5_DRC_CONNECTION_RATE_EXCEEDED: aws_mqtt5_disconnect_reason_code = 159;
pub const AWS_MQTT5_DRC_MAXIMUM_CONNECT_TIME: aws_mqtt5_disconnect_reason_code = 160;
pub const AWS_MQTT5_DRC_SUBSCRIPTION_IDENTIFIERS_NOT_SUPPORTED: aws_mqtt5_disconnect_reason_code =
    161;
pub const AWS_MQTT5_DRC_WILDCARD_SUBSCRIPTIONS_NOT_SUPPORTED: aws_mqtt5_disconnect_reason_code =
    162;
pub const AWS_MQTT5_PARC_SUCCESS: aws_mqtt5_puback_reason_code = 0;
pub const AWS_MQTT5_PARC_NO_MATCHING_SUBSCRIBERS: aws_mqtt5_puback_reason_code = 16;
pub const AWS_MQTT5_PARC_UNSPECIFIED_ERROR: aws_mqtt5_puback_reason_code = 128;
pub const AWS_MQTT5_PARC_IMPLEMENTATION_SPECIFIC_ERROR: aws_mqtt5_puback_reason_code = 131;
pub const AWS_MQTT5_PARC_NOT_AUTHORIZED: aws_mqtt5_puback_reason_code = 135;
pub const AWS_MQTT5_PARC_TOPIC_NAME_INVALID: aws_mqtt5_puback_reason_code = 144;
pub const AWS_MQTT5_PARC_PACKET_IDENTIFIER_IN_USE: aws_mqtt5_puback_reason_code = 145;
pub const AWS_MQTT5_PARC_QUOTA_EXCEEDED: aws_mqtt5_puback_reason_code = 151;
pub const AWS_MQTT5_PARC_PAYLOAD_FORMAT_INVALID: aws_mqtt5_puback_reason_code = 153;
pub const AWS_MQTT5_SARC_GRANTED_QOS_0: aws_mqtt5_suback_reason_code = 0;
pub const AWS_MQTT5_SARC_GRANTED_QOS_1: aws_mqtt5_suback_reason_code = 1;
pub const AWS_MQTT5_SARC_GRANTED_QOS_2: aws_mqtt5_suback_reason_code = 2;
pub const AWS_MQTT5_SARC_UNSPECIFIED_ERROR: aws_mqtt5_suback_reason_code = 128;
pub const AWS_MQTT5_SARC_IMPLEMENTATION_SPECIFIC_ERROR: aws_mqtt5_suback_reason_code = 131;
pub const AWS_MQTT5_SARC_NOT_AUTHORIZED: aws_mqtt5_suback_reason_code = 135;
pub const AWS_MQTT5_SARC_TOPIC_FILTER_INVALID: aws_mqtt5_suback_reason_code = 143;
pub const AWS_MQTT5_SARC_PACKET_IDENTIFIER_IN_USE: aws_mqtt5_suback_reason_code = 145;
pub const AWS_MQTT5_SARC_QUOTA_EXCEEDED: aws_mqtt5_suback_reason_code = 151;
pub const AWS_MQTT5_SARC_SHARED_SUBSCRIPTIONS_NOT_SUPPORTED: aws_mqtt5_suback_reason_code = 158;
pub const AWS_MQTT5_SARC_SUBSCRIPTION_IDENTIFIERS_NOT_SUPPORTED: aws_mqtt5_suback_reason_code = 161;
pub const AWS_MQTT5_SARC_WILDCARD_SUBSCRIPTIONS_NOT_SUPPORTED: aws_mqtt5_suback_reason_code = 162;
pub const AWS_MQTT5_UARC_SUCCESS: aws_mqtt5_unsuback_reason_code = 0;
pub const AWS_MQTT5_UARC_NO_SUBSCRIPTION_EXISTED: aws_mqtt5_unsuback_reason_code = 17;
pub const AWS_MQTT5_UARC_UNSPECIFIED_ERROR: aws_mqtt5_unsuback_reason_code = 128;
pub const AWS_MQTT5_UARC_IMPLEMENTATION_SPECIFIC_ERROR: aws_mqtt5_unsuback_reason_code = 131;
pub const AWS_MQTT5_UARC_NOT_AUTHORIZED: aws_mqtt5_unsuback_reason_code = 135;
pub const AWS_MQTT5_UARC_TOPIC_FILTER_INVALID: aws_mqtt5_unsuback_reason_code = 143;
pub const AWS_MQTT5_UARC_PACKET_IDENTIFIER_IN_USE: aws_mqtt5_unsuback_reason_code = 145;
pub const AWS_MQTT5_PT_NONE: aws_mqtt5_packet_type = -1;
pub const AWS_MQTT5_PT_RESERVED: aws_mqtt5_packet_type = 0;
pub const AWS_MQTT5_PT_CONNECT: aws_mqtt5_packet_type = 1;
pub const AWS_MQTT5_PT_CONNACK: aws_mqtt5_packet_type = 2;
pub const AWS_MQTT5_PT_PUBLISH: aws_mqtt5_packet_type = 3;
pub const AWS_MQTT5_PT_PUBACK: aws_mqtt5_packet_type = 4;
pub const AWS_MQTT5_PT_PUBREC: aws_mqtt5_packet_type = 5;
pub const AWS_MQTT5_PT_PUBREL: aws_mqtt5_packet_type = 6;
pub const AWS_MQTT5_PT_PUBCOMP: aws_mqtt5_packet_type = 7;
pub const AWS_MQTT5_PT_SUBSCRIBE: aws_mqtt5_packet_type = 8;
pub const AWS_MQTT5_PT_SUBACK: aws_mqtt5_packet_type = 9;
pub const AWS_MQTT5_PT_UNSUBSCRIBE: aws_mqtt5_packet_type = 10;
pub const AWS_MQTT5_PT_UNSUBACK: aws_mqtt5_packet_type = 11;
pub const AWS_MQTT5_PT_PINGREQ: aws_mqtt5_packet_type = 12;
pub const AWS_MQTT5_PT_PINGRESP: aws_mqtt5_packet_type = 13;
pub const AWS_MQTT5_PT_DISCONNECT: aws_mqtt5_packet_type = 14;
pub const AWS_MQTT5_PT_AUTH: aws_mqtt5_packet_type = 15;
pub const AWS_MQTT5_PFI_BYTES: aws_mqtt5_payload_format_indicator = 0;
pub const AWS_MQTT5_PFI_UTF8: aws_mqtt5_payload_format_indicator = 1;
#[doc = " Server should send all retained messages on topics that match the subscription's filter."]
pub const AWS_MQTT5_RHT_SEND_ON_SUBSCRIBE: aws_mqtt5_retain_handling_type = 0;
#[doc = " Server should send all retained messages on topics that match the subscription's filter, where this is the\n first (relative to connection) subscription filter that matches the topic with a retained message."]
pub const AWS_MQTT5_RHT_SEND_ON_SUBSCRIBE_IF_NEW: aws_mqtt5_retain_handling_type = 1;
#[doc = " Subscribe must not trigger any retained message publishes from the server."]
pub const AWS_MQTT5_RHT_DONT_SEND: aws_mqtt5_retain_handling_type = 2;
#[doc = " Maps to AWS_MQTT5_CSBT_CLEAN"]
pub const AWS_MQTT5_CSBT_DEFAULT: aws_mqtt5_client_session_behavior_type = 0;
#[doc = " Always join a new, clean session"]
pub const AWS_MQTT5_CSBT_CLEAN: aws_mqtt5_client_session_behavior_type = 1;
#[doc = " Always attempt to rejoin an existing session after an initial connection success."]
pub const AWS_MQTT5_CSBT_REJOIN_POST_SUCCESS: aws_mqtt5_client_session_behavior_type = 2;
#[doc = " Always attempt to rejoin an existing session.  Since the client does not support durable session persistence,\n this option is not guaranteed to be spec compliant because any unacknowledged qos1 publishes (which are\n part of the client session state) will not be present on the initial connection.  Until we support\n durable session resumption, this option is technically spec-breaking, but useful."]
pub const AWS_MQTT5_CSBT_REJOIN_ALWAYS: aws_mqtt5_client_session_behavior_type = 3;
#[doc = " Maps to AWS_MQTT5_COTABT_DISABLED  This keeps the client from being broken (by default) if the broker\n topic aliasing implementation has a problem."]
pub const AWS_MQTT5_COTABT_DEFAULT: aws_mqtt5_client_outbound_topic_alias_behavior_type = 0;
#[doc = " Outbound aliasing is the user's responsibility.  Client will cache and use\n previously-established aliases if they fall within the negotiated limits of the connection.\n\n The user must still always submit a full topic in their publishes because disconnections disrupt\n topic alias mappings unpredictably.  The client will properly use the alias when the current connection\n has seen the alias binding already."]
pub const AWS_MQTT5_COTABT_MANUAL: aws_mqtt5_client_outbound_topic_alias_behavior_type = 1;
#[doc = " Client ignores any user-specified topic aliasing and acts on the outbound alias set as an LRU cache."]
pub const AWS_MQTT5_COTABT_LRU: aws_mqtt5_client_outbound_topic_alias_behavior_type = 2;
#[doc = " Completely disable outbound topic aliasing."]
pub const AWS_MQTT5_COTABT_DISABLED: aws_mqtt5_client_outbound_topic_alias_behavior_type = 3;
#[doc = " Maps to AWS_MQTT5_CITABT_DISABLED"]
pub const AWS_MQTT5_CITABT_DEFAULT: aws_mqtt5_client_inbound_topic_alias_behavior_type = 0;
#[doc = " Allow the server to send PUBLISH packets to the client that use topic aliasing"]
pub const AWS_MQTT5_CITABT_ENABLED: aws_mqtt5_client_inbound_topic_alias_behavior_type = 1;
#[doc = " Forbid the server from sending PUBLISH packets to the client that use topic aliasing"]
pub const AWS_MQTT5_CITABT_DISABLED: aws_mqtt5_client_inbound_topic_alias_behavior_type = 2;
#[doc = " Do not do any additional validation or flow control outside of the MQTT5 spec"]
pub const AWS_MQTT5_EVAFCO_NONE: aws_mqtt5_extended_validation_and_flow_control_options = 0;
#[doc = " Apply additional client-side operational flow control that respects the\n default AWS IoT Core limits.\n\n Applies the following flow control:\n  (1) Outbound throughput throttled to 512KB/s\n  (2) Outbound publish TPS throttled to 100"]
pub const AWS_MQTT5_EVAFCO_AWS_IOT_CORE_DEFAULTS:
    aws_mqtt5_extended_validation_and_flow_control_options = 1;
pub const AWS_MQTT5_COQBT_DEFAULT: aws_mqtt5_client_operation_queue_behavior_type = 0;
pub const AWS_MQTT5_COQBT_FAIL_NON_QOS1_PUBLISH_ON_DISCONNECT:
    aws_mqtt5_client_operation_queue_behavior_type = 1;
pub const AWS_MQTT5_COQBT_FAIL_QOS0_PUBLISH_ON_DISCONNECT:
    aws_mqtt5_client_operation_queue_behavior_type = 2;
pub const AWS_MQTT5_COQBT_FAIL_ALL_ON_DISCONNECT: aws_mqtt5_client_operation_queue_behavior_type =
    3;
#[doc = " Emitted when the client begins an attempt to connect to the remote endpoint.\n\n Mandatory event fields: client, user_data"]
pub const AWS_MQTT5_CLET_ATTEMPTING_CONNECT: aws_mqtt5_client_lifecycle_event_type = 0;
#[doc = " Emitted after the client connects to the remote endpoint and receives a successful CONNACK.\n Every ATTEMPTING_CONNECT will be followed by exactly one CONNECTION_SUCCESS or one CONNECTION_FAILURE.\n\n Mandatory event fields: client, user_data, connack_data, settings"]
pub const AWS_MQTT5_CLET_CONNECTION_SUCCESS: aws_mqtt5_client_lifecycle_event_type = 1;
#[doc = " Emitted at any point during the connection process when it has conclusively failed.\n Every ATTEMPTING_CONNECT will be followed by exactly one CONNECTION_SUCCESS or one CONNECTION_FAILURE.\n\n Mandatory event fields: client, user_data, error_code\n Conditional event fields: connack_data"]
pub const AWS_MQTT5_CLET_CONNECTION_FAILURE: aws_mqtt5_client_lifecycle_event_type = 2;
#[doc = " Lifecycle event containing information about a disconnect.  Every CONNECTION_SUCCESS will eventually be\n followed by one and only one DISCONNECTION.\n\n Mandatory event fields: client, user_data, error_code\n Conditional event fields: disconnect_data"]
pub const AWS_MQTT5_CLET_DISCONNECTION: aws_mqtt5_client_lifecycle_event_type = 3;
#[doc = " Lifecycle event notifying the user that the client has entered the STOPPED state.  Entering this state will\n cause the client to wipe all MQTT session state.\n\n Mandatory event fields: client, user_data"]
pub const AWS_MQTT5_CLET_STOPPED: aws_mqtt5_client_lifecycle_event_type = 4;
extern "C" {
    pub fn aws_mqtt_is_valid_topic(topic: *const aws_byte_cursor) -> bool;
    pub fn aws_mqtt_is_valid_topic_filter(topic_filter: *const aws_byte_cursor) -> bool;
    #[doc = " Validate utf-8 string under mqtt specs\n\n @param text\n @return AWS_OP_SUCCESS if the text is validate, otherwise AWS_OP_ERR"]
    pub fn aws_mqtt_validate_utf8_text(text: aws_byte_cursor) -> ::core::ffi::c_int;
    #[doc = " Initializes internal datastructures used by aws-c-mqtt.\n Must be called before using any functionality in aws-c-mqtt."]
    pub fn aws_mqtt_library_init(allocator: *mut aws_allocator);
    #[doc = " Shuts down the internal datastructures used by aws-c-mqtt."]
    pub fn aws_mqtt_library_clean_up();
    pub fn aws_mqtt_fatal_assert_library_initialized();
    #[doc = " Creates an instance of aws_mqtt_client.\n\n \\param[in] allocator The allocator the client will use for all future allocations\n \\param[in] bootstrap The client bootstrap to use to initiate new socket connections\n\n \\returns a new instance of an aws_mqtt_client if successful, NULL otherwise"]
    pub fn aws_mqtt_client_new(
        allocator: *mut aws_allocator,
        bootstrap: *mut aws_client_bootstrap,
    ) -> *mut aws_mqtt_client;
    #[doc = " Increments the ref count to an mqtt client, allowing the caller to take a reference to it\n\n \\param[in] client    The client to increment the ref count on\n\n \\returns the mqtt client"]
    pub fn aws_mqtt_client_acquire(client: *mut aws_mqtt_client) -> *mut aws_mqtt_client;
    #[doc = " Decrements the ref count on an mqtt client.  If the ref count drops to zero, the client is cleaned up.\n\n \\param[in] client    The client to release a ref count on"]
    pub fn aws_mqtt_client_release(client: *mut aws_mqtt_client);
    #[doc = " Spawns a new connection object.\n\n \\param[in] client    The client to spawn the connection from\n\n \\returns a new mqtt connection on success, NULL otherwise"]
    pub fn aws_mqtt_client_connection_new(
        client: *mut aws_mqtt_client,
    ) -> *mut aws_mqtt_client_connection;
    #[doc = " Creates a new MQTT311 connection object that uses an MQTT5 client under the hood\n\n \\param[in] client    The mqtt5 client to create the connection from\n\n \\returns a new mqtt (311) connection on success, NULL otherwise"]
    pub fn aws_mqtt_client_connection_new_from_mqtt5_client(
        client: *mut aws_mqtt5_client,
    ) -> *mut aws_mqtt_client_connection;
    #[doc = " Increments the ref count to an mqtt client connection, allowing the caller to take a reference to it\n\n \\param[in] connection    The connection object\n\n \\returns the mqtt connection"]
    pub fn aws_mqtt_client_connection_acquire(
        connection: *mut aws_mqtt_client_connection,
    ) -> *mut aws_mqtt_client_connection;
    #[doc = " Decrements the ref count on an mqtt connection.  If the ref count drops to zero, the connection is cleaned up.\n Note: cannot call this with lock held, since it will start the destroy process and cause a dead lock.\n\n \\param[in] connection    The connection object"]
    pub fn aws_mqtt_client_connection_release(connection: *mut aws_mqtt_client_connection);
    #[doc = " Sets the will message to send with the CONNECT packet.\n\n \\param[in] connection    The connection object\n \\param[in] topic         The topic to publish the will on\n \\param[in] qos           The QoS to publish the will with\n \\param[in] retain        The retain flag to publish the will with\n \\param[in] payload       The data if the will message"]
    pub fn aws_mqtt_client_connection_set_will(
        connection: *mut aws_mqtt_client_connection,
        topic: *const aws_byte_cursor,
        qos: aws_mqtt_qos,
        retain: bool,
        payload: *const aws_byte_cursor,
    ) -> ::core::ffi::c_int;
    #[doc = " Sets the username and/or password to send with the CONNECT packet.\n\n \\param[in] connection    The connection object\n \\param[in] username      The username to connect with\n \\param[in] password      [optional] The password to connect with"]
    pub fn aws_mqtt_client_connection_set_login(
        connection: *mut aws_mqtt_client_connection,
        username: *const aws_byte_cursor,
        password: *const aws_byte_cursor,
    ) -> ::core::ffi::c_int;
    #[doc = " Use MQTT over websockets when connecting.\n Requires the MQTT_WITH_WEBSOCKETS build option.\n\n In this scenario, an HTTP connection is established, which is then upgraded to a websocket connection,\n which is then used to send MQTT data.\n\n \\param[in] connection        The connection object.\n \\param[in] transformer       [optional] Function that may transform the websocket handshake request.\n                              See `aws_mqtt_transform_websocket_handshake_fn` for more info.\n \\param[in] transformer_ud    [optional] Userdata for request_transformer.\n \\param[in] validator         [optional] Function that may reject the websocket handshake response.\n \\param[in] validator_ud      [optional] Userdata for response_validator."]
    pub fn aws_mqtt_client_connection_use_websockets(
        connection: *mut aws_mqtt_client_connection,
        transformer: aws_mqtt_transform_websocket_handshake_fn,
        transformer_ud: *mut ::core::ffi::c_void,
        validator: aws_mqtt_validate_websocket_handshake_fn,
        validator_ud: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    #[doc = " Set http proxy options for the connection."]
    pub fn aws_mqtt_client_connection_set_http_proxy_options(
        connection: *mut aws_mqtt_client_connection,
        proxy_options: *mut aws_http_proxy_options,
    ) -> ::core::ffi::c_int;
    #[doc = " Set host resolution ooptions for the connection."]
    pub fn aws_mqtt_client_connection_set_host_resolution_options(
        connection: *mut aws_mqtt_client_connection,
        host_resolution_config: *const aws_host_resolution_config,
    ) -> ::core::ffi::c_int;
    #[doc = " Sets the minimum and maximum reconnect timeouts.\n\n The time between reconnect attempts will start at min and multiply by 2 until max is reached.\n\n \\param[in] connection    The connection object\n \\param[in] min_timeout   The timeout to start with\n \\param[in] max_timeout   The highest allowable wait time between reconnect attempts"]
    pub fn aws_mqtt_client_connection_set_reconnect_timeout(
        connection: *mut aws_mqtt_client_connection,
        min_timeout: u64,
        max_timeout: u64,
    ) -> ::core::ffi::c_int;
    #[doc = " Sets the callbacks to call when a connection succeeds or fails\n\n \\param[in] connection                The connection object\n \\param[in] on_connection_success     The function to call when a connection is successful or gets resumed\n \\param[in] on_connection_success_ud  Userdata for on_connection_success\n \\param[in] on_connection_failure     The function to call when a connection fails\n \\param[in] on_connection_failure_ud  Userdata for on_connection_failure"]
    pub fn aws_mqtt_client_connection_set_connection_result_handlers(
        connection: *mut aws_mqtt_client_connection,
        on_connection_success: aws_mqtt_client_on_connection_success_fn,
        on_connection_success_ud: *mut ::core::ffi::c_void,
        on_connection_failure: aws_mqtt_client_on_connection_failure_fn,
        on_connection_failure_ud: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    #[doc = " Sets the callbacks to call when a connection is interrupted and resumed.\n\n \\param[in] connection        The connection object\n \\param[in] on_interrupted    The function to call when a connection is lost\n \\param[in] on_interrupted_ud Userdata for on_interrupted\n \\param[in] on_resumed        The function to call when a connection is resumed\n(if clean_session is true, calling aws_mqtt_resubscribe_existing_topics is suggested)\n \\param[in] on_resumed_ud     Userdata for on_resumed"]
    pub fn aws_mqtt_client_connection_set_connection_interruption_handlers(
        connection: *mut aws_mqtt_client_connection,
        on_interrupted: aws_mqtt_client_on_connection_interrupted_fn,
        on_interrupted_ud: *mut ::core::ffi::c_void,
        on_resumed: aws_mqtt_client_on_connection_resumed_fn,
        on_resumed_ud: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    #[doc = " Sets the callback to call when the connection is closed normally by user request.\n This is different than the connection interrupted or lost, this only covers successful\n closure.\n\n \\param[in] connection        The connection object\n \\param[in] on_closed         The function to call when a connection is closed\n \\param[in] on_closed_ud      Userdata for on_closed"]
    pub fn aws_mqtt_client_connection_set_connection_closed_handler(
        connection: *mut aws_mqtt_client_connection,
        on_closed: aws_mqtt_client_on_connection_closed_fn,
        on_closed_ud: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    #[doc = " Sets the callback to call whenever ANY publish packet is received. Only safe to set when connection is not connected.\n\n \\param[in] connection        The connection object\n \\param[in] on_any_publish    The function to call when a publish is received (pass NULL to unset)\n \\param[in] on_any_publish_ud Userdata for on_any_publish"]
    pub fn aws_mqtt_client_connection_set_on_any_publish_handler(
        connection: *mut aws_mqtt_client_connection,
        on_any_publish: aws_mqtt_client_publish_received_fn,
        on_any_publish_ud: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    #[doc = " Sets the callback to call on a connection destruction.\n\n \\param[in] connection        The connection object.\n \\param[in] on_termination    The function to call when a connection is destroyed.\n \\param[in] on_termination_ud Userdata for on_termination."]
    pub fn aws_mqtt_client_connection_set_connection_termination_handler(
        connection: *mut aws_mqtt_client_connection,
        on_termination: aws_mqtt_client_on_connection_termination_fn,
        on_termination_ud: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    #[doc = " Opens the actual connection defined by aws_mqtt_client_connection_new.\n Once the connection is opened, on_connack will be called. Only called when connection is disconnected.\n\n \\param[in] connection                The connection object\n \\param[in] connection_options        Configuration information for the connection attempt\n\n \\returns AWS_OP_SUCCESS if the connection has been successfully initiated,\n              otherwise AWS_OP_ERR and aws_last_error() will be set."]
    pub fn aws_mqtt_client_connection_connect(
        connection: *mut aws_mqtt_client_connection,
        connection_options: *const aws_mqtt_connection_options,
    ) -> ::core::ffi::c_int;
    #[doc = " DEPRECATED\n Opens the actual connection defined by aws_mqtt_client_connection_new.\n Once the connection is opened, on_connack will be called.\n\n Must be called on a connection that has previously been open,\n as the parameters passed during the last connection will be reused.\n\n \\param[in] connection                The connection object\n \\param[in] on_connection_complete    The callback to fire when the connection attempt completes\n \\param[in] userdata                  (nullable) Passed to the userdata param of on_connection_complete\n\n \\returns AWS_OP_SUCCESS if the connection has been successfully initiated,\n              otherwise AWS_OP_ERR and aws_last_error() will be set."]
    pub fn aws_mqtt_client_connection_reconnect(
        connection: *mut aws_mqtt_client_connection,
        on_connection_complete: aws_mqtt_client_on_connection_complete_fn,
        userdata: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    #[doc = " Closes the connection asynchronously, calls the on_disconnect callback.\n All uncompleted requests (publish/subscribe/unsubscribe) will be cancelled, regardless to the status of\n clean_session. DISCONNECT packet will be sent, which deletes the will message from server.\n\n \\param[in] connection    The connection to close\n \\param[in] on_disconnect (nullable) Callback function to invoke when the connection is completely disconnected.\n \\param[in] userdata      (nullable) passed to on_disconnect\n\n \\returns AWS_OP_SUCCESS if the connection is open and is being shutdown,\n              otherwise AWS_OP_ERR and aws_last_error() is set."]
    pub fn aws_mqtt_client_connection_disconnect(
        connection: *mut aws_mqtt_client_connection,
        on_disconnect: aws_mqtt_client_on_disconnect_fn,
        userdata: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    #[doc = " Subscribe to topic filters. on_publish will be called when a PUBLISH matching each topic_filter is received.\n\n \\param[in] connection        The connection to subscribe on\n \\param[in] topic_filters     An array_list of aws_mqtt_topic_subscription (NOT pointers) describing the requests.\n \\param[in] on_suback         (nullable) Called when a SUBACK has been received from the server and the subscription\n                              is complete.  Broker may fail one of the topics, check the qos in\n                              aws_mqtt_topic_subscription from the callback\n \\param[in] on_suback_ud      (nullable) Passed to on_suback\n\n \\returns The packet id of the subscribe packet if successfully sent, otherwise 0."]
    pub fn aws_mqtt_client_connection_subscribe_multiple(
        connection: *mut aws_mqtt_client_connection,
        topic_filters: *const aws_array_list,
        on_suback: aws_mqtt_suback_multi_fn,
        on_suback_ud: *mut ::core::ffi::c_void,
    ) -> u16;
    #[doc = " Subscribe to a single topic filter. on_publish will be called when a PUBLISH matching topic_filter is received.\n\n \\param[in] connection    The connection to subscribe on\n \\param[in] topic_filter  The topic filter to subscribe on.  This resource must persist until on_suback.\n \\param[in] qos           The maximum QoS of messages to receive\n \\param[in] on_publish    (nullable) Called when a PUBLISH packet matching topic_filter is received\n \\param[in] on_publish_ud (nullable) Passed to on_publish\n \\param[in] on_ud_cleanup (nullable) Called when a subscription is removed, on_publish_ud is passed.\n \\param[in] on_suback     (nullable) Called when a SUBACK has been received from the server and the subscription is\n                          complete\n \\param[in] on_suback_ud  (nullable) Passed to on_suback\n\n \\returns The packet id of the subscribe packet if successfully sent, otherwise 0."]
    pub fn aws_mqtt_client_connection_subscribe(
        connection: *mut aws_mqtt_client_connection,
        topic_filter: *const aws_byte_cursor,
        qos: aws_mqtt_qos,
        on_publish: aws_mqtt_client_publish_received_fn,
        on_publish_ud: *mut ::core::ffi::c_void,
        on_ud_cleanup: aws_mqtt_userdata_cleanup_fn,
        on_suback: aws_mqtt_suback_fn,
        on_suback_ud: *mut ::core::ffi::c_void,
    ) -> u16;
    #[doc = " Resubscribe to all topics currently subscribed to. This is to help when resuming a connection with a clean session.\n\n \\param[in] connection    The connection to subscribe on\n \\param[in] on_suback     (nullable) Called when a SUBACK has been received from the server and the subscription is\n                          complete\n \\param[in] on_suback_ud  (nullable) Passed to on_suback\n\n \\returns The packet id of the subscribe packet if successfully sent, otherwise 0 (and aws_last_error() will be set)."]
    pub fn aws_mqtt_resubscribe_existing_topics(
        connection: *mut aws_mqtt_client_connection,
        on_suback: aws_mqtt_suback_multi_fn,
        on_suback_ud: *mut ::core::ffi::c_void,
    ) -> u16;
    #[doc = " Unsubscribe to a topic filter.\n\n \\param[in] connection        The connection to unsubscribe on\n \\param[in] topic_filter      The topic filter to unsubscribe on. This resource must persist until on_unsuback.\n \\param[in] on_unsuback       (nullable) Called when a UNSUBACK has been received from the server and the subscription\n                              is removed\n \\param[in] on_unsuback_ud    (nullable) Passed to on_unsuback\n\n \\returns The packet id of the unsubscribe packet if successfully sent, otherwise 0."]
    pub fn aws_mqtt_client_connection_unsubscribe(
        connection: *mut aws_mqtt_client_connection,
        topic_filter: *const aws_byte_cursor,
        on_unsuback: aws_mqtt_op_complete_fn,
        on_unsuback_ud: *mut ::core::ffi::c_void,
    ) -> u16;
    #[doc = " Send a PUBLISH packet over connection.\n\n \\param[in] connection    The connection to publish on\n \\param[in] topic         The topic to publish on\n \\param[in] qos           The requested QoS of the packet\n \\param[in] retain        True to have the server save the packet, and send to all new subscriptions matching topic\n \\param[in] payload       The data to send as the payload of the publish\n \\param[in] on_complete   (nullable) For QoS 0, called as soon as the packet is sent\n                          For QoS 1, called when PUBACK is received\n                          For QoS 2, called when PUBCOMP is received\n \\param[in] user_data     (nullable) Passed to on_complete\n\n \\returns The packet id of the publish packet if successfully sent, otherwise 0."]
    pub fn aws_mqtt_client_connection_publish(
        connection: *mut aws_mqtt_client_connection,
        topic: *const aws_byte_cursor,
        qos: aws_mqtt_qos,
        retain: bool,
        payload: *const aws_byte_cursor,
        on_complete: aws_mqtt_op_complete_fn,
        userdata: *mut ::core::ffi::c_void,
    ) -> u16;
    #[doc = " Queries the connection's internal statistics for incomplete/unacked operations.\n \\param connection connection to get statistics for\n \\param stats set of incomplete/unacked operation statistics\n \\returns AWS_OP_SUCCESS if getting the operation statistics were successful, AWS_OP_ERR otherwise"]
    pub fn aws_mqtt_client_connection_get_stats(
        connection: *mut aws_mqtt_client_connection,
        stats: *mut aws_mqtt_connection_operation_statistics,
    ) -> ::core::ffi::c_int;
    #[doc = " Creates a new mqtt5 client using the supplied configuration\n\n @param allocator allocator to use with all memory operations related to this client's creation and operation\n @param options mqtt5 client configuration\n @return a new mqtt5 client or NULL"]
    pub fn aws_mqtt5_client_new(
        allocator: *mut aws_allocator,
        options: *const aws_mqtt5_client_options,
    ) -> *mut aws_mqtt5_client;
    #[doc = " Acquires a reference to an mqtt5 client\n\n @param client client to acquire a reference to.  May be NULL.\n @return what was passed in as the client (a client or NULL)"]
    pub fn aws_mqtt5_client_acquire(client: *mut aws_mqtt5_client) -> *mut aws_mqtt5_client;
    #[doc = " Release a reference to an mqtt5 client.  When the client ref count drops to zero, the client will automatically\n trigger a stop and once the stop completes, the client will delete itself.\n\n @param client client to release a reference to.  May be NULL.\n @return NULL"]
    pub fn aws_mqtt5_client_release(client: *mut aws_mqtt5_client) -> *mut aws_mqtt5_client;
    #[doc = " Asynchronous notify to the mqtt5 client that you want it to attempt to connect to the configured endpoint.\n The client will attempt to stay connected using the properties of the reconnect-related parameters\n in the mqtt5 client configuration.\n\n @param client mqtt5 client to start\n @return success/failure in the synchronous logic that kicks off the start process"]
    pub fn aws_mqtt5_client_start(client: *mut aws_mqtt5_client) -> ::core::ffi::c_int;
    #[doc = " Asynchronous notify to the mqtt5 client that you want it to transition to the stopped state.  When the client\n reaches the stopped state, all session state is erased.\n\n @param client mqtt5 client to stop\n @param disconnect_options (optional) properties of a DISCONNECT packet to send as part of the shutdown process\n @return success/failure in the synchronous logic that kicks off the stop process"]
    pub fn aws_mqtt5_client_stop(
        client: *mut aws_mqtt5_client,
        disconnect_options: *const aws_mqtt5_packet_disconnect_view,
        completion_options: *const aws_mqtt5_disconnect_completion_options,
    ) -> ::core::ffi::c_int;
    #[doc = " Queues a Publish operation in an mqtt5 client\n\n @param client mqtt5 client to queue a Publish for\n @param publish_options configuration options for the Publish operation\n @param completion_options completion callback configuration.  Successful QoS 0 publishes invoke the callback when\n the data has been written to the socket.  Successful QoS1+ publishes invoke the callback when the corresponding ack\n is received.  Unsuccessful publishes invoke the callback at the point in time a failure condition is reached.\n @return success/failure in the synchronous logic that kicks off the publish operation"]
    pub fn aws_mqtt5_client_publish(
        client: *mut aws_mqtt5_client,
        publish_options: *const aws_mqtt5_packet_publish_view,
        completion_options: *const aws_mqtt5_publish_completion_options,
    ) -> ::core::ffi::c_int;
    #[doc = " Queues a Subscribe operation in an mqtt5 client\n\n @param client mqtt5 client to queue a Subscribe for\n @param subscribe_options configuration options for the Subscribe operation\n @param completion_options Completion callback configuration.  Invoked when the corresponding SUBACK is received or\n a failure condition is reached.  An error code implies complete failure of the subscribe, while a success code\n implies the user must still check all of the SUBACK's reason codes for per-subscription feedback.\n @return success/failure in the synchronous logic that kicks off the Subscribe operation"]
    pub fn aws_mqtt5_client_subscribe(
        client: *mut aws_mqtt5_client,
        subscribe_options: *const aws_mqtt5_packet_subscribe_view,
        completion_options: *const aws_mqtt5_subscribe_completion_options,
    ) -> ::core::ffi::c_int;
    #[doc = " Queues an Unsubscribe operation in an mqtt5 client\n\n @param client mqtt5 client to queue an Unsubscribe for\n @param unsubscribe_options configuration options for the Unsubscribe operation\n @param completion_options Completion callback configuration.  Invoked when the corresponding UNSUBACK is received or\n a failure condition is reached.  An error code implies complete failure of the unsubscribe, while a success code\n implies the user must still check all of the UNSUBACK's reason codes for per-topic-filter feedback.\n @return success/failure in the synchronous logic that kicks off the Unsubscribe operation"]
    pub fn aws_mqtt5_client_unsubscribe(
        client: *mut aws_mqtt5_client,
        unsubscribe_options: *const aws_mqtt5_packet_unsubscribe_view,
        completion_options: *const aws_mqtt5_unsubscribe_completion_options,
    ) -> ::core::ffi::c_int;
    #[doc = " Queries the client's internal statistics for incomplete operations.\n @param client client to get statistics for\n @param stats set of incomplete operation statistics"]
    pub fn aws_mqtt5_client_get_stats(
        client: *mut aws_mqtt5_client,
        stats: *mut aws_mqtt5_client_operation_statistics,
    );
    #[doc = " Initializes the Client ID byte buf in negotiated settings\n\n @param allocator allocator to use for memory allocation\n @param negotiated_settings settings to apply client id to\n @param client_id client id to set"]
    pub fn aws_mqtt5_negotiated_settings_init(
        allocator: *mut aws_allocator,
        negotiated_settings: *mut aws_mqtt5_negotiated_settings,
        client_id: *const aws_byte_cursor,
    ) -> ::core::ffi::c_int;
    #[doc = " Makes an owning copy of a negotiated settings structure.\n\n @param source settings to copy from\n @param dest settings to copy into.  Must be in a zeroed or initialized state because it gets clean up\n  called on it as the first step of the copy process.\n @return success/failure\n\n Used in downstream."]
    pub fn aws_mqtt5_negotiated_settings_copy(
        source: *const aws_mqtt5_negotiated_settings,
        dest: *mut aws_mqtt5_negotiated_settings,
    ) -> ::core::ffi::c_int;
    #[doc = " Clean up owned memory in negotiated_settings\n\n @param negotiated_settings settings to clean up"]
    pub fn aws_mqtt5_negotiated_settings_clean_up(
        negotiated_settings: *mut aws_mqtt5_negotiated_settings,
    );
    #[doc = " Creates a new MQTT5 listener object.  For as long as the listener lives, incoming publishes and lifecycle events\n will be forwarded to the callbacks configured on the listener.\n\n @param allocator allocator to use\n @param config listener configuration\n @return a new aws_mqtt5_listener object"]
    pub fn aws_mqtt5_listener_new(
        allocator: *mut aws_allocator,
        config: *mut aws_mqtt5_listener_config,
    ) -> *mut aws_mqtt5_listener;
    #[doc = " Adds a reference to an mqtt5 listener.\n\n @param listener listener to add a reference to\n @return the listener object"]
    pub fn aws_mqtt5_listener_acquire(listener: *mut aws_mqtt5_listener)
        -> *mut aws_mqtt5_listener;
    #[doc = " Removes a reference to an mqtt5 listener.  When the reference count drops to zero, the listener's asynchronous\n destruction will be started.\n\n @param listener listener to remove a reference from\n @return NULL"]
    pub fn aws_mqtt5_listener_release(listener: *mut aws_mqtt5_listener)
        -> *mut aws_mqtt5_listener;
    pub fn aws_mqtt5_user_property_set_init_with_storage(
        property_set: *mut aws_mqtt5_user_property_set,
        allocator: *mut aws_allocator,
        storage_buffer: *mut aws_byte_buf,
        property_count: usize,
        properties: *const aws_mqtt5_user_property,
    ) -> ::core::ffi::c_int;
    pub fn aws_mqtt5_user_property_set_clean_up(property_set: *mut aws_mqtt5_user_property_set);
    pub fn aws_mqtt5_user_property_set_size(
        property_set: *const aws_mqtt5_user_property_set,
    ) -> usize;
    pub fn aws_mqtt5_packet_connect_storage_init(
        connect_storage: *mut aws_mqtt5_packet_connect_storage,
        allocator: *mut aws_allocator,
        connect_options: *const aws_mqtt5_packet_connect_view,
    ) -> ::core::ffi::c_int;
    pub fn aws_mqtt5_packet_connect_storage_init_from_external_storage(
        connect_storage: *mut aws_mqtt5_packet_connect_storage,
        allocator: *mut aws_allocator,
    ) -> ::core::ffi::c_int;
    pub fn aws_mqtt5_packet_connect_storage_clean_up(
        connect_storage: *mut aws_mqtt5_packet_connect_storage,
    );
    pub fn aws_mqtt5_packet_connack_storage_init(
        connack_storage: *mut aws_mqtt5_packet_connack_storage,
        allocator: *mut aws_allocator,
        connack_options: *const aws_mqtt5_packet_connack_view,
    ) -> ::core::ffi::c_int;
    pub fn aws_mqtt5_packet_connack_storage_init_from_external_storage(
        connack_storage: *mut aws_mqtt5_packet_connack_storage,
        allocator: *mut aws_allocator,
    ) -> ::core::ffi::c_int;
    pub fn aws_mqtt5_packet_connack_storage_clean_up(
        connack_storage: *mut aws_mqtt5_packet_connack_storage,
    );
    pub fn aws_mqtt5_packet_disconnect_storage_init(
        disconnect_storage: *mut aws_mqtt5_packet_disconnect_storage,
        allocator: *mut aws_allocator,
        disconnect_options: *const aws_mqtt5_packet_disconnect_view,
    ) -> ::core::ffi::c_int;
    pub fn aws_mqtt5_packet_disconnect_storage_init_from_external_storage(
        disconnect_storage: *mut aws_mqtt5_packet_disconnect_storage,
        allocator: *mut aws_allocator,
    ) -> ::core::ffi::c_int;
    pub fn aws_mqtt5_packet_disconnect_storage_clean_up(
        disconnect_storage: *mut aws_mqtt5_packet_disconnect_storage,
    );
    pub fn aws_mqtt5_packet_publish_storage_init(
        publish_storage: *mut aws_mqtt5_packet_publish_storage,
        allocator: *mut aws_allocator,
        publish_options: *const aws_mqtt5_packet_publish_view,
    ) -> ::core::ffi::c_int;
    pub fn aws_mqtt5_packet_publish_storage_init_from_external_storage(
        publish_storage: *mut aws_mqtt5_packet_publish_storage,
        allocator: *mut aws_allocator,
    ) -> ::core::ffi::c_int;
    pub fn aws_mqtt5_packet_publish_storage_clean_up(
        publish_storage: *mut aws_mqtt5_packet_publish_storage,
    );
    pub fn aws_mqtt5_packet_puback_storage_init(
        puback_storage: *mut aws_mqtt5_packet_puback_storage,
        allocator: *mut aws_allocator,
        puback_view: *const aws_mqtt5_packet_puback_view,
    ) -> ::core::ffi::c_int;
    pub fn aws_mqtt5_packet_puback_storage_init_from_external_storage(
        puback_storage: *mut aws_mqtt5_packet_puback_storage,
        allocator: *mut aws_allocator,
    ) -> ::core::ffi::c_int;
    pub fn aws_mqtt5_packet_puback_storage_clean_up(
        puback_storage: *mut aws_mqtt5_packet_puback_storage,
    );
    pub fn aws_mqtt5_packet_subscribe_storage_init(
        subscribe_storage: *mut aws_mqtt5_packet_subscribe_storage,
        allocator: *mut aws_allocator,
        subscribe_options: *const aws_mqtt5_packet_subscribe_view,
    ) -> ::core::ffi::c_int;
    pub fn aws_mqtt5_packet_subscribe_storage_init_from_external_storage(
        subscribe_storage: *mut aws_mqtt5_packet_subscribe_storage,
        allocator: *mut aws_allocator,
    ) -> ::core::ffi::c_int;
    pub fn aws_mqtt5_packet_subscribe_storage_clean_up(
        subscribe_storage: *mut aws_mqtt5_packet_subscribe_storage,
    );
    pub fn aws_mqtt5_packet_suback_storage_init(
        suback_storage: *mut aws_mqtt5_packet_suback_storage,
        allocator: *mut aws_allocator,
        suback_view: *const aws_mqtt5_packet_suback_view,
    ) -> ::core::ffi::c_int;
    pub fn aws_mqtt5_packet_suback_storage_init_from_external_storage(
        suback_storage: *mut aws_mqtt5_packet_suback_storage,
        allocator: *mut aws_allocator,
    ) -> ::core::ffi::c_int;
    pub fn aws_mqtt5_packet_suback_storage_clean_up(
        suback_storage: *mut aws_mqtt5_packet_suback_storage,
    );
    pub fn aws_mqtt5_packet_unsubscribe_storage_init(
        unsubscribe_storage: *mut aws_mqtt5_packet_unsubscribe_storage,
        allocator: *mut aws_allocator,
        unsubscribe_options: *const aws_mqtt5_packet_unsubscribe_view,
    ) -> ::core::ffi::c_int;
    pub fn aws_mqtt5_packet_unsubscribe_storage_init_from_external_storage(
        unsubscribe_storage: *mut aws_mqtt5_packet_unsubscribe_storage,
        allocator: *mut aws_allocator,
    ) -> ::core::ffi::c_int;
    pub fn aws_mqtt5_packet_unsubscribe_storage_clean_up(
        unsubscribe_storage: *mut aws_mqtt5_packet_unsubscribe_storage,
    );
    pub fn aws_mqtt5_packet_unsuback_storage_init(
        unsuback_storage: *mut aws_mqtt5_packet_unsuback_storage,
        allocator: *mut aws_allocator,
        unsuback_view: *const aws_mqtt5_packet_unsuback_view,
    ) -> ::core::ffi::c_int;
    pub fn aws_mqtt5_packet_unsuback_storage_init_from_external_storage(
        unsuback_storage: *mut aws_mqtt5_packet_unsuback_storage,
        allocator: *mut aws_allocator,
    ) -> ::core::ffi::c_int;
    pub fn aws_mqtt5_packet_unsuback_storage_clean_up(
        unsuback_storage: *mut aws_mqtt5_packet_unsuback_storage,
    );
}
