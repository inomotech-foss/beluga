/* automatically generated by rust-bindgen 0.69.1 */

pub type aws_event_stream_errors = ::core::ffi::c_uint;
pub type aws_event_stream_log_subject = ::core::ffi::c_uint;
pub type aws_event_stream_header_value_type = ::core::ffi::c_uint;
pub type aws_event_stream_process_state_fn = ::core::option::Option<
    unsafe extern "C" fn(
        decoder: *mut aws_event_stream_streaming_decoder,
        data: *const u8,
        len: usize,
        processed: *mut usize,
    ) -> ::core::ffi::c_int,
>;
#[doc = " Called by aws_aws_event_stream_streaming_decoder when payload data has been received.\n 'data' doesn't belong to you, so copy the data if it is needed beyond the scope of your callback.\n final_segment == 1 indicates the current data is the last payload buffer for that message."]
pub type aws_event_stream_process_on_payload_segment_fn = ::core::option::Option<
    unsafe extern "C" fn(
        decoder: *mut aws_event_stream_streaming_decoder,
        payload: *mut aws_byte_buf,
        final_segment: i8,
        user_data: *mut ::core::ffi::c_void,
    ),
>;
#[doc = " Called by aws_aws_event_stream_streaming_decoder when a new message has arrived. The prelude will contain metadata\n about the message. At this point no headers or payload have been received. prelude is copyable."]
pub type aws_event_stream_prelude_received_fn = ::core::option::Option<
    unsafe extern "C" fn(
        decoder: *mut aws_event_stream_streaming_decoder,
        prelude: *mut aws_event_stream_message_prelude,
        user_data: *mut ::core::ffi::c_void,
    ),
>;
#[doc = " Called by aws_aws_event_stream_streaming_decoder when a header is encountered. 'header' is not yours. Copy the data\n you want from it if your scope extends beyond your callback."]
pub type aws_event_stream_header_received_fn = ::core::option::Option<
    unsafe extern "C" fn(
        decoder: *mut aws_event_stream_streaming_decoder,
        prelude: *mut aws_event_stream_message_prelude,
        header: *mut aws_event_stream_header_value_pair,
        user_data: *mut ::core::ffi::c_void,
    ),
>;
#[doc = " Called by aws_aws_event_stream_streaming_decoder when a message decoding is complete\n and crc is verified."]
pub type aws_event_stream_on_complete_fn = ::core::option::Option<
    unsafe extern "C" fn(
        decoder: *mut aws_event_stream_streaming_decoder,
        message_crc: u32,
        user_data: *mut ::core::ffi::c_void,
    ),
>;
#[doc = " Called by aws_aws_event_stream_streaming_decoder when an error is encountered. The decoder is not in a good state for\n usage after this callback."]
pub type aws_event_stream_on_error_fn = ::core::option::Option<
    unsafe extern "C" fn(
        decoder: *mut aws_event_stream_streaming_decoder,
        prelude: *mut aws_event_stream_message_prelude,
        error_code: ::core::ffi::c_int,
        message: *const ::core::ffi::c_char,
        user_data: *mut ::core::ffi::c_void,
    ),
>;
#[doc = " Invoked when an aws_event_stream_message is encountered. If the message\n parsed successfully, message will be non-null and error_code will be AWS_ERROR_SUCCESS.\n Otherwise message will be null and error_code will represent the error that was encountered.\n Note that any case that error_code was not AWS_OP_SUCCESS, the channel also shuts down."]
pub type aws_event_stream_channel_handler_on_message_received_fn = ::core::option::Option<
    unsafe extern "C" fn(
        message: *mut aws_event_stream_message,
        error_code: ::core::ffi::c_int,
        user_data: *mut ::core::ffi::c_void,
    ),
>;
#[doc = " Invoked when an aws_event_stream_message is flushed to the IO interface. When error_code is AWS_ERROR_SUCCESS the\n write happened successfuly. Regardless, message is held from the aws_event_stream_channel_handler_write_message()\n call and should likely be freed in this callback. If error_code is non-zero, the channel will be shutdown immediately\n after this callback returns."]
pub type aws_event_stream_channel_handler_on_message_written_fn = ::core::option::Option<
    unsafe extern "C" fn(
        message: *mut aws_event_stream_message,
        error_code: ::core::ffi::c_int,
        user_data: *mut ::core::ffi::c_void,
    ),
>;
pub type aws_event_stream_rpc_message_type = ::core::ffi::c_uint;
pub type aws_event_stream_rpc_message_flag = ::core::ffi::c_uint;
#[doc = " Invoked when a connection receives a message on an existing stream. message_args contains the\n message data."]
pub type aws_event_stream_rpc_client_stream_continuation_fn = ::core::option::Option<
    unsafe extern "C" fn(
        token: *mut aws_event_stream_rpc_client_continuation_token,
        message_args: *const aws_event_stream_rpc_message_args,
        user_data: *mut ::core::ffi::c_void,
    ),
>;
#[doc = " Invoked when a continuation has either been closed with the TERMINATE_STREAM flag, or when the connection\n shuts down and deletes the continuation."]
pub type aws_event_stream_rpc_client_stream_continuation_closed_fn = ::core::option::Option<
    unsafe extern "C" fn(
        token: *mut aws_event_stream_rpc_client_continuation_token,
        user_data: *mut ::core::ffi::c_void,
    ),
>;
#[doc = " Invoked when a non-stream level message is received on a connection."]
pub type aws_event_stream_rpc_client_connection_protocol_message_fn = ::core::option::Option<
    unsafe extern "C" fn(
        connection: *mut aws_event_stream_rpc_client_connection,
        message_args: *const aws_event_stream_rpc_message_args,
        user_data: *mut ::core::ffi::c_void,
    ),
>;
#[doc = " Invoked when a successfully created connection is shutdown. error_code will indicate the reason for the shutdown."]
pub type aws_event_stream_rpc_client_on_connection_shutdown_fn = ::core::option::Option<
    unsafe extern "C" fn(
        connection: *mut aws_event_stream_rpc_client_connection,
        error_code: ::core::ffi::c_int,
        user_data: *mut ::core::ffi::c_void,
    ),
>;
#[doc = " Invoked when a connection attempt completes.\n\n If the attempt was unsuccessful, the error_code will be non-zero and the connection pointer will be NULL,\n and aws_event_stream_rpc_client_on_connection_shutdown_fn will not be invoked.\n\n If the attempt was successful, error_code will be 0 and the connection pointer will be valid.\n You must call aws_event_stream_rpc_client_connection_acquire()\n to prevent the pointer's memory from being destroyed before you are ready.\n When you are completely done with the connection pointer you must call\n aws_event_stream_rpc_client_connection_release() or its memory will leak.\n aws_event_stream_rpc_client_on_connection_shutdown_fn will be invoked\n when the network connection has closed. If you are done with the connection,\n but it is still open, you must call aws_aws_event_stream_rpc_client_close()\n or network connection will remain open, even if you call release()."]
pub type aws_event_stream_rpc_client_on_connection_setup_fn = ::core::option::Option<
    unsafe extern "C" fn(
        connection: *mut aws_event_stream_rpc_client_connection,
        error_code: ::core::ffi::c_int,
        user_data: *mut ::core::ffi::c_void,
    ),
>;
#[doc = " Invoked whenever a message has been flushed to the channel."]
pub type aws_event_stream_rpc_client_message_flush_fn = ::core::option::Option<
    unsafe extern "C" fn(error_code: ::core::ffi::c_int, user_data: *mut ::core::ffi::c_void),
>;
#[doc = " Invoked when a connection receives a message on an existing stream. message_args contains the\n message data."]
pub type aws_event_stream_rpc_server_stream_continuation_fn = ::core::option::Option<
    unsafe extern "C" fn(
        token: *mut aws_event_stream_rpc_server_continuation_token,
        message_args: *const aws_event_stream_rpc_message_args,
        user_data: *mut ::core::ffi::c_void,
    ),
>;
#[doc = " Invoked when a continuation has either been closed with the TERMINATE_STREAM flag, or when the connection\n shutsdown and deletes the continuation."]
pub type aws_event_stream_rpc_server_stream_continuation_closed_fn = ::core::option::Option<
    unsafe extern "C" fn(
        token: *mut aws_event_stream_rpc_server_continuation_token,
        user_data: *mut ::core::ffi::c_void,
    ),
>;
#[doc = " Invoked when a non-stream level message is received on a connection."]
pub type aws_event_stream_rpc_server_connection_protocol_message_fn = ::core::option::Option<
    unsafe extern "C" fn(
        connection: *mut aws_event_stream_rpc_server_connection,
        message_args: *const aws_event_stream_rpc_message_args,
        user_data: *mut ::core::ffi::c_void,
    ),
>;
#[doc = " Invoked when a new stream has been received on the connection. If you return AWS_OP_SUCCESS (0),\n You must fill in the fields for continuation options or the program will assert and exit.\n\n A failure path MUST leave the ref count of the continuation alone.\n\n A success path should probably take a ref which will leave the continuation (assuming no other interference)\n at two AFTER creation is complete: 1 for the connection's continuation table, and one for the callback\n recipient which is presumably tracking it as well."]
pub type aws_event_stream_rpc_server_on_incoming_stream_fn = ::core::option::Option<
    unsafe extern "C" fn(
        connection: *mut aws_event_stream_rpc_server_connection,
        token: *mut aws_event_stream_rpc_server_continuation_token,
        operation_name: aws_byte_cursor,
        continuation_options: *mut aws_event_stream_rpc_server_stream_continuation_options,
        user_data: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int,
>;
#[doc = " Invoked when a new connection is received on a server listener. If you return AWS_OP_SUCCESS,\n You must fill in the fields for connection_options or the program will assert and exit.\n\n If error_code is non-zero, an error occurred upon setting up the channel and connection will be NULL. Otherwise,\n connection is non-null. If you intend to seat a pointer to connection, you MUST call\n aws_event_stream_rpc_server_connection_acquire() and when you're finished with the connection you MUST call\n aws_event_stream_server_connection_release()."]
pub type aws_event_stream_rpc_server_on_new_connection_fn = ::core::option::Option<
    unsafe extern "C" fn(
        connection: *mut aws_event_stream_rpc_server_connection,
        error_code: ::core::ffi::c_int,
        connection_options: *mut aws_event_stream_rpc_connection_options,
        user_data: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int,
>;
#[doc = " Invoked when a successfully created connection is shutdown. error_code will indicate the reason for the shutdown."]
pub type aws_event_stream_rpc_server_on_connection_shutdown_fn = ::core::option::Option<
    unsafe extern "C" fn(
        connection: *mut aws_event_stream_rpc_server_connection,
        error_code: ::core::ffi::c_int,
        user_data: *mut ::core::ffi::c_void,
    ),
>;
#[doc = " Invoked whenever a message has been flushed to the channel."]
pub type aws_event_stream_rpc_server_message_flush_fn = ::core::option::Option<
    unsafe extern "C" fn(error_code: ::core::ffi::c_int, user_data: *mut ::core::ffi::c_void),
>;
#[doc = " (Optional). Invoked when the listener has been successfully shutdown (after the last ref count release)."]
pub type aws_event_stream_rpc_server_on_listener_destroy_fn = ::core::option::Option<
    unsafe extern "C" fn(
        server: *mut aws_event_stream_rpc_server_listener,
        user_data: *mut ::core::ffi::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_event_stream_message_prelude {
    pub total_len: u32,
    pub headers_len: u32,
    pub prelude_crc: u32,
}
#[repr(C)]
pub struct aws_event_stream_message {
    pub alloc: *mut aws_allocator,
    pub message_buffer: aws_byte_buf,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aws_event_stream_header_value_pair {
    pub header_name_len: u8,
    pub header_name: [::core::ffi::c_char; 127usize],
    pub header_value_type: aws_event_stream_header_value_type,
    pub header_value: aws_event_stream_header_value_pair__bindgen_ty_1,
    pub header_value_len: u16,
    pub value_owned: i8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aws_event_stream_streaming_decoder {
    pub alloc: *mut aws_allocator,
    pub working_buffer: [u8; 12usize],
    pub message_pos: usize,
    pub running_crc: u32,
    pub current_header_name_offset: usize,
    pub current_header_value_offset: usize,
    pub current_header: aws_event_stream_header_value_pair,
    pub prelude: aws_event_stream_message_prelude,
    pub state: aws_event_stream_process_state_fn,
    pub on_payload: aws_event_stream_process_on_payload_segment_fn,
    pub on_prelude: aws_event_stream_prelude_received_fn,
    pub on_header: aws_event_stream_header_received_fn,
    pub on_complete: aws_event_stream_on_complete_fn,
    pub on_error: aws_event_stream_on_error_fn,
    pub user_context: *mut ::core::ffi::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_event_stream_streaming_decoder_options {
    #[doc = " (Required)\n Invoked repeatedly as payload segment are received.\n See `aws_event_stream_process_on_payload_segment_fn`."]
    pub on_payload_segment: aws_event_stream_process_on_payload_segment_fn,
    #[doc = " (Required)\n Invoked when when a new message has arrived. The prelude will contain metadata about the message.\n See `aws_event_stream_prelude_received_fn`."]
    pub on_prelude: aws_event_stream_prelude_received_fn,
    #[doc = " (Required)\n Invoked repeatedly as headers are received.\n See `aws_event_stream_header_received_fn`."]
    pub on_header: aws_event_stream_header_received_fn,
    #[doc = " (Optional)\n Invoked if a message is decoded successfully.\n See `aws_event_stream_on_complete_fn`."]
    pub on_complete: aws_event_stream_on_complete_fn,
    #[doc = " (Required)\n Invoked when an error is encountered. The decoder is not in a good state for usage after this callback.\n See `aws_event_stream_on_error_fn`."]
    pub on_error: aws_event_stream_on_error_fn,
    #[doc = " (Optional)\n user_data passed to callbacks."]
    pub user_data: *mut ::core::ffi::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_event_stream_channel_handler {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_event_stream_channel_handler_options {
    #[doc = " Callback for when messages are received. Can not be null."]
    pub on_message_received: aws_event_stream_channel_handler_on_message_received_fn,
    #[doc = " user data passed to message callback. Optional"]
    pub user_data: *mut ::core::ffi::c_void,
    #[doc = " initial window size to use for the channel. If automatic window management is set to true, this value is\n ignored."]
    pub initial_window_size: usize,
    #[doc = " if set to false (the default), windowing will be managed automatically for the user.\n Otherwise, after any on_message_received, the user must invoke\n aws_event_stream_channel_handler_increment_read_window()"]
    pub manual_window_management: bool,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_event_stream_rpc_message_args {
    #[doc = " array of headers for an event-stream message."]
    pub headers: *mut aws_event_stream_header_value_pair,
    #[doc = " number of headers in the headers array.\n headers are copied in aws_event_stream_rpc_*_send_message()\n so you can free the memory immediately after calling it if you need to."]
    pub headers_count: usize,
    #[doc = " payload buffer for the message, payload is copied in aws_event_stream_rpc_*_send_message()\n so you can free the memory immediately after calling it if you need to."]
    pub payload: *mut aws_byte_buf,
    #[doc = " message type for the message. This will be added to the headers array\n and the \":message-type\" header should not be included in headers"]
    pub message_type: aws_event_stream_rpc_message_type,
    #[doc = " message flags for the message. This will be added to the headers array\n and the \":message-flags\" header should not be included in headers"]
    pub message_flags: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_event_stream_rpc_client_connection {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_event_stream_rpc_client_continuation_token {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_event_stream_rpc_client_stream_continuation_options {
    pub on_continuation: aws_event_stream_rpc_client_stream_continuation_fn,
    pub on_continuation_closed: aws_event_stream_rpc_client_stream_continuation_closed_fn,
    pub user_data: *mut ::core::ffi::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_event_stream_rpc_client_connection_options {
    #[doc = " host name to use for the connection. This depends on your socket type."]
    pub host_name: *const ::core::ffi::c_char,
    #[doc = " port to use for your connection, assuming for the appropriate socket type."]
    pub port: u32,
    #[doc = " socket options for establishing the connection to the RPC server."]
    pub socket_options: *mut aws_socket_options,
    #[doc = " optional: tls options for using when establishing your connection."]
    pub tls_options: *mut aws_tls_connection_options,
    pub bootstrap: *mut aws_client_bootstrap,
    pub on_connection_setup: aws_event_stream_rpc_client_on_connection_setup_fn,
    pub on_connection_protocol_message: aws_event_stream_rpc_client_connection_protocol_message_fn,
    pub on_connection_shutdown: aws_event_stream_rpc_client_on_connection_shutdown_fn,
    pub user_data: *mut ::core::ffi::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_event_stream_rpc_server_connection {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_event_stream_rpc_server_continuation_token {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_event_stream_rpc_server_stream_continuation_options {
    pub on_continuation: aws_event_stream_rpc_server_stream_continuation_fn,
    pub on_continuation_closed: aws_event_stream_rpc_server_stream_continuation_closed_fn,
    pub user_data: *mut ::core::ffi::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_event_stream_rpc_connection_options {
    pub on_incoming_stream: aws_event_stream_rpc_server_on_incoming_stream_fn,
    pub on_connection_protocol_message: aws_event_stream_rpc_server_connection_protocol_message_fn,
    pub user_data: *mut ::core::ffi::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_event_stream_rpc_server_listener {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_event_stream_rpc_server_listener_options {
    #[doc = " host name to use for the listener. This depends on your socket type."]
    pub host_name: *const ::core::ffi::c_char,
    #[doc = " port to use for your listener, assuming for the appropriate socket type."]
    pub port: u32,
    pub socket_options: *const aws_socket_options,
    #[doc = " optional: tls options for using when setting up your server."]
    pub tls_options: *const aws_tls_connection_options,
    pub bootstrap: *mut aws_server_bootstrap,
    pub on_new_connection: aws_event_stream_rpc_server_on_new_connection_fn,
    pub on_connection_shutdown: aws_event_stream_rpc_server_on_connection_shutdown_fn,
    pub on_destroy_callback: aws_event_stream_rpc_server_on_listener_destroy_fn,
    pub user_data: *mut ::core::ffi::c_void,
}
pub const AWS_C_EVENT_STREAM_PACKAGE_ID: u32 = 4;
pub const AWS_EVENT_STREAM_MAX_MESSAGE_SIZE: u32 = 16777216;
pub const AWS_EVENT_STREAM_MAX_HEADERS_SIZE: u32 = 131072;
pub const AWS_EVENT_STREAM_HEADER_NAME_LEN_MAX: u32 = 127;
pub const AWS_EVENT_STREAM_HEADER_STATIC_VALUE_LEN_MAX: u32 = 16;
pub const AWS_ERROR_EVENT_STREAM_BUFFER_LENGTH_MISMATCH: aws_event_stream_errors = 4096;
pub const AWS_ERROR_EVENT_STREAM_INSUFFICIENT_BUFFER_LEN: aws_event_stream_errors = 4097;
pub const AWS_ERROR_EVENT_STREAM_MESSAGE_FIELD_SIZE_EXCEEDED: aws_event_stream_errors = 4098;
pub const AWS_ERROR_EVENT_STREAM_PRELUDE_CHECKSUM_FAILURE: aws_event_stream_errors = 4099;
pub const AWS_ERROR_EVENT_STREAM_MESSAGE_CHECKSUM_FAILURE: aws_event_stream_errors = 4100;
pub const AWS_ERROR_EVENT_STREAM_MESSAGE_INVALID_HEADERS_LEN: aws_event_stream_errors = 4101;
pub const AWS_ERROR_EVENT_STREAM_MESSAGE_UNKNOWN_HEADER_TYPE: aws_event_stream_errors = 4102;
pub const AWS_ERROR_EVENT_STREAM_MESSAGE_PARSER_ILLEGAL_STATE: aws_event_stream_errors = 4103;
pub const AWS_ERROR_EVENT_STREAM_RPC_CONNECTION_CLOSED: aws_event_stream_errors = 4104;
pub const AWS_ERROR_EVENT_STREAM_RPC_PROTOCOL_ERROR: aws_event_stream_errors = 4105;
pub const AWS_ERROR_EVENT_STREAM_RPC_STREAM_CLOSED: aws_event_stream_errors = 4106;
pub const AWS_ERROR_EVENT_STREAM_RPC_STREAM_NOT_ACTIVATED: aws_event_stream_errors = 4107;
pub const AWS_ERROR_EVENT_STREAM_END_RANGE: aws_event_stream_errors = 5119;
pub const AWS_LS_EVENT_STREAM_GENERAL: aws_event_stream_log_subject = 4096;
pub const AWS_LS_EVENT_STREAM_CHANNEL_HANDLER: aws_event_stream_log_subject = 4097;
pub const AWS_LS_EVENT_STREAM_RPC_SERVER: aws_event_stream_log_subject = 4098;
pub const AWS_LS_EVENT_STREAM_RPC_CLIENT: aws_event_stream_log_subject = 4099;
pub const AWS_LS_EVENT_STREAM_LAST: aws_event_stream_log_subject = 5119;
pub const AWS_EVENT_STREAM_HEADER_BOOL_TRUE: aws_event_stream_header_value_type = 0;
pub const AWS_EVENT_STREAM_HEADER_BOOL_FALSE: aws_event_stream_header_value_type = 1;
pub const AWS_EVENT_STREAM_HEADER_BYTE: aws_event_stream_header_value_type = 2;
pub const AWS_EVENT_STREAM_HEADER_INT16: aws_event_stream_header_value_type = 3;
pub const AWS_EVENT_STREAM_HEADER_INT32: aws_event_stream_header_value_type = 4;
pub const AWS_EVENT_STREAM_HEADER_INT64: aws_event_stream_header_value_type = 5;
pub const AWS_EVENT_STREAM_HEADER_BYTE_BUF: aws_event_stream_header_value_type = 6;
pub const AWS_EVENT_STREAM_HEADER_STRING: aws_event_stream_header_value_type = 7;
pub const AWS_EVENT_STREAM_HEADER_TIMESTAMP: aws_event_stream_header_value_type = 8;
pub const AWS_EVENT_STREAM_HEADER_UUID: aws_event_stream_header_value_type = 9;
pub const AWS_EVENT_STREAM_RPC_MESSAGE_TYPE_APPLICATION_MESSAGE: aws_event_stream_rpc_message_type =
    0;
pub const AWS_EVENT_STREAM_RPC_MESSAGE_TYPE_APPLICATION_ERROR: aws_event_stream_rpc_message_type =
    1;
pub const AWS_EVENT_STREAM_RPC_MESSAGE_TYPE_PING: aws_event_stream_rpc_message_type = 2;
pub const AWS_EVENT_STREAM_RPC_MESSAGE_TYPE_PING_RESPONSE: aws_event_stream_rpc_message_type = 3;
pub const AWS_EVENT_STREAM_RPC_MESSAGE_TYPE_CONNECT: aws_event_stream_rpc_message_type = 4;
pub const AWS_EVENT_STREAM_RPC_MESSAGE_TYPE_CONNECT_ACK: aws_event_stream_rpc_message_type = 5;
pub const AWS_EVENT_STREAM_RPC_MESSAGE_TYPE_PROTOCOL_ERROR: aws_event_stream_rpc_message_type = 6;
pub const AWS_EVENT_STREAM_RPC_MESSAGE_TYPE_INTERNAL_ERROR: aws_event_stream_rpc_message_type = 7;
pub const AWS_EVENT_STREAM_RPC_MESSAGE_TYPE_COUNT: aws_event_stream_rpc_message_type = 8;
pub const AWS_EVENT_STREAM_RPC_MESSAGE_FLAG_CONNECTION_ACCEPTED: aws_event_stream_rpc_message_flag =
    1;
pub const AWS_EVENT_STREAM_RPC_MESSAGE_FLAG_TERMINATE_STREAM: aws_event_stream_rpc_message_flag = 2;
#[repr(C)]
#[derive(Copy, Clone)]
pub union aws_event_stream_header_value_pair__bindgen_ty_1 {
    pub variable_len_val: *mut u8,
    pub static_val: [u8; 16usize],
}
extern "C" {
    #[doc = " Initializes with a list of headers, the payload, and a payload length. CRCs will be computed for you.\n If headers or payload is NULL, then the fields will be appropriately set to indicate no headers and/or no payload.\n Both payload and headers will result in an allocation."]
    pub fn aws_event_stream_message_init(
        message: *mut aws_event_stream_message,
        alloc: *mut aws_allocator,
        headers: *const aws_array_list,
        payload: *const aws_byte_buf,
    ) -> ::core::ffi::c_int;
    #[doc = " Zero allocation, Zero copy. The message will simply wrap the buffer. The message functions are only useful as long as\n buffer is referencable memory."]
    pub fn aws_event_stream_message_from_buffer(
        message: *mut aws_event_stream_message,
        alloc: *mut aws_allocator,
        buffer: *mut aws_byte_buf,
    ) -> ::core::ffi::c_int;
    #[doc = " Allocates memory and copies buffer. Otherwise the same as aws_aws_event_stream_message_from_buffer. This is slower,\n but possibly safer."]
    pub fn aws_event_stream_message_from_buffer_copy(
        message: *mut aws_event_stream_message,
        alloc: *mut aws_allocator,
        buffer: *const aws_byte_buf,
    ) -> ::core::ffi::c_int;
    #[doc = " Cleans up any internally allocated memory. Always call this for API compatibility reasons, even if you only used the\n aws_aws_event_stream_message_from_buffer function."]
    pub fn aws_event_stream_message_clean_up(message: *mut aws_event_stream_message);
    #[doc = " Returns the total length of the message (including the length field)."]
    pub fn aws_event_stream_message_total_length(message: *const aws_event_stream_message) -> u32;
    #[doc = " Returns the length of the headers portion of the message."]
    pub fn aws_event_stream_message_headers_len(message: *const aws_event_stream_message) -> u32;
    #[doc = " Returns the prelude crc (crc32)"]
    pub fn aws_event_stream_message_prelude_crc(message: *const aws_event_stream_message) -> u32;
    #[doc = " Writes the message to fd in json format. All strings and binary fields are base64 encoded."]
    pub fn aws_event_stream_message_to_debug_str(
        fd: *mut FILE,
        message: *const aws_event_stream_message,
    ) -> ::core::ffi::c_int;
    #[doc = " Adds the headers for the message to list. The memory in each header is owned as part of the message, do not free it\n or pass its address around."]
    pub fn aws_event_stream_message_headers(
        message: *const aws_event_stream_message,
        headers: *mut aws_array_list,
    ) -> ::core::ffi::c_int;
    #[doc = " Returns a pointer to the beginning of the message payload."]
    pub fn aws_event_stream_message_payload(message: *const aws_event_stream_message) -> *const u8;
    #[doc = " Returns the length of the message payload."]
    pub fn aws_event_stream_message_payload_len(message: *const aws_event_stream_message) -> u32;
    #[doc = " Returns the checksum of the entire message (crc32)"]
    pub fn aws_event_stream_message_message_crc(message: *const aws_event_stream_message) -> u32;
    #[doc = " Returns the message as a buffer ready for transport."]
    pub fn aws_event_stream_message_buffer(message: *const aws_event_stream_message) -> *const u8;
    pub fn aws_event_stream_compute_headers_required_buffer_len(
        headers: *const aws_array_list,
    ) -> u32;
    #[doc = " Writes headers to buf assuming buf is large enough to hold the data. Prefer this function over the unsafe variant\n 'aws_event_stream_write_headers_to_buffer'.\n\n Returns AWS_OP_SUCCESS if the headers were successfully and completely written and AWS_OP_ERR otherwise."]
    pub fn aws_event_stream_write_headers_to_buffer_safe(
        headers: *const aws_array_list,
        buf: *mut aws_byte_buf,
    ) -> ::core::ffi::c_int;
    #[doc = " Deprecated in favor of 'aws_event_stream_write_headers_to_buffer_safe' as this API is unsafe.\n\n Writes headers to buffer and returns the length of bytes written to buffer. Assumes buffer is large enough to\n store the headers."]
    pub fn aws_event_stream_write_headers_to_buffer(
        headers: *const aws_array_list,
        buffer: *mut u8,
    ) -> usize;
    #[doc = " Get the headers from the buffer, store them in the headers list.\n the user's responsibility to cleanup the list when they are finished with it.\n no buffer copies happen here, the lifetime of the buffer, must outlive the usage of the headers.\n returns error codes defined in the public interface."]
    pub fn aws_event_stream_read_headers_from_buffer(
        headers: *mut aws_array_list,
        buffer: *const u8,
        headers_len: usize,
    ) -> ::core::ffi::c_int;
    #[doc = " Initialize a streaming decoder for messages with callbacks for usage\n and an optional user context pointer."]
    pub fn aws_event_stream_streaming_decoder_init_from_options(
        decoder: *mut aws_event_stream_streaming_decoder,
        allocator: *mut aws_allocator,
        options: *const aws_event_stream_streaming_decoder_options,
    );
    #[doc = " Deprecated. Use aws_event_stream_streaming_decoder_init_from_options instead.\n Initialize a streaming decoder for messages with callbacks for usage and an optional user context pointer."]
    pub fn aws_event_stream_streaming_decoder_init(
        decoder: *mut aws_event_stream_streaming_decoder,
        alloc: *mut aws_allocator,
        on_payload_segment: aws_event_stream_process_on_payload_segment_fn,
        on_prelude: aws_event_stream_prelude_received_fn,
        on_header: aws_event_stream_header_received_fn,
        on_error: aws_event_stream_on_error_fn,
        user_data: *mut ::core::ffi::c_void,
    );
    #[doc = " Currently, no memory is allocated inside aws_aws_event_stream_streaming_decoder, but for future API compatibility,\n you should call this when finished with it."]
    pub fn aws_event_stream_streaming_decoder_clean_up(
        decoder: *mut aws_event_stream_streaming_decoder,
    );
    #[doc = " initializes a headers list for you. It will default to a capacity of 4 in dynamic mode."]
    pub fn aws_event_stream_headers_list_init(
        headers: *mut aws_array_list,
        allocator: *mut aws_allocator,
    ) -> ::core::ffi::c_int;
    #[doc = " Cleans up the headers list. Also deallocates any headers that were the result of a copy flag for strings or buffer."]
    pub fn aws_event_stream_headers_list_cleanup(headers: *mut aws_array_list);
    #[doc = " Adds a string header to the list of headers. If copy is set to true, this will result in an allocation for the header\n value. Otherwise, the value will be set to the memory address of 'value'."]
    pub fn aws_event_stream_add_string_header(
        headers: *mut aws_array_list,
        name: *const ::core::ffi::c_char,
        name_len: u8,
        value: *const ::core::ffi::c_char,
        value_len: u16,
        copy: i8,
    ) -> ::core::ffi::c_int;
    pub fn aws_event_stream_create_string_header(
        name: aws_byte_cursor,
        value: aws_byte_cursor,
    ) -> aws_event_stream_header_value_pair;
    pub fn aws_event_stream_create_int32_header(
        name: aws_byte_cursor,
        value: i32,
    ) -> aws_event_stream_header_value_pair;
    #[doc = " Adds a byte header to the list of headers."]
    pub fn aws_event_stream_add_byte_header(
        headers: *mut aws_array_list,
        name: *const ::core::ffi::c_char,
        name_len: u8,
        value: i8,
    ) -> ::core::ffi::c_int;
    #[doc = " Adds a bool header to the list of headers."]
    pub fn aws_event_stream_add_bool_header(
        headers: *mut aws_array_list,
        name: *const ::core::ffi::c_char,
        name_len: u8,
        value: i8,
    ) -> ::core::ffi::c_int;
    #[doc = " adds a 16 bit integer to the list of headers."]
    pub fn aws_event_stream_add_int16_header(
        headers: *mut aws_array_list,
        name: *const ::core::ffi::c_char,
        name_len: u8,
        value: i16,
    ) -> ::core::ffi::c_int;
    #[doc = " adds a 32 bit integer to the list of headers."]
    pub fn aws_event_stream_add_int32_header(
        headers: *mut aws_array_list,
        name: *const ::core::ffi::c_char,
        name_len: u8,
        value: i32,
    ) -> ::core::ffi::c_int;
    #[doc = " adds a 64 bit integer to the list of headers."]
    pub fn aws_event_stream_add_int64_header(
        headers: *mut aws_array_list,
        name: *const ::core::ffi::c_char,
        name_len: u8,
        value: i64,
    ) -> ::core::ffi::c_int;
    #[doc = " Adds a byte-buffer header to the list of headers. If copy is set to true, this will result in an allocation for the\n header value. Otherwise, the value will be set to the memory address of 'value'."]
    pub fn aws_event_stream_add_bytebuf_header(
        headers: *mut aws_array_list,
        name: *const ::core::ffi::c_char,
        name_len: u8,
        value: *mut u8,
        value_len: u16,
        copy: i8,
    ) -> ::core::ffi::c_int;
    #[doc = " adds a 64 bit integer representing milliseconds since unix epoch to the list of headers."]
    pub fn aws_event_stream_add_timestamp_header(
        headers: *mut aws_array_list,
        name: *const ::core::ffi::c_char,
        name_len: u8,
        value: i64,
    ) -> ::core::ffi::c_int;
    #[doc = " adds a uuid buffer to the list of headers. Value must always be 16 bytes long."]
    pub fn aws_event_stream_add_uuid_header(
        headers: *mut aws_array_list,
        name: *const ::core::ffi::c_char,
        name_len: u8,
        value: *const u8,
    ) -> ::core::ffi::c_int;
    #[doc = " Adds a generic header to the list of headers.\n Makes a copy of the underlaying data."]
    pub fn aws_event_stream_add_header(
        headers: *mut aws_array_list,
        header: *const aws_event_stream_header_value_pair,
    ) -> ::core::ffi::c_int;
    #[doc = " Adds a boolean-valued header to a header list\n\n @param headers header list to add to\n @param name name of the header to add\n @param value value of the header to add\n @return AWS_OP_SUCCESS on success, AWS_OP_ERR on failure"]
    pub fn aws_event_stream_add_bool_header_by_cursor(
        headers: *mut aws_array_list,
        name: aws_byte_cursor,
        value: bool,
    ) -> ::core::ffi::c_int;
    #[doc = " Adds a byte-valued header to a header list\n\n @param headers header list to add to\n @param name name of the header to add\n @param value value of the header to add\n @return AWS_OP_SUCCESS on success, AWS_OP_ERR on failure"]
    pub fn aws_event_stream_add_byte_header_by_cursor(
        headers: *mut aws_array_list,
        name: aws_byte_cursor,
        value: i8,
    ) -> ::core::ffi::c_int;
    #[doc = " Adds a int16-valued header to a header list\n\n @param headers header list to add to\n @param name name of the header to add\n @param value value of the header to add\n @return AWS_OP_SUCCESS on success, AWS_OP_ERR on failure"]
    pub fn aws_event_stream_add_int16_header_by_cursor(
        headers: *mut aws_array_list,
        name: aws_byte_cursor,
        value: i16,
    ) -> ::core::ffi::c_int;
    #[doc = " Adds a int32-valued header to a header list\n\n @param headers header list to add to\n @param name name of the header to add\n @param value value of the header to add\n @return AWS_OP_SUCCESS on success, AWS_OP_ERR on failure"]
    pub fn aws_event_stream_add_int32_header_by_cursor(
        headers: *mut aws_array_list,
        name: aws_byte_cursor,
        value: i32,
    ) -> ::core::ffi::c_int;
    #[doc = " Adds a int64-valued header to a header list\n\n @param headers header list to add to\n @param name name of the header to add\n @param value value of the header to add\n @return AWS_OP_SUCCESS on success, AWS_OP_ERR on failure"]
    pub fn aws_event_stream_add_int64_header_by_cursor(
        headers: *mut aws_array_list,
        name: aws_byte_cursor,
        value: i64,
    ) -> ::core::ffi::c_int;
    #[doc = " Adds a string-valued header to a header list\n\n @param headers header list to add to\n @param name name of the header to add\n @param value value of the header to add\n @return AWS_OP_SUCCESS on success, AWS_OP_ERR on failure"]
    pub fn aws_event_stream_add_string_header_by_cursor(
        headers: *mut aws_array_list,
        name: aws_byte_cursor,
        value: aws_byte_cursor,
    ) -> ::core::ffi::c_int;
    #[doc = " Adds a byte_buf-valued header to a header list\n\n @param headers header list to add to\n @param name name of the header to add\n @param value value of the header to add\n @return AWS_OP_SUCCESS on success, AWS_OP_ERR on failure"]
    pub fn aws_event_stream_add_byte_buf_header_by_cursor(
        headers: *mut aws_array_list,
        name: aws_byte_cursor,
        value: aws_byte_cursor,
    ) -> ::core::ffi::c_int;
    #[doc = " Adds a timestamp-valued header to a header list\n\n @param headers header list to add to\n @param name name of the header to add\n @param value value of the header to add\n @return AWS_OP_SUCCESS on success, AWS_OP_ERR on failure"]
    pub fn aws_event_stream_add_timestamp_header_by_cursor(
        headers: *mut aws_array_list,
        name: aws_byte_cursor,
        value: i64,
    ) -> ::core::ffi::c_int;
    #[doc = " Adds a uuid-valued header to a header list\n\n @param headers header list to add to\n @param name name of the header to add\n @param value value of the header to add\n @return AWS_OP_SUCCESS on success, AWS_OP_ERR on failure"]
    pub fn aws_event_stream_add_uuid_header_by_cursor(
        headers: *mut aws_array_list,
        name: aws_byte_cursor,
        value: aws_byte_cursor,
    ) -> ::core::ffi::c_int;
    #[doc = " Returns the header name. Note: this value is not null terminated"]
    pub fn aws_event_stream_header_name(
        header: *mut aws_event_stream_header_value_pair,
    ) -> aws_byte_buf;
    #[doc = " Returns the header value as a string. Note: this value is not null terminated."]
    pub fn aws_event_stream_header_value_as_string(
        header: *mut aws_event_stream_header_value_pair,
    ) -> aws_byte_buf;
    #[doc = " Returns the header value as a byte"]
    pub fn aws_event_stream_header_value_as_byte(
        header: *mut aws_event_stream_header_value_pair,
    ) -> i8;
    #[doc = " Returns the header value as a boolean value."]
    pub fn aws_event_stream_header_value_as_bool(
        header: *mut aws_event_stream_header_value_pair,
    ) -> i8;
    #[doc = " Returns the header value as a 16 bit integer."]
    pub fn aws_event_stream_header_value_as_int16(
        header: *mut aws_event_stream_header_value_pair,
    ) -> i16;
    #[doc = " Returns the header value as a 32 bit integer."]
    pub fn aws_event_stream_header_value_as_int32(
        header: *mut aws_event_stream_header_value_pair,
    ) -> i32;
    #[doc = " Returns the header value as a 64 bit integer."]
    pub fn aws_event_stream_header_value_as_int64(
        header: *mut aws_event_stream_header_value_pair,
    ) -> i64;
    #[doc = " Returns the header value as a pointer to a byte buffer, call aws_event_stream_header_value_length to determine\n the length of the buffer."]
    pub fn aws_event_stream_header_value_as_bytebuf(
        header: *mut aws_event_stream_header_value_pair,
    ) -> aws_byte_buf;
    #[doc = " Returns the header value as a 64 bit integer representing milliseconds since unix epoch."]
    pub fn aws_event_stream_header_value_as_timestamp(
        header: *mut aws_event_stream_header_value_pair,
    ) -> i64;
    #[doc = " Returns the header value a byte buffer which is 16 bytes long. Represents a UUID."]
    pub fn aws_event_stream_header_value_as_uuid(
        header: *mut aws_event_stream_header_value_pair,
    ) -> aws_byte_buf;
    #[doc = " Returns the length of the header value buffer. This is mostly intended for string and byte buffer types."]
    pub fn aws_event_stream_header_value_length(
        header: *mut aws_event_stream_header_value_pair,
    ) -> u16;
    #[doc = " The main driver of the decoder. Pass data that should be decoded with its length. A likely use-case here is in\n response to a read event from an io-device"]
    pub fn aws_event_stream_streaming_decoder_pump(
        decoder: *mut aws_event_stream_streaming_decoder,
        data: *const aws_byte_buf,
    ) -> ::core::ffi::c_int;
    #[doc = " Initializes internal datastructures used by aws-c-event-stream.\n Must be called before using any functionality in aws-c-event-stream."]
    pub fn aws_event_stream_library_init(allocator: *mut aws_allocator);
    #[doc = " Clean up internal datastructures used by aws-c-event-stream.\n Must not be called until application is done using functionality in aws-c-event-stream."]
    pub fn aws_event_stream_library_clean_up();
    #[doc = " Allocates and initializes a new channel handler for processing aws_event_stream_message() events. Handler options\n must not be null."]
    pub fn aws_event_stream_channel_handler_new(
        allocator: *mut aws_allocator,
        handler_options: *const aws_event_stream_channel_handler_options,
    ) -> *mut aws_channel_handler;
    #[doc = " Writes an aws_event_stream_message() to the channel. Once the channel flushes or an error occurs, on_message_written\n will be invoked. message should stay valid until the callback is invoked. If an error an occurs, the channel will\n automatically be shutdown."]
    pub fn aws_event_stream_channel_handler_write_message(
        handler: *mut aws_channel_handler,
        message: *mut aws_event_stream_message,
        on_message_written: aws_event_stream_channel_handler_on_message_written_fn,
        user_data: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    #[doc = " Updates the read window for the channel if automatic_window_managemanet was set to false."]
    pub fn aws_event_stream_channel_handler_increment_read_window(
        handler: *mut aws_channel_handler,
        window_update_size: usize,
    );
    pub fn aws_event_stream_channel_handler_get_user_data(
        handler: *mut aws_channel_handler,
    ) -> *mut ::core::ffi::c_void;
    #[doc = " :message-type header name"]
    pub static aws_event_stream_rpc_message_type_name: aws_byte_cursor;
    #[doc = " :message-flags header name"]
    pub static aws_event_stream_rpc_message_flags_name: aws_byte_cursor;
    #[doc = " :stream-id header name"]
    pub static aws_event_stream_rpc_stream_id_name: aws_byte_cursor;
    #[doc = " operation header name."]
    pub static aws_event_stream_rpc_operation_name: aws_byte_cursor;
    #[doc = " Initiate a new connection. If this function returns AWS_OP_SUCESSS, the\n aws_event_stream_rpc_client_connection_options::on_connection_setup is guaranteed to be called exactly once. If that\n callback successfully creates a connection, aws_event_stream_rpc_client_connection_options::on_connection_shutdown\n will be invoked upon connection closure. However if the connection was never successfully setup,\n aws_event_stream_rpc_client_connection_options::on_connection_shutdown will not be invoked later."]
    pub fn aws_event_stream_rpc_client_connection_connect(
        allocator: *mut aws_allocator,
        conn_options: *const aws_event_stream_rpc_client_connection_options,
    ) -> ::core::ffi::c_int;
    pub fn aws_event_stream_rpc_client_connection_acquire(
        connection: *const aws_event_stream_rpc_client_connection,
    );
    pub fn aws_event_stream_rpc_client_connection_release(
        connection: *const aws_event_stream_rpc_client_connection,
    );
    #[doc = " Closes the connection if it is open and aws_event_stream_rpc_client_connection_options::on_connection_shutdown will\n be invoked upon shutdown. shutdown_error_code will indicate the reason for shutdown. For a graceful shutdown pass 0\n or AWS_ERROR_SUCCESS."]
    pub fn aws_event_stream_rpc_client_connection_close(
        connection: *mut aws_event_stream_rpc_client_connection,
        shutdown_error_code: ::core::ffi::c_int,
    );
    #[doc = " Returns true if the connection is open, false otherwise."]
    pub fn aws_event_stream_rpc_client_connection_is_open(
        connection: *const aws_event_stream_rpc_client_connection,
    ) -> bool;
    #[doc = " Sends a message on the connection. These must be connection level messages (not application messages).\n\n flush_fn will be invoked when the message has been successfully writen to the wire or when it fails.\n\n returns AWS_OP_SUCCESS if the message was successfully created and queued, and in that case flush_fn will always be\n invoked. Otherwise, flush_fn will not be invoked."]
    pub fn aws_event_stream_rpc_client_connection_send_protocol_message(
        connection: *mut aws_event_stream_rpc_client_connection,
        message_args: *const aws_event_stream_rpc_message_args,
        flush_fn: aws_event_stream_rpc_client_message_flush_fn,
        user_data: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    #[doc = " Create a new stream. continuation_option's callbacks will not be invoked, and nothing will be sent across the wire\n until aws_event_stream_rpc_client_continuation_activate() is invoked.\n\n returns an instance of a aws_event_stream_rpc_client_continuation_token on success with a reference count of 1. You\n must call aws_event_stream_rpc_client_continuation_release() when you're finished with it. Returns NULL on failure."]
    pub fn aws_event_stream_rpc_client_connection_new_stream(
        connection: *mut aws_event_stream_rpc_client_connection,
        continuation_options: *const aws_event_stream_rpc_client_stream_continuation_options,
    ) -> *mut aws_event_stream_rpc_client_continuation_token;
    pub fn aws_event_stream_rpc_client_continuation_acquire(
        continuation: *const aws_event_stream_rpc_client_continuation_token,
    );
    pub fn aws_event_stream_rpc_client_continuation_release(
        continuation: *const aws_event_stream_rpc_client_continuation_token,
    );
    #[doc = " returns true if the continuation has been closed."]
    pub fn aws_event_stream_rpc_client_continuation_is_closed(
        continuation: *const aws_event_stream_rpc_client_continuation_token,
    ) -> bool;
    #[doc = " Actually sends the initial stream to the peer. Callbacks from aws_event_stream_rpc_client_connection_new_stream()\n will actually be invoked if this function returns AWS_OP_SUCCESS, otherwise, the stream has not been queued and no\n callbacks will be invoked.\n\n operation_name is the name to identify which logical rpc call you want to kick off with the peer. It must be\n non-empty. flush_fn will be invoked once the message has either been written to the wire or it fails."]
    pub fn aws_event_stream_rpc_client_continuation_activate(
        continuation: *mut aws_event_stream_rpc_client_continuation_token,
        operation_name: aws_byte_cursor,
        message_args: *const aws_event_stream_rpc_message_args,
        flush_fn: aws_event_stream_rpc_client_message_flush_fn,
        user_data: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    pub fn aws_event_stream_rpc_client_continuation_get_user_data(
        continuation: *mut aws_event_stream_rpc_client_continuation_token,
    ) -> *mut ::core::ffi::c_void;
    #[doc = " Sends a message on the continuation. aws_event_stream_rpc_client_continuation_activate() must be successfully invoked\n prior to calling this function.\n\n If this function returns AWS_OP_SUCCESS, flush_fn will be invoked once the message has either been written to the\n wire or it fails."]
    pub fn aws_event_stream_rpc_client_continuation_send_message(
        continuation: *mut aws_event_stream_rpc_client_continuation_token,
        message_args: *const aws_event_stream_rpc_message_args,
        flush_fn: aws_event_stream_rpc_client_message_flush_fn,
        user_data: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    #[doc = " Creates a listener with a ref count of 1. You are responsible for calling\n aws_event_stream_rpc_server_listener_release() when you're finished with the listener. Returns NULL if an error\n occurs."]
    pub fn aws_event_stream_rpc_server_new_listener(
        allocator: *mut aws_allocator,
        options: *mut aws_event_stream_rpc_server_listener_options,
    ) -> *mut aws_event_stream_rpc_server_listener;
    pub fn aws_event_stream_rpc_server_listener_acquire(
        listener: *mut aws_event_stream_rpc_server_listener,
    );
    pub fn aws_event_stream_rpc_server_listener_release(
        listener: *mut aws_event_stream_rpc_server_listener,
    );
    #[doc = " Get the local port which the listener's socket is bound to."]
    pub fn aws_event_stream_rpc_server_listener_get_bound_port(
        listener: *const aws_event_stream_rpc_server_listener,
    ) -> u32;
    #[doc = " Bypasses server, and creates a connection on an already existing channel. No connection lifetime callbacks will be\n invoked on the returned connection. Returns NULL if an error occurs. If and only if, you use this API, the returned\n connection is already ref counted and you must call aws_event_stream_rpc_server_connection_release() even if you did\n not explictly call aws_event_stream_rpc_server_connection_acquire()"]
    pub fn aws_event_stream_rpc_server_connection_from_existing_channel(
        server: *mut aws_event_stream_rpc_server_listener,
        channel: *mut aws_channel,
        connection_options: *const aws_event_stream_rpc_connection_options,
    ) -> *mut aws_event_stream_rpc_server_connection;
    pub fn aws_event_stream_rpc_server_connection_acquire(
        connection: *mut aws_event_stream_rpc_server_connection,
    );
    pub fn aws_event_stream_rpc_server_connection_release(
        connection: *mut aws_event_stream_rpc_server_connection,
    );
    pub fn aws_event_stream_rpc_server_connection_get_user_data(
        connection: *mut aws_event_stream_rpc_server_connection,
    ) -> *mut ::core::ffi::c_void;
    #[doc = " returns true if the connection is open. False otherwise."]
    pub fn aws_event_stream_rpc_server_connection_is_open(
        connection: *mut aws_event_stream_rpc_server_connection,
    ) -> bool;
    #[doc = " Closes the connection (including all continuations on the connection), and releases the connection ref count.\n shutdown_error_code is the error code to use when shutting down the channel. Use AWS_ERROR_SUCCESS for non-error\n cases."]
    pub fn aws_event_stream_rpc_server_connection_close(
        connection: *mut aws_event_stream_rpc_server_connection,
        shutdown_error_code: ::core::ffi::c_int,
    );
    #[doc = " Sends a protocol message on the connection (not application data). If the message is valid and successfully written\n to the channel, flush_fn will be invoked."]
    pub fn aws_event_stream_rpc_server_connection_send_protocol_message(
        connection: *mut aws_event_stream_rpc_server_connection,
        message_args: *const aws_event_stream_rpc_message_args,
        flush_fn: aws_event_stream_rpc_server_message_flush_fn,
        user_data: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    pub fn aws_event_stream_rpc_server_continuation_acquire(
        continuation: *mut aws_event_stream_rpc_server_continuation_token,
    );
    pub fn aws_event_stream_rpc_server_continuation_release(
        continuation: *mut aws_event_stream_rpc_server_continuation_token,
    );
    #[doc = " returns true if the continuation is still in an open state."]
    pub fn aws_event_stream_rpc_server_continuation_is_closed(
        continuation: *mut aws_event_stream_rpc_server_continuation_token,
    ) -> bool;
    #[doc = " Sends an application message on the continuation. If the message is valid and successfully written\n to the channel, flush_fn will be invoked."]
    pub fn aws_event_stream_rpc_server_continuation_send_message(
        continuation: *mut aws_event_stream_rpc_server_continuation_token,
        message_args: *const aws_event_stream_rpc_message_args,
        flush_fn: aws_event_stream_rpc_server_message_flush_fn,
        user_data: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
}
